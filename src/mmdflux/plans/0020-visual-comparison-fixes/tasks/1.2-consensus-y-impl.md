# Task 1.2: Implement Consensus-Y in `resolve_attachment_points`

## Objective
Modify `resolve_attachment_points()` to compute a shared y-coordinate for LR/RL edges, ensuring horizontal segments instead of H-V-H paths.

## Location
Modify: `src/render/router.rs`, function `resolve_attachment_points` (lines ~300-347)

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

*(Tests from Task 1.1)*

### ðŸŸ¢ Green: Minimal Implementation

Replace the independent `center_y()` calls in the LR/RL branches with a consensus y:

```rust
Direction::LeftRight => {
    let consensus_y = (from_bounds.center_y() + to_bounds.center_y()) / 2;
    // Clamp to both nodes' valid y-ranges
    let clamped_y = consensus_y
        .max(from_bounds.y)
        .min(from_bounds.y + from_bounds.height - 1)
        .max(to_bounds.y)
        .min(to_bounds.y + to_bounds.height - 1);

    let src = match src_override {
        Some(s) => s,
        None => (from_bounds.x + from_bounds.width - 1, clamped_y),
    };
    let tgt = match tgt_override {
        Some(t) => t,
        None => (to_bounds.x, clamped_y),
    };
    return (src, tgt);
}
```

Apply the same pattern for `Direction::RightLeft` (source on left face, target on right face):

```rust
Direction::RightLeft => {
    let consensus_y = (from_bounds.center_y() + to_bounds.center_y()) / 2;
    let clamped_y = consensus_y
        .max(from_bounds.y)
        .min(from_bounds.y + from_bounds.height - 1)
        .max(to_bounds.y)
        .min(to_bounds.y + to_bounds.height - 1);

    let src = match src_override {
        Some(s) => s,
        None => (from_bounds.x, clamped_y),
    };
    let tgt = match tgt_override {
        Some(t) => t,
        None => (to_bounds.x + to_bounds.width - 1, clamped_y),
    };
    return (src, tgt);
}
```

**Key considerations:**
- When one side has an override, the other side still uses consensus y (the override point provides the other half)
- When both sides have overrides, return them as-is (no consensus needed)
- Clamping prevents attachment points outside node boundaries
- If ranges don't overlap (vertically disjoint nodes), the H-V-H path is correct â€” but this shouldn't happen for same-rank nodes in practice

### ðŸ”µ Refactor: Clean Up

- Extract the consensus_y computation into a helper: `fn consensus_y(a: &NodeBounds, b: &NodeBounds) -> usize`
- Consider whether override points should influence the consensus (currently they don't)

## Context
- See [q1-lr-edge-routing.md](../../../research/0013-visual-comparison-fixes/q1-lr-edge-routing.md) for root cause analysis
- The function is called from `route_edge()` and `route_backward_edge()` in the same file
- After this change, `build_orthogonal_path_for_direction()` will receive `start.y == end.y` for same-rank LR/RL edges, producing a single horizontal segment

## Acceptance Criteria
- [ ] Failing tests from Task 1.1 pass
- [ ] `cargo test --test integration` passes (no regression)
- [ ] `left_right.mmd` renders with horizontal arrows, not vertical

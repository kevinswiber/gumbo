# Task 3.2: Arrow Overwrite Protection

## Objective
Prevent later edges' line-drawing characters from overwriting existing arrow characters on the canvas.

## Location
Modify: `src/render/edge.rs`, function `draw_arrow_with_entry` (lines ~518-535)

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[test]
fn test_arrow_not_overwritten_by_line() {
    let charset = CharSet::unicode();
    let mut canvas = Canvas::new(20, 10);

    // Draw an arrow at position (5, 3)
    draw_arrow_with_entry(&mut canvas, &Point { x: 5, y: 3 }, AttachDirection::Top, &charset);
    assert_eq!(canvas.get(5, 3).unwrap().ch, charset.arrow_down);

    // Draw a vertical line through that position
    render_segment(&mut canvas, &Segment::Vertical { x: 5, y_start: 1, y_end: 5 }, &charset);

    // Arrow should be preserved, not overwritten by line character
    assert_eq!(canvas.get(5, 3).unwrap().ch, charset.arrow_down,
        "Arrow should not be overwritten by line segment");
}
```

**What the failing test asserts:** Arrow characters survive being overwritten by subsequent line-drawing operations.
**Expected failure reason:** `canvas.set()` unconditionally overwrites.

### ðŸŸ¢ Green: Minimal Implementation

Option A: Protect in `draw_arrow_with_entry` (draw arrow last):
This doesn't help if edges are drawn sequentially and a later edge's line overwrites an earlier edge's arrow.

Option B: Protect in the line-drawing code â€” before setting a cell to a line character, check if it's already an arrow:

```rust
// In render_segment or wherever line characters are drawn:
fn set_if_not_arrow(canvas: &mut Canvas, x: usize, y: usize, ch: char, charset: &CharSet) {
    if let Some(existing) = canvas.get(x, y) {
        if is_arrow_char(existing.ch, charset) {
            return; // Don't overwrite arrow
        }
    }
    canvas.set(x, y, ch);
}

fn is_arrow_char(ch: char, charset: &CharSet) -> bool {
    ch == charset.arrow_down || ch == charset.arrow_up
        || ch == charset.arrow_left || ch == charset.arrow_right
}
```

Option C: Draw all edges' lines first, then all arrows as a second pass. This is a larger refactor.

**Recommended:** Option B â€” minimal change, targeted protection.

### ðŸ”µ Refactor: Clean Up

- Extract `is_arrow_char()` as a method on `CharSet`
- Consider whether other special characters (junction characters) also need protection

## Context
- See [q3-attachment-point-ordering.md](../../../research/0013-visual-comparison-fixes/q3-attachment-point-ordering.md) â€” issue 8
- `draw_arrow_with_entry` is at `src/render/edge.rs` lines ~518-535
- The canvas `set()` method is at `src/render/canvas.rs`
- Edges are rendered sequentially; a later edge's line segment can overwrite an earlier edge's arrow

## Acceptance Criteria
- [ ] Arrow characters are preserved when line segments cross them
- [ ] Both Unicode and ASCII arrow characters are protected
- [ ] `cargo test --test integration` passes

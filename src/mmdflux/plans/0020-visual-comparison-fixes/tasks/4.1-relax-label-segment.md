# Task 4.1: Relax `select_label_segment_horizontal` Filtering

## Objective
Make `select_label_segment_horizontal` less likely to return `None` by including boundary segments in its search.

## Location
Modify: `src/render/edge.rs`, function `select_label_segment_horizontal` (lines ~423-451)

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[test]
fn test_select_label_segment_finds_boundary_horizontal() {
    // Path with only boundary horizontal segments (first and last)
    let segments = vec![
        Segment::Horizontal { y: 5, x_start: 0, x_end: 10 },
        Segment::Vertical { x: 10, y_start: 5, y_end: 15 },
        Segment::Horizontal { y: 15, x_start: 10, x_end: 20 },
    ];

    let result = select_label_segment_horizontal(&segments);
    assert!(result.is_some(), "Should find a horizontal segment even if only boundary ones exist");
}
```

**What the failing test asserts:** The function finds a horizontal segment even when only boundary segments exist.
**Expected failure reason:** Current filtering may exclude first/last segments for certain path lengths.

### ðŸŸ¢ Green: Minimal Implementation

Review the existing logic and ensure the fallback chain includes boundary segments:

```rust
fn select_label_segment_horizontal(segments: &[Segment]) -> Option<&Segment> {
    // Prefer inner horizontal segments (not first or last)
    let inner = segments.iter()
        .enumerate()
        .filter(|&(i, _)| i > 0 && i < segments.len() - 1)
        .filter(|(_, s)| matches!(s, Segment::Horizontal { .. }))
        .map(|(_, s)| s)
        .next();

    if inner.is_some() {
        return inner;
    }

    // Fall back to any horizontal segment (including boundary)
    segments.iter()
        .rev()
        .find(|s| matches!(s, Segment::Horizontal { .. }))
}
```

### ðŸ”µ Refactor: Clean Up

- Verify the function is only called from `draw_edge_label_with_tracking`
- Document the preference order (inner first, then any)

## Context
- See [q5-lr-label-placement.md](../../../research/0013-visual-comparison-fixes/q5-lr-label-placement.md)
- This function selects which segment to place the label on
- The caller falls back to an averaged midpoint when this returns `None`

## Acceptance Criteria
- [ ] Function returns a segment for paths that have at least one horizontal segment
- [ ] Inner segments are still preferred when available
- [ ] No regression in existing label placement

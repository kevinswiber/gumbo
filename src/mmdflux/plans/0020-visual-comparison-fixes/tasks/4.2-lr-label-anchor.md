# Task 4.2: Fix LR Fallback to Use Anchor Y

## Objective
When `select_label_segment_horizontal` returns `None` for LR/RL edges, anchor the label's y-coordinate to the source exit point instead of using an averaged midpoint that falls in empty space.

## Location
Modify: `src/render/edge.rs`, function `draw_edge_label_with_tracking` (lines ~104-137, specifically the `else` branch around lines 118-122)

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[test]
fn test_lr_backward_label_near_source() {
    // LR diagram with a labeled backward edge spanning 2+ ranks
    let input = "graph LR\n    A --> B --> C\n    C -->|back| A";
    let flowchart = parse_flowchart(input).unwrap();
    let diagram = build_diagram(&flowchart);
    let config = RenderConfig::default();
    let layout = compute_layout_direct(&diagram, &config);

    // Render and check label position
    let output = render(&layout, &config);

    // The label "back" should appear near the source node (C), not in empty space
    // Find the line containing "back" and verify it's within a few rows of node C's position
    let label_line = output.lines()
        .enumerate()
        .find(|(_, line)| line.contains("back"))
        .map(|(i, _)| i);

    assert!(label_line.is_some(), "Label 'back' should appear in output");

    // Find node C's approximate y-position
    let c_line = output.lines()
        .enumerate()
        .find(|(_, line)| line.contains("C"))
        .map(|(i, _)| i);

    if let (Some(label_y), Some(c_y)) = (label_line, c_line) {
        let distance = if label_y > c_y { label_y - c_y } else { c_y - label_y };
        assert!(distance <= 3, "Label should be within 3 rows of source node, got distance {}", distance);
    }
}
```

**What the failing test asserts:** LR backward edge labels appear near the source node, not in empty space.
**Expected failure reason:** Current fallback uses averaged midpoint which falls between nodes.

### ðŸŸ¢ Green: Minimal Implementation

In the `else` branch of `draw_edge_label_with_tracking` for LR/RL:

```rust
// Current (broken):
let mid_y = (routed.start.y + routed.end.y) / 2;
let mid_x = (routed.start.x + routed.end.x) / 2;
(mid_x.saturating_sub(label_len / 2), mid_y)

// Fixed: anchor to source's y-coordinate
let anchor_y = routed.start.y;
let mid_x = (routed.start.x + routed.end.x) / 2;
(mid_x.saturating_sub(label_len / 2), anchor_y.saturating_sub(1))
```

For RL, use `routed.end.y` as anchor (target is on the left in RL).

### ðŸ”µ Refactor: Clean Up

- Add a comment explaining why the anchor y is used instead of averaged midpoint
- Verify label doesn't overlap with the source node itself (the `.saturating_sub(1)` offset)

## Context
- See [q5-lr-label-placement.md](../../../research/0013-visual-comparison-fixes/q5-lr-label-placement.md)
- The fallback is reached when no horizontal segment is found for label placement
- For backward edges, the path snakes around the diagram, so the midpoint is in empty space

## Acceptance Criteria
- [ ] LR backward edge labels appear near the source node
- [ ] No label overlaps with nodes
- [ ] `labeled_edges.mmd` and `label_spacing.mmd` still render correctly

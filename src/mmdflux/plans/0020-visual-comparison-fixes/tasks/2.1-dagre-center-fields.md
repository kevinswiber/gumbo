# Task 2.1: Add `dagre_center` Fields to `NodeBounds`

## Objective
Add optional `dagre_center_x` and `dagre_center_y` fields to `NodeBounds` so that `center_x()` and `center_y()` return the original dagre-derived center, avoiding integer division rounding errors.

## Location
Modify: `src/render/shape.rs` (struct `NodeBounds` and its methods)

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[test]
fn test_node_bounds_dagre_center_overrides_integer_division() {
    // Two nodes with different widths but same dagre center
    let a = NodeBounds { x: 40, y: 0, width: 9, height: 3, dagre_center_x: Some(44), dagre_center_y: None };
    let b = NodeBounds { x: 41, y: 5, width: 7, height: 3, dagre_center_x: Some(44), dagre_center_y: None };

    assert_eq!(a.center_x(), 44);
    assert_eq!(b.center_x(), 44);
    // Without dagre_center_x, a.center_x() = 40 + 9/2 = 44, b.center_x() = 41 + 7/2 = 44
    // But if x values were off by 1 (e.g., a.x=40, b.x=42), we'd get 44 vs 45
}

#[test]
fn test_node_bounds_dagre_center_y_overrides() {
    let a = NodeBounds { x: 0, y: 2, width: 5, height: 3, dagre_center_x: None, dagre_center_y: Some(3) };
    let b = NodeBounds { x: 0, y: 4, width: 5, height: 5, dagre_center_x: None, dagre_center_y: Some(6) };

    assert_eq!(a.center_y(), 3);
    assert_eq!(b.center_y(), 6);
}

#[test]
fn test_node_bounds_fallback_without_dagre_center() {
    // Without dagre centers, falls back to integer division
    let bounds = NodeBounds { x: 10, y: 5, width: 8, height: 4, dagre_center_x: None, dagre_center_y: None };
    assert_eq!(bounds.center_x(), 14); // 10 + 8/2
    assert_eq!(bounds.center_y(), 7);  // 5 + 4/2
}
```

**What the failing test asserts:** `center_x()` and `center_y()` return the stored dagre center when present.
**Expected failure reason:** `NodeBounds` doesn't have `dagre_center_x/y` fields yet.

### ðŸŸ¢ Green: Minimal Implementation

```rust
#[derive(Debug, Clone)]
pub struct NodeBounds {
    pub x: usize,
    pub y: usize,
    pub width: usize,
    pub height: usize,
    pub dagre_center_x: Option<usize>,
    pub dagre_center_y: Option<usize>,
}

impl NodeBounds {
    pub fn center_x(&self) -> usize {
        self.dagre_center_x.unwrap_or(self.x + self.width / 2)
    }

    pub fn center_y(&self) -> usize {
        self.dagre_center_y.unwrap_or(self.y + self.height / 2)
    }
}
```

### ðŸ”µ Refactor: Clean Up

- Ensure all existing `NodeBounds` construction sites compile with the new fields (add `dagre_center_x: None, dagre_center_y: None` everywhere)
- This may temporarily break compilation â€” Task 2.3 fixes all sites

## Context
- See [q4-centering-jog-analysis.md](../../../research/0013-visual-comparison-fixes/q4-centering-jog-analysis.md) for root cause
- `NodeBounds` is constructed in multiple places across `layout.rs`, `shape.rs`, and tests
- `center_x()` is called from: `resolve_attachment_points()`, `calculate_attachment_points()`, `classify_face()`, `intersect_rect()`, `sort_face_group()`, `offset_from_boundary()`

## Acceptance Criteria
- [ ] Failing tests written and confirmed red
- [ ] `NodeBounds` has new fields
- [ ] `center_x()` and `center_y()` use stored dagre centers when present
- [ ] Fallback to integer division when `None`

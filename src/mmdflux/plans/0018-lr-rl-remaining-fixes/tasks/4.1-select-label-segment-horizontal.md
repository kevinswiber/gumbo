# Task 4.1: Add select_label_segment_horizontal()

## Objective
Add a function to select the best horizontal segment for placing edge labels on LR/RL multi-segment paths. Analogous to `select_label_segment()` (line 349) which handles TD/BT vertical segments.

## Location
Modify: `src/render/edge.rs` — add function and tests

## TDD Cycle

### RED: Write failing tests

Add tests in `src/render/edge.rs` in the existing `#[cfg(test)] mod tests` (line 622). These reference `select_label_segment_horizontal()` which doesn't exist yet, so they won't compile.

```rust
#[test]
fn test_select_label_segment_horizontal_short_path() {
    use super::super::router::Segment;
    // 3-segment H-V-H forward path
    let segments = vec![
        Segment::Horizontal { y: 5, x_start: 10, x_end: 20 },
        Segment::Vertical { x: 20, y_start: 5, y_end: 10 },
        Segment::Horizontal { y: 10, x_start: 20, x_end: 30 },
    ];
    let chosen = select_label_segment_horizontal(&segments);
    // For short paths, should return the last horizontal segment
    match chosen {
        Some(Segment::Horizontal { y, .. }) => assert_eq!(*y, 10),
        _ => panic!("Expected last horizontal segment at y=10"),
    }
}

#[test]
fn test_select_label_segment_horizontal_long_path() {
    use super::super::router::Segment;
    // 7-segment backward edge path (like LR backward routing)
    let segments = vec![
        Segment::Horizontal { y: 3, x_start: 50, x_end: 55 },   // short exit stub
        Segment::Vertical { x: 55, y_start: 3, y_end: 12 },
        Segment::Horizontal { y: 12, x_start: 55, x_end: 5 },   // long bottom run (50 chars)
        Segment::Vertical { x: 5, y_start: 12, y_end: 3 },
        Segment::Horizontal { y: 3, x_start: 5, x_end: 10 },    // short entry stub
        Segment::Vertical { x: 10, y_start: 3, y_end: 5 },
        Segment::Horizontal { y: 5, x_start: 10, x_end: 15 },
    ];
    let chosen = select_label_segment_horizontal(&segments);
    // For long paths, should return the longest inner horizontal segment (50 chars at y=12)
    match chosen {
        Some(Segment::Horizontal { y, .. }) => assert_eq!(*y, 12),
        _ => panic!("Expected longest inner horizontal segment at y=12"),
    }
}

#[test]
fn test_select_label_segment_horizontal_no_horizontal() {
    use super::super::router::Segment;
    // Edge case: only vertical segments
    let segments = vec![
        Segment::Vertical { x: 5, y_start: 0, y_end: 10 },
    ];
    let chosen = select_label_segment_horizontal(&segments);
    assert!(chosen.is_none(), "Should return None when no horizontal segments exist");
}
```

**Run:** `cargo test --lib render::edge::tests` — expect compile error (`select_label_segment_horizontal` not found).

### GREEN: Minimal implementation

Add the function near `select_label_segment()` (line 384):

```rust
/// Select the best horizontal segment for label placement on LR/RL edges.
///
/// Analogous to `select_label_segment()` for TD/BT vertical segments.
/// For long paths (backward edges, 6+ segments), returns the longest inner horizontal segment.
/// For shorter paths, returns the last horizontal segment.
fn select_label_segment_horizontal(segments: &[Segment]) -> Option<&Segment> {
    let is_long_path = segments.len() >= 6;

    if is_long_path {
        let inner = if segments.len() > 2 {
            &segments[1..segments.len() - 1]
        } else {
            segments
        };
        inner
            .iter()
            .filter(|s| matches!(s, Segment::Horizontal { .. }))
            .max_by_key(|s| match s {
                Segment::Horizontal { x_start, x_end, .. } => {
                    (*x_start as isize - *x_end as isize).unsigned_abs()
                }
                _ => 0,
            })
            .or_else(|| {
                segments
                    .iter()
                    .rev()
                    .find(|s| matches!(s, Segment::Horizontal { .. }))
            })
    } else {
        segments
            .iter()
            .rev()
            .find(|s| matches!(s, Segment::Horizontal { .. }))
    }
}
```

**Run:** `cargo test --lib render::edge::tests` — all three new tests should pass.

### REFACTOR

The structure mirrors `select_label_segment()` exactly (just swapping Vertical↔Horizontal). Consider whether a generic helper could serve both, but that's likely over-engineering for two functions. No refactoring needed.

## Context
- `Segment` is defined in `router.rs:29` — may need `use super::router::Segment` in the test module
- The `abs_diff` method on `usize` exists but may not work if `x_start > x_end`; the `isize` cast + `unsigned_abs()` approach handles both directions
- See [q3-lr-label-placement.md](../../../research/0011-lr-rl-rendering-issues/q3-lr-label-placement.md)

## Acceptance Criteria
- [ ] Three tests fail (compile error) before implementation, pass after
- [ ] Short path: returns last horizontal segment
- [ ] Long path: returns longest inner horizontal segment
- [ ] No horizontal segments: returns None

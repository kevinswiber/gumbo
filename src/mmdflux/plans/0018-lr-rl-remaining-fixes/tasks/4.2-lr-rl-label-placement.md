# Task 4.2: Rewrite LR/RL Label Placement

## Objective
Replace the naive midpoint label placement for LR/RL with segment-aware placement using `select_label_segment_horizontal()` (Issues 5/6).

## Location
Modify: `src/render/edge.rs` — `Direction::LeftRight` branch (lines ~104-123) and `Direction::RightLeft` branch (lines ~125-145) in `draw_edge_label_with_tracking()`

## TDD Cycle

### RED: Write failing test

Add an integration-level test in `src/render/edge.rs` (test module at line 622) that renders an LR diagram with a labeled multi-segment edge and verifies the label Y-coordinate is near an actual edge segment, not at the naive midpoint.

```rust
#[test]
fn test_lr_label_placement_near_edge_segment() {
    use super::super::layout::{LayoutConfig, compute_layout};
    use super::super::router::route_edge;
    use crate::graph::{Diagram, Direction, Edge, Node};

    // Create a simple LR diagram with a labeled edge
    let mut diagram = Diagram::new(Direction::LeftRight);
    diagram.add_node(Node::new("A").with_label("Start"));
    diagram.add_node(Node::new("B").with_label("End"));
    let mut edge = Edge::new("A", "B");
    edge.label = Some("test".to_string());
    diagram.add_edge(edge);

    let config = LayoutConfig::default();
    let layout = compute_layout(&diagram, &config);
    let charset = CharSet::unicode();

    let routed = route_edge(
        &diagram.edges[0], &layout, Direction::LeftRight, None, None,
    ).unwrap();

    // Check that the routed edge has segments
    assert!(!routed.segments.is_empty(), "Routed edge should have segments");

    // Render the edge with label
    let mut canvas = Canvas::new(layout.width, layout.height);
    render_edge(&mut canvas, &routed, &charset, Direction::LeftRight);

    let output = canvas.to_string();
    // The label "test" should appear in the output
    assert!(
        output.contains("test"),
        "Label 'test' should appear in output:\n{}",
        output
    );

    // Collect the Y coordinates of all horizontal segments
    let seg_ys: Vec<usize> = routed.segments.iter().filter_map(|s| match s {
        Segment::Horizontal { y, .. } => Some(*y),
        _ => None,
    }).collect();

    // Find where "test" appears in the output
    let lines: Vec<&str> = output.lines().collect();
    let label_line = lines.iter().position(|l| l.contains("test"))
        .expect("Label should be on some line");

    // The label should be within 1 row of an actual horizontal segment
    let near_segment = seg_ys.iter().any(|&sy| sy.abs_diff(label_line) <= 1);
    assert!(
        near_segment,
        "Label at line {} should be within 1 row of a segment (segments at y={:?})",
        label_line, seg_ys
    );
}
```

**Run:** `cargo test --lib render::edge::tests::test_lr_label_placement`

**Expected failure:** With naive midpoint placement, the label Y may not be near any actual segment. This depends on the specific routed path geometry — the test may need tuning during RED phase. If the simple A→B forward edge happens to pass (midpoint matches the segment), extend the test with a backward edge or multi-node LR diagram where the midpoint demonstrably misses.

**Alternative/additional RED test for backward edges:**

```rust
#[test]
fn test_lr_backward_edge_label_near_path() {
    use super::super::layout::{LayoutConfig, compute_layout};
    use crate::graph::{Diagram, Direction, Edge, Node};

    // Create LR diagram where B→A is a backward edge
    let mut diagram = Diagram::new(Direction::LeftRight);
    diagram.add_node(Node::new("A").with_label("A"));
    diagram.add_node(Node::new("B").with_label("B"));
    diagram.add_edge(Edge::new("A", "B"));
    let mut back_edge = Edge::new("B", "A");
    back_edge.label = Some("back".to_string());
    diagram.add_edge(back_edge);

    let config = LayoutConfig::default();
    let layout = compute_layout(&diagram, &config);
    let charset = CharSet::unicode();

    // Render entire diagram
    let mut canvas = Canvas::new(layout.width, layout.height);
    // render nodes + edges...
    // Then check that "back" label is near an actual edge segment
    let output = canvas.to_string();
    // (Assertions about label proximity to segments)
}
```

The exact test may need refinement during RED phase based on what the Layout and routing APIs actually return. The key assertion is: **label Y coordinate is within 1 row of an actual horizontal edge segment**.

### GREEN: Minimal implementation

Replace the `Direction::LeftRight` branch (lines ~104-123) in `draw_edge_label_with_tracking()`:

```rust
Direction::LeftRight => {
    if routed.segments.len() >= 3 {
        if let Some(Segment::Horizontal { y, x_start, x_end }) =
            select_label_segment_horizontal(&routed.segments)
        {
            let seg_min_x = (*x_start).min(*x_end);
            let seg_max_x = (*x_start).max(*x_end);
            let seg_len = seg_max_x - seg_min_x;
            let label_x = if seg_len >= label_len {
                seg_min_x + (seg_len - label_len) / 2
            } else {
                seg_min_x
            };
            (label_x, y.saturating_sub(1))
        } else {
            let mid_y = (routed.start.y + routed.end.y) / 2;
            let mid_x = (routed.start.x + routed.end.x) / 2;
            (mid_x.saturating_sub(label_len / 2), mid_y)
        }
    } else {
        // Short/straight path — keep existing inline placement
        let mid_y = (routed.start.y + routed.end.y) / 2;
        let max_label_end = routed.end.x.saturating_sub(1);
        let min_x = routed.start.x.saturating_add(1);
        let available = max_label_end.saturating_sub(routed.start.x);
        let label_x = if available >= label_len {
            let centered = routed.start.x + (available - label_len) / 2;
            let max_x = max_label_end.saturating_sub(label_len);
            centered.max(min_x).min(max_x)
        } else {
            min_x
        };
        (label_x, mid_y)
    }
}
```

Apply the same pattern to the `Direction::RightLeft` branch.

**Run:** `cargo test --lib render::edge::tests` — should pass.

### REFACTOR

The LR and RL branches share the multi-segment logic. Consider extracting the shared segment-selection + label-positioning into a helper, but only if the duplication is significant. The fallback (short path) differs between LR and RL, so full deduplication may not be clean. Run `cargo test` to verify no regressions.

## Context
- `select_label_segment_horizontal()` must exist first (task 4.1)
- Label placed at `y.saturating_sub(1)` — one row above the chosen horizontal segment
- `find_safe_label_position()` (called at line ~150) handles collision avoidance
- See [q3-lr-label-placement.md](../../../research/0011-lr-rl-rendering-issues/q3-lr-label-placement.md)

## Acceptance Criteria
- [ ] Test fails before implementation (label at wrong Y), passes after
- [ ] LR multi-segment edge labels appear near actual edge segments
- [ ] RL edges have analogous behavior
- [ ] Short/straight edges keep existing inline placement
- [ ] `cargo test` passes

# Task 2.1: Add edge_sep and Dummy-Aware Separation

## Objective
Add an `edge_sep` parameter matching dagre.js's `edgesep`, and use it for dummy node separation in BK compaction. This is the structural change (types + logic). Direction-aware defaults come in task 2.3.

## Location
Modify:
- `src/dagre/types.rs` — Add `edge_sep` to `LayoutConfig`
- `src/dagre/bk.rs` — Add `edge_sep` to `BKConfig`, use in `place_block()`
- `src/dagre/position.rs` — Pass `edge_sep` when constructing `BKConfig`
- `src/render/layout.rs` — Add `edge_sep` to `DagreConfig` construction

## Background

In dagre.js, `sep()` differentiates dummy vs real nodes:
```javascript
sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
```
Our `bk.rs:739` uses `config.node_sep` unconditionally.

## TDD Cycle

### RED: Write failing tests

Add three tests in `src/dagre/bk.rs` in the existing `#[cfg(test)]` module. These tests reference the `edge_sep` field which doesn't exist yet, so they won't compile. That's the expected RED state — a compile error is a valid failing test.

**Test 1: Dummy-dummy separation uses edge_sep**

```rust
#[test]
fn test_edge_sep_for_dummy_nodes() {
    let mut lg = LayoutGraph::new();
    let d0 = lg.add_node_with_id("d0", 1.0, 1.0);
    let d1 = lg.add_node_with_id("d1", 1.0, 1.0);
    lg.set_dummy(d0, true);
    lg.set_dummy(d1, true);
    lg.ranks = vec![0, 0];
    lg.order = vec![0, 1];

    let alignment = BlockAlignment::new(&[d0, d1]);
    let config = BKConfig {
        node_sep: 50.0,
        edge_sep: 10.0,
        direction: Direction::TopBottom,
    };
    let result = horizontal_compaction(&lg, &alignment, &config);

    let x0 = result.x.get(&d0).unwrap();
    let x1 = result.x.get(&d1).unwrap();
    let actual_sep = x1 - x0;

    // Two dummy nodes: separation = width/2 + width/2 + edge_sep = 0.5 + 0.5 + 10.0 = 11.0
    let expected_min = 1.0 / 2.0 + 1.0 / 2.0 + 10.0;
    assert!(
        actual_sep >= expected_min - 0.01,
        "Dummy separation {} should be >= {} (edge_sep=10)",
        actual_sep, expected_min
    );
    // Must NOT use node_sep (would give 51.0)
    let node_sep_min = 1.0 / 2.0 + 1.0 / 2.0 + 50.0;
    assert!(
        actual_sep < node_sep_min,
        "Dummy separation {} should be < {} (should NOT use node_sep)",
        actual_sep, node_sep_min
    );
}
```

**Test 2: Real-real separation unchanged**

```rust
#[test]
fn test_real_nodes_still_use_node_sep() {
    let mut lg = LayoutGraph::new();
    let a = lg.add_node_with_id("A", 100.0, 50.0);
    let b = lg.add_node_with_id("B", 100.0, 50.0);
    lg.ranks = vec![0, 0];
    lg.order = vec![0, 1];

    let alignment = BlockAlignment::new(&[a, b]);
    let config = BKConfig {
        node_sep: 50.0,
        edge_sep: 10.0,
        direction: Direction::TopBottom,
    };
    let result = horizontal_compaction(&lg, &alignment, &config);

    let x0 = result.x.get(&a).unwrap();
    let x1 = result.x.get(&b).unwrap();
    let actual_sep = x1 - x0;

    // Two real nodes: separation = 50 + 50 + 50 = 150
    let expected_min = 100.0 / 2.0 + 100.0 / 2.0 + 50.0;
    assert!(
        actual_sep >= expected_min - 0.01,
        "Real node separation {} should be >= {} (node_sep=50)",
        actual_sep, expected_min
    );
}
```

**Test 3: Mixed dummy/real separation**

```rust
#[test]
fn test_mixed_dummy_real_separation() {
    let mut lg = LayoutGraph::new();
    let real = lg.add_node_with_id("R", 100.0, 50.0);
    let dummy = lg.add_node_with_id("d", 1.0, 1.0);
    lg.set_dummy(dummy, true);
    lg.ranks = vec![0, 0];
    lg.order = vec![0, 1];

    let alignment = BlockAlignment::new(&[real, dummy]);
    let config = BKConfig {
        node_sep: 50.0,
        edge_sep: 10.0,
        direction: Direction::TopBottom,
    };
    let result = horizontal_compaction(&lg, &alignment, &config);

    let x_real = result.x.get(&real).unwrap();
    let x_dummy = result.x.get(&dummy).unwrap();
    let actual_sep = x_dummy - x_real;

    // Mixed: sep = (node_sep + edge_sep) / 2 = (50+10)/2 = 30
    // min_separation = 50 + 0.5 + 30 = 80.5
    let expected_min = 100.0 / 2.0 + 1.0 / 2.0 + (50.0 + 10.0) / 2.0;
    assert!(
        actual_sep >= expected_min - 0.01,
        "Mixed separation {} should be >= {} (avg of node_sep and edge_sep)",
        actual_sep, expected_min
    );
}
```

**Run:** `cargo test --lib dagre::bk` — expect compile errors (no `edge_sep` field).

**Note:** Also check whether `add_node_with_id` or `set_dummy` exist on `LayoutGraph`. If not, use whatever API is available (the tests in 2.2 had pseudo-code; adapt to actual API during RED phase).

### GREEN: Minimal implementation

**Step 1:** Add `edge_sep: f64` to `LayoutConfig` in `types.rs` with default `20.0`.

**Step 2:** Add `edge_sep: f64` to `BKConfig` in `bk.rs` with default `20.0`.

**Step 3:** In `place_block()` at `bk.rs:739`, replace:
```rust
let min_separation = (left_width + node_width) / 2.0 + config.node_sep;
```
with:
```rust
let left_sep = if is_dummy(graph, left) { config.edge_sep } else { config.node_sep };
let node_s = if is_dummy(graph, node) { config.edge_sep } else { config.node_sep };
let sep = (left_sep + node_s) / 2.0;
let min_separation = (left_width + node_width) / 2.0 + sep;
```

**Step 4:** In `position.rs:90-93`, pass `edge_sep`:
```rust
let bk_config = BKConfig {
    node_sep: config.node_sep,
    edge_sep: config.edge_sep,
    direction: config.direction,
};
```

**Step 5:** In `layout.rs:240-245`, add `edge_sep: 20.0` to the `DagreConfig` construction.

**Step 6:** Fix all existing `BKConfig` literals in tests to include `edge_sep: 20.0`.

**Run:** `cargo test --lib dagre::bk` — all three new tests and all existing tests should pass.

### REFACTOR

No structural refactoring needed. Run `cargo test` to confirm no regressions.

## Context
- The `is_dummy()` function is already available in `bk.rs` (line 287)
- See [dagre-edge-points-analysis.md](../../../research/archive/0009-attachment-point-spreading/dagre-edge-points-analysis.md) lines 291-357

## Acceptance Criteria
- [ ] Three new tests fail (compile error) before implementation
- [ ] All three pass after implementation
- [ ] All existing BK tests still pass (updated to include `edge_sep` field)
- [ ] `cargo test` passes

# Task 3.1: Post-BK Source Centering

## Objective
Center layer-0 source nodes among their successors' coordinates after BK assignment, fixing the off-center source in LR fan-out layouts (Issue 2).

## Location
Modify: `src/dagre/position.rs` — `assign_horizontal()` function

## TDD Cycle

### RED: Write failing test

Add a test in `src/render/layout.rs` (test module at line 1222) that verifies the source node is vertically centered among its targets in an LR fan-out.

```rust
#[test]
fn test_lr_source_centered_among_targets() {
    use crate::graph::{Diagram, Direction, Edge, Node};

    let mut diagram = Diagram::new(Direction::LeftRight);
    diagram.add_node(Node::new("A").with_label("A"));
    diagram.add_node(Node::new("B").with_label("B"));
    diagram.add_node(Node::new("C").with_label("C"));
    diagram.add_node(Node::new("D").with_label("D"));
    diagram.add_edge(Edge::new("A", "B"));
    diagram.add_edge(Edge::new("A", "C"));
    diagram.add_edge(Edge::new("A", "D"));

    let config = LayoutConfig::default();
    let layout = compute_layout(&diagram, &config);

    let a_pos = layout.nodes.get("A").expect("A should exist");
    let a_bounds = layout.node_bounds.get("A").expect("A bounds should exist");
    let b_pos = layout.nodes.get("B").expect("B should exist");
    let b_bounds = layout.node_bounds.get("B").expect("B bounds should exist");
    let d_pos = layout.nodes.get("D").expect("D should exist");
    let d_bounds = layout.node_bounds.get("D").expect("D bounds should exist");

    // Compute vertical centers
    let a_center = a_pos.y as f64 + a_bounds.height as f64 / 2.0;

    // The range of targets spans from top of B to bottom of D
    let targets_top = b_pos.y.min(d_pos.y) as f64;
    let targets_bottom = (b_pos.y + b_bounds.height).max(d_pos.y + d_bounds.height) as f64;
    let targets_center = (targets_top + targets_bottom) / 2.0;

    // A's center should be within 2 rows of the targets' center
    let offset = (a_center - targets_center).abs();
    assert!(
        offset <= 2.0,
        "Source A center ({}) should be within 2 rows of targets center ({}), offset={}",
        a_center, targets_center, offset
    );
}
```

**Run:** `cargo test --lib render::layout::tests::test_lr_source_centered`

**Expected failure:** A's center will be aligned with B (the first child) rather than centered among B, C, D. The offset will be > 2.

**Note:** Check the actual Layout struct API during RED phase — the field names (`nodes`, `node_bounds`) may differ. Adapt the test to match.

### GREEN: Minimal implementation

In `assign_horizontal()` (`position.rs:83`), after `let y_coords = position_x(graph, &bk_config);` (line 94), add:

```rust
let mut y_coords = y_coords;

// Post-BK centering: center layer-0 source nodes among their successors.
// BK aligns via predecessors; layer-0 nodes have none, so they default to
// their first child's position instead of being centered.
if !layers.is_empty() {
    for &node in &layers[0] {
        let has_predecessors = graph
            .graph
            .edges_directed(node, petgraph::Direction::Incoming)
            .next()
            .is_some();
        if has_predecessors {
            continue;
        }

        let succ_ys: Vec<f64> = graph
            .graph
            .edges_directed(node, petgraph::Direction::Outgoing)
            .map(|e| e.target())
            .filter_map(|s| y_coords.get(&s).copied())
            .collect();

        if succ_ys.len() >= 2 {
            let min_y = succ_ys.iter().copied().fold(f64::INFINITY, f64::min);
            let max_y = succ_ys.iter().copied().fold(f64::NEG_INFINITY, f64::max);
            y_coords.insert(node, (min_y + max_y) / 2.0);
        }
    }
}
```

**Run:** `cargo test --lib render::layout::tests::test_lr_source_centered` — should pass.

### REFACTOR

- The `has_predecessors` check could be inlined, but the explicit variable improves readability. No refactoring needed.
- Run `cargo test` to verify no TD/BT regressions. `assign_horizontal` is only called for LR/RL layouts (`assign_vertical` handles TD/BT).

## Context
- `layers` is the layer assignment already available in `assign_horizontal()`
- `position_x()` returns `HashMap<NodeIndex, f64>` — must rebind as `let mut`
- Only applies to layer-0 nodes with no predecessors and 2+ successors
- See [q4-lr-centering-and-spacing.md](../../../research/0011-lr-rl-rendering-issues/q4-lr-centering-and-spacing.md)

## Acceptance Criteria
- [ ] `test_lr_source_centered_among_targets` fails before implementation, passes after
- [ ] TD/BT layouts unchanged (`cargo test` passes)

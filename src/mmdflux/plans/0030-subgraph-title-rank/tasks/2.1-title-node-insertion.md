# Task 2.1: Create Title Dummy Node in `nesting::run()`

## Objective
For compounds with titles, insert a title dummy node and wire it into the nesting chain: `root â†’ title â†’ border_top â†’ children â†’ border_bottom`.

## Location
Modify: `src/dagre/nesting.rs`

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[test]
fn test_nesting_run_adds_title_node_for_titled_compound() {
    let mut g: DiGraph<(f64, f64)> = DiGraph::new();
    g.add_node("A", (10.0, 10.0));
    g.add_node("B", (10.0, 10.0));
    g.add_node("sg1", (0.0, 0.0));
    g.add_edge("A", "B");
    g.set_parent("A", "sg1");
    g.set_parent("B", "sg1");
    g.set_has_title("sg1");
    let mut lg = LayoutGraph::from_digraph(&g, |_, dims| *dims);
    let sg1_idx = lg.node_index[&"sg1".into()];

    run(&mut lg);

    // Title node should exist
    assert!(lg.border_title.contains_key(&sg1_idx));
    let title_idx = lg.border_title[&sg1_idx];
    // Title node should have ID pattern _tt_sg1
    assert_eq!(lg.node_ids[title_idx], NodeId::from("_tt_sg1"));
}

#[test]
fn test_nesting_run_no_title_node_for_untitled_compound() {
    let mut g: DiGraph<(f64, f64)> = DiGraph::new();
    g.add_node("A", (10.0, 10.0));
    g.add_node("B", (10.0, 10.0));
    g.add_node("sg1", (0.0, 0.0));
    g.add_edge("A", "B");
    g.set_parent("A", "sg1");
    g.set_parent("B", "sg1");
    // No set_has_title call
    let mut lg = LayoutGraph::from_digraph(&g, |_, dims| *dims);
    let sg1_idx = lg.node_index[&"sg1".into()];

    run(&mut lg);

    assert!(!lg.border_title.contains_key(&sg1_idx));
}
```

**What the failing test asserts:** After `nesting::run()`, titled compounds have a `border_title` entry with a `_tt_`-prefixed node; untitled compounds do not.
**Expected failure reason:** `run()` does not create title nodes.

### ðŸŸ¢ Green: Minimal Implementation

In `nesting::run()`, after creating `border_top` and `border_bottom` for each compound:

```rust
// Create title node for compounds with titles
if lg.compound_titles.contains(&compound_idx) {
    let title_id = NodeId(format!("_tt_{}", compound_id));
    let title_idx = lg.add_nesting_node(title_id);
    lg.border_title.insert(compound_idx, title_idx);
}
```

In the root connection section, replace `root â†’ border_top` with `root â†’ title â†’ border_top` for titled compounds:

```rust
// Connect root to top-level compound borders
for &compound_idx in &compound_indices {
    let top_idx = lg.border_top[&compound_idx];

    if let Some(&title_idx) = lg.border_title.get(&compound_idx) {
        // root â†’ title
        let e = lg.add_nesting_edge(root_idx, title_idx, nesting_weight);
        lg.nesting_edges.insert(e);
        // title â†’ border_top
        let e = lg.add_nesting_edge(title_idx, top_idx, nesting_weight);
        lg.nesting_edges.insert(e);
    } else {
        // root â†’ border_top (existing behavior)
        let e = lg.add_nesting_edge(root_idx, top_idx, nesting_weight);
        lg.nesting_edges.insert(e);
    }
}
```

### ðŸ”µ Refactor: Clean Up

- Verify cleanup() handles title edges (they're nesting edges, so auto-excluded)
- Check that the title node gets zero dimensions from `add_nesting_node()`

## Context
See [Q1 research](../../../research/0023-subgraph-title-arrow-collision/layout-level-structural-fix/q1-nesting-insertion.md) for detailed analysis of the nesting insertion point, edge weight strategy, and cleanup compatibility.

The title node uses the same `nesting_weight = (n * 2)` as border edges, so ranking forces `title < border_top < children < border_bottom`.

## Acceptance Criteria
- [ ] Failing tests written and confirmed red
- [ ] Title node created for titled compounds with `_tt_` prefix
- [ ] Nesting chain: `root â†’ title â†’ border_top â†’ children â†’ border_bottom`
- [ ] Untitled compounds unchanged
- [ ] All existing nesting tests still pass

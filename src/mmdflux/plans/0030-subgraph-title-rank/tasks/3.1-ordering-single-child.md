# Task 3.1: Fix Ordering for Single-Child Ranks

## Objective
Extend `apply_compound_constraints()` to position border nodes at ranks with only 1 child (the title dummy), ensuring border_left < child < border_right ordering.

## Location
Modify: `src/dagre/order.rs` (`apply_compound_constraints()`)

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[test]
fn test_compound_ordering_single_child_rank_has_borders() {
    // Build a graph where the title rank has exactly 1 child
    let mut g: DiGraph<(f64, f64)> = DiGraph::new();
    g.add_node("X", (10.0, 10.0));
    g.add_node("A", (10.0, 10.0));
    g.add_node("B", (10.0, 10.0));
    g.add_node("sg1", (0.0, 0.0));
    g.add_edge("X", "A");
    g.add_edge("A", "B");
    g.set_parent("A", "sg1");
    g.set_parent("B", "sg1");
    g.set_has_title("sg1");

    let mut lg = LayoutGraph::from_digraph(&g, |_, dims| *dims);
    nesting::run(&mut lg);
    rank::run(&mut lg);
    rank::normalize(&mut lg);
    nesting::cleanup(&mut lg);
    nesting::assign_rank_minmax(&mut lg);
    border::add_segments(&mut lg);

    run(&mut lg);  // order::run()

    let sg1_idx = lg.node_index[&"sg1".into()];
    let title_idx = lg.border_title[&sg1_idx];
    let title_rank = lg.ranks[title_idx];
    let min_r = lg.min_rank[&sg1_idx];
    let rank_offset = (title_rank - min_r) as usize;

    let left_borders = &lg.border_left[&sg1_idx];
    let right_borders = &lg.border_right[&sg1_idx];
    let left = left_borders[rank_offset];
    let right = right_borders[rank_offset];

    // At the title rank: left < title < right
    assert!(
        lg.order[left] < lg.order[title_idx],
        "left border order ({}) should be < title order ({})",
        lg.order[left], lg.order[title_idx]
    );
    assert!(
        lg.order[title_idx] < lg.order[right],
        "title order ({}) should be < right border order ({})",
        lg.order[title_idx], lg.order[right]
    );
}
```

**What the failing test asserts:** At the title rank, left border has lower order than the title node, and title node has lower order than right border.
**Expected failure reason:** `apply_compound_constraints()` skips border placement when `< 2 children` (line 376).

### ðŸŸ¢ Green: Minimal Implementation

In `apply_compound_constraints()`, change the guard for the border placement section from:
```rust
if child_positions.len() < 2 {
    continue;
}
```
to:
```rust
if child_positions.is_empty() {
    continue;
}
```

This allows the existing border placement logic to work with 1 child. When there's 1 child:
- `first_child_pos == last_child_pos`
- Left border is placed at `first_child_pos` (before the child)
- Right border is placed at `last_child_pos + 1` (after the child)

The contiguity enforcement guard (line 336) can remain `< 2` since a single child is already contiguous.

### ðŸ”µ Refactor: Clean Up

- Verify the existing logic handles `first == last` correctly for both border placements
- Run all existing ordering tests to confirm no regressions
- Consider adding a comment explaining the single-child case is needed for title ranks

## Context
See [Q2 research](../../../research/0023-subgraph-title-arrow-collision/layout-level-structural-fix/q2-border-ordering-impact.md) for detailed analysis of the `< 2 children` skip and its impact on title rank border positioning.

The fix changes only the border placement guard, not the contiguity enforcement. This is safe because:
- Border placement logic already handles `first_child_pos == last_child_pos`
- The left border goes to `first_child_pos`, the right to after `last_child_pos`
- Vertical edge linking between consecutive borders provides additional alignment

## Acceptance Criteria
- [ ] Failing test written and confirmed red
- [ ] Guard changed from `< 2` to `is_empty()` for border placement
- [ ] Single-child rank correctly orders: left < child < right
- [ ] All existing ordering tests still pass
- [ ] Multi-child ranks unaffected (existing behavior preserved)

# Task 3.1: Implement `build_children_map()` Helper

## Objective
Create a helper that builds a `HashMap<String, Vec<String>>` mapping each subgraph to its direct child subgraphs, for use in inside-out bounds computation.

## Location
Modify: `src/render/layout.rs` (new private function near `convert_subgraph_bounds`)

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[test]
fn test_build_children_map() {
    let mut subgraphs = HashMap::new();
    subgraphs.insert("inner".to_string(), Subgraph {
        id: "inner".to_string(),
        title: "Inner".to_string(),
        nodes: vec!["A".to_string()],
        parent: Some("outer".to_string()),
    });
    subgraphs.insert("outer".to_string(), Subgraph {
        id: "outer".to_string(),
        title: "Outer".to_string(),
        nodes: vec!["A".to_string()],
        parent: None,
    });
    let children_map = build_children_map(&subgraphs);
    assert_eq!(children_map["outer"], vec!["inner".to_string()]);
    assert!(!children_map.contains_key("inner")); // inner has no children
}
```

**What the failing test asserts:** `build_children_map` returns a mapping from parent IDs to child subgraph IDs.
**Expected failure reason:** Function does not exist yet.

### ðŸŸ¢ Green: Minimal Implementation

```rust
fn build_children_map(
    subgraphs: &HashMap<String, crate::graph::Subgraph>,
) -> HashMap<String, Vec<String>> {
    let mut children: HashMap<String, Vec<String>> = HashMap::new();
    for sg in subgraphs.values() {
        if let Some(ref parent_id) = sg.parent {
            children.entry(parent_id.clone()).or_default().push(sg.id.clone());
        }
    }
    children
}
```

### ðŸ”µ Refactor: Clean Up

None expected. Simple utility function.

## Acceptance Criteria
- [ ] Failing test written and confirmed red
- [ ] Helper builds correct parent-to-children mapping
- [ ] Empty for subgraphs with no children
- [ ] Code refactored with tests still green

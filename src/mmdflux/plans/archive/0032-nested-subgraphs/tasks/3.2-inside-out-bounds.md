# Task 3.2: Implement Inside-Out Bounds Computation

## Objective
Redesign `convert_subgraph_bounds()` to compute bounds bottom-up (children first, then parents) using a recursive approach that includes child subgraph bounds in parent bounds.

## Location
Modify: `src/render/layout.rs` â€” modify `convert_subgraph_bounds()`

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[test]
fn test_nested_outer_only_subgraph_gets_bounds() {
    // outer has no direct nodes, only contains inner
    // inner has nodes A, B
    let input = "graph TD\nsubgraph outer[Outer]\nsubgraph inner[Inner]\nA --> B\nend\nend\n";
    let flowchart = parse_flowchart(input).unwrap();
    let diagram = build_diagram(&flowchart);
    let config = RenderConfig::default();
    let layout = compute_layout(&diagram, &config);
    // outer should have valid bounds even with no direct nodes
    assert!(layout.subgraph_bounds.contains_key("outer"));
    let outer = &layout.subgraph_bounds["outer"];
    assert!(outer.width > 0);
    assert!(outer.height > 0);
}
```

**What the failing test asserts:** An outer subgraph with no direct nodes (only a nested subgraph) still gets valid bounds.
**Expected failure reason:** Current `convert_subgraph_bounds` skips subgraphs when `min_x == usize::MAX` (line 826-828), which happens when the subgraph has no direct nodes in `draw_positions`.

### ðŸŸ¢ Green: Minimal Implementation

Rewrite `convert_subgraph_bounds` to:
1. Call `build_children_map()` to get parent-child relationships
2. Use a recursive `compute_bounds_recursive()` inner function:
   - First recursively compute all child subgraph bounds
   - Then compute this subgraph's bounds as the union of:
     - Direct member node positions (existing logic)
     - Already-computed child subgraph bounds
   - Apply border_padding, title-width minimum, backward-edge expansion (existing logic)
3. Use a `visited` HashSet to prevent recomputation

Key change: After computing min/max from direct nodes, ALSO iterate child subgraph bounds:
```rust
if let Some(children) = children_map.get(sg_id) {
    for child_id in children {
        if let Some(child_bounds) = bounds.get(child_id) {
            min_x = min_x.min(child_bounds.x);
            min_y = min_y.min(child_bounds.y);
            max_x = max_x.max(child_bounds.x + child_bounds.width);
            max_y = max_y.max(child_bounds.y + child_bounds.height);
        }
    }
}
```

The `min_x == usize::MAX` skip check should now only trigger for subgraphs with neither direct nodes nor children with bounds.

### ðŸ”µ Refactor: Clean Up

- Extract per-subgraph bound finalization (padding, title width, backward edge) into a helper
- Ensure the recursive function is clean and well-documented

## Context
This is the most impactful change in the plan. The current flat iteration must become a recursive traversal. All existing single-level subgraph behavior must be preserved.

See [Q3: Rendering nested bounds](../../../research/0025-nested-subgraphs/q3-rendering-nested-bounds.md) for detailed pseudocode.

## Acceptance Criteria
- [ ] Failing test written and confirmed red
- [ ] Outer subgraphs with only nested children get valid bounds
- [ ] Parent bounds fully contain child bounds with padding
- [ ] All existing single-level subgraph tests still pass
- [ ] No infinite recursion (visited set guards)
- [ ] Code refactored with tests still green

# Task 2.3: Add Unit Tests for DFS Initial Ordering

## Objective
Test that `init_order()` produces correct DFS-based orderings and handles edge cases.

## Location
Modify: `src/dagre/order.rs` (test module)

## Implementation

### Test 1: DFS groups connected nodes

```rust
#[test]
fn test_init_order_groups_connected() {
    // Diamond graph:
    //     A
    //    / \
    //   B   C
    //    \ /
    //     D
    //
    // DFS from A visits A, then follows first successor path.
    // If edges are A->B, A->C, B->D, C->D:
    // DFS order: A, B, D, C (follows A->B->D first, then A->C)
    // Layer 0: [A] (order 0)
    // Layer 1: [B, C] - B gets order 0 (visited first via A->B), C gets order 1
    // Layer 2: [D] (order 0)

    let mut graph: DiGraph<()> = DiGraph::new();
    graph.add_node("A", ());
    graph.add_node("B", ());
    graph.add_node("C", ());
    graph.add_node("D", ());
    graph.add_edge("A", "B");
    graph.add_edge("A", "C");
    graph.add_edge("B", "D");
    graph.add_edge("C", "D");

    let mut lg = LayoutGraph::from_digraph(&graph, |_, _| (10.0, 10.0));
    rank::run(&mut lg);
    rank::normalize(&mut lg);

    init_order(&mut lg);

    // All nodes should have valid order values
    let layers = rank::by_rank(&lg);
    for layer in &layers {
        let mut orders: Vec<usize> = layer.iter().map(|&n| lg.order[n]).collect();
        orders.sort();
        let expected: Vec<usize> = (0..layer.len()).collect();
        assert_eq!(orders, expected, "Orders should be consecutive starting from 0");
    }
}
```

### Test 2: Disconnected components

```rust
#[test]
fn test_init_order_disconnected() {
    // Two disconnected chains: A->B, C->D
    let mut graph: DiGraph<()> = DiGraph::new();
    graph.add_node("A", ());
    graph.add_node("B", ());
    graph.add_node("C", ());
    graph.add_node("D", ());
    graph.add_edge("A", "B");
    graph.add_edge("C", "D");

    let mut lg = LayoutGraph::from_digraph(&graph, |_, _| (10.0, 10.0));
    rank::run(&mut lg);
    rank::normalize(&mut lg);

    init_order(&mut lg);

    // All nodes should have valid order values, no panics
    let layers = rank::by_rank(&lg);
    for layer in &layers {
        let mut orders: Vec<usize> = layer.iter().map(|&n| lg.order[n]).collect();
        orders.sort();
        let expected: Vec<usize> = (0..layer.len()).collect();
        assert_eq!(orders, expected);
    }
}
```

## Context

`init_order()` is a private function, so tests must be in the `mod tests` block. Node indices depend on `DiGraph::add_node` insertion order.

## Acceptance Criteria
- [ ] Test verifies DFS produces valid consecutive order values per layer
- [ ] Test verifies disconnected components are handled
- [ ] All tests pass with `cargo test`

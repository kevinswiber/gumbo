# Task 3.1: Rewrite `run()` with Dagre-Style Adaptive Loop

## Objective
Replace the current `run()` function and `MAX_ITERATIONS` constant with a Dagre-style adaptive loop that uses DFS initialization, single sweeps per iteration, alternating direction and bias, best-order tracking, and adaptive termination.

## Location
Modify: `src/dagre/order.rs`

## Implementation

### 1. Remove `MAX_ITERATIONS` constant (line 8)

Delete:
```rust
const MAX_ITERATIONS: usize = 24;
```

### 2. Replace entire `run()` function (lines 10-44)

```rust
/// Run crossing reduction using Dagre-style adaptive ordering.
///
/// Matches Dagre's `order()` function in `lib/order/index.js`:
/// - DFS-based initial ordering
/// - Alternating up/down sweeps (one per iteration)
/// - Alternating left/right bias (pattern: false, false, true, true)
/// - Best-order tracking across iterations
/// - Terminates after 4 consecutive non-improving iterations
pub fn run(graph: &mut LayoutGraph) {
    let layers = rank::by_rank(graph);
    if layers.len() < 2 {
        return;
    }

    // Phase 2: DFS-based initial ordering
    init_order(graph);

    // Rebuild layers sorted by the new DFS order
    let layers = layers_sorted_by_order(graph);
    let edges = graph.effective_edges();

    let mut best_cc = usize::MAX;
    let mut best_order: Vec<usize> = Vec::new();

    // Dagre-style adaptive loop.
    //
    // Translates this Dagre code:
    //   for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
    //       sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);
    //       let cc = crossCount(g, layering);
    //       if (cc < bestCC) { lastBest = 0; best = ...; bestCC = cc; }
    //       else if (cc === bestCC) { best = structuredClone(layering); }
    //   }
    //
    // Direction: i % 2 == 0 -> sweep_up, i % 2 == 1 -> sweep_down
    // Bias: i % 4 >= 2 -> bias_right = true
    // last_best increments every iteration, resets to 0 on strict improvement
    // (then gets incremented to 1 at bottom of loop)

    let mut i: usize = 0;
    let mut last_best: usize = 0;

    while last_best < 4 {
        let bias_right = (i % 4) >= 2;

        if i % 2 == 0 {
            sweep_up(graph, &layers, &edges, bias_right);
        } else {
            sweep_down(graph, &layers, &edges, bias_right);
        }

        let cc = count_all_crossings(graph, &layers, &edges);

        if cc < best_cc {
            last_best = 0;
            best_cc = cc;
            best_order = graph.order.clone();
        } else if cc == best_cc {
            // Dagre saves on equal too (structuredClone)
            best_order = graph.order.clone();
        }

        i += 1;
        last_best += 1;
    }

    // Restore best ordering found
    if !best_order.is_empty() {
        graph.order = best_order;
    }
}
```

## Context

### Dagre loop semantics (critical details)

**`last_best` counting**: In Dagre's for-loop, `++lastBest` runs at the end of every iteration. When `cc < bestCC`, the body sets `lastBest = 0`, then the for-loop increment makes it 1. So after an improvement, you get exactly 3 more chances before termination (1→2→3→4). The Rust code replicates this by incrementing `last_best` at the bottom of the while loop.

**Direction mapping**: Dagre's `i % 2 ? downLayerGraphs : upLayerGraphs` means:
- i=0: falsy → upLayerGraphs (sweep up)
- i=1: truthy → downLayerGraphs (sweep down)
Our `i % 2 == 0` → `sweep_up` matches this.

**Equal crossing save**: When `cc == best_cc`, Dagre replaces `best` with a `structuredClone`. This allows later iterations to build on a potentially better structural ordering even though crossing count is the same.

**No order reset**: Dagre does NOT reset between iterations. Each sweep mutates the current order cumulatively. The best-order tracking captures the best snapshot.

**No hard iteration cap**: Dagre has no `MAX_ITERATIONS`. The adaptive termination handles convergence. In practice, convergence happens within 8-20 iterations for typical graphs.

### Dagre reference (`lib/order/index.js` lines 49-61)
```javascript
for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2, constraints);
    layering = util.buildLayerMatrix(g);
    let cc = crossCount(g, layering);
    if (cc < bestCC) {
        lastBest = 0;
        best = Object.assign({}, layering);
        bestCC = cc;
    } else if (cc === bestCC) {
        best = structuredClone(layering);
    }
}
assignOrder(g, best);
```

## Acceptance Criteria
- [ ] `MAX_ITERATIONS` constant removed
- [ ] `run()` uses DFS init via `init_order()`
- [ ] `run()` uses `layers_sorted_by_order()` after init
- [ ] Loop does single sweep per iteration (up on even, down on odd)
- [ ] Bias alternates: false, false, true, true pattern
- [ ] Best order tracked and saved on improvement
- [ ] Equal crossing count also saves order
- [ ] Terminates after 4 consecutive non-improving iterations
- [ ] Best order restored at end
- [ ] `cargo build` succeeds
- [ ] `cargo clippy` clean

# Task 3.2: Add Unit Tests for Adaptive Loop

## Objective
Test the Dagre-style adaptive loop behavior: best-order selection, convergence, and handling of various graph structures.

## Location
Modify: `src/dagre/order.rs` (test module)

## Implementation

### Test 1: Algorithm selects best ordering

```rust
#[test]
fn test_adaptive_selects_best() {
    // Create a graph where the ordering matters:
    // Layer 0: A, B
    // Layer 1: C, D
    // Edges: A->D, B->C (crossing if A,B and C,D in original order)
    let mut graph: DiGraph<()> = DiGraph::new();
    graph.add_node("A", ());
    graph.add_node("B", ());
    graph.add_node("C", ());
    graph.add_node("D", ());
    graph.add_edge("A", "D");
    graph.add_edge("B", "C");

    let mut lg = LayoutGraph::from_digraph(&graph, |_, _| (10.0, 10.0));
    rank::run(&mut lg);
    rank::normalize(&mut lg);

    run(&mut lg);

    // After adaptive ordering, crossings should be minimized to 0
    let layers = rank::by_rank(&lg);
    let edges = lg.effective_edges();
    let crossings = count_all_crossings(&lg, &layers, &edges);
    assert_eq!(crossings, 0, "Adaptive loop should find zero-crossing ordering");
}
```

### Test 2: Convergence on complex graph

```rust
#[test]
fn test_adaptive_converges() {
    // 6-node graph with multiple layers
    //     A
    //    / \
    //   B   C
    //   |   |
    //   D   E
    //    \ /
    //     F
    let mut graph: DiGraph<()> = DiGraph::new();
    graph.add_node("A", ());
    graph.add_node("B", ());
    graph.add_node("C", ());
    graph.add_node("D", ());
    graph.add_node("E", ());
    graph.add_node("F", ());
    graph.add_edge("A", "B");
    graph.add_edge("A", "C");
    graph.add_edge("B", "D");
    graph.add_edge("C", "E");
    graph.add_edge("D", "F");
    graph.add_edge("E", "F");

    let mut lg = LayoutGraph::from_digraph(&graph, |_, _| (10.0, 10.0));
    rank::run(&mut lg);
    rank::normalize(&mut lg);

    run(&mut lg);

    // Should terminate and produce valid ordering
    let layers = rank::by_rank(&lg);
    for layer in &layers {
        let mut orders: Vec<usize> = layer.iter().map(|&n| lg.order[n]).collect();
        orders.sort();
        let expected: Vec<usize> = (0..layer.len()).collect();
        assert_eq!(orders, expected, "Orders should be consecutive in each layer");
    }

    // Should have 0 crossings for this parallel structure
    let edges = lg.effective_edges();
    assert_eq!(count_all_crossings(&lg, &layers, &edges), 0);
}
```

### Test 3: Single layer graph

```rust
#[test]
fn test_adaptive_single_layer() {
    // All nodes at same rank - should exit early
    let mut graph: DiGraph<()> = DiGraph::new();
    graph.add_node("A", ());
    graph.add_node("B", ());

    let mut lg = LayoutGraph::from_digraph(&graph, |_, _| (10.0, 10.0));
    rank::run(&mut lg);
    rank::normalize(&mut lg);

    run(&mut lg);
    // Should not panic, even with < 2 layers
}
```

## Context

The existing tests `test_order_no_crossings`, `test_order_reduces_crossings`, and `test_order_with_disconnected` should also still pass after the rewrite. They test the public `run()` function and check for zero crossings or completion without errors.

## Acceptance Criteria
- [ ] Test verifies adaptive loop finds optimal ordering for crossing graph
- [ ] Test verifies convergence on multi-layer graph
- [ ] Test verifies single-layer early exit
- [ ] All existing tests still pass
- [ ] `cargo test` succeeds

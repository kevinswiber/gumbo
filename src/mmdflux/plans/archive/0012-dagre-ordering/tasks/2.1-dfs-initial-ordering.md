# Task 2.1: Add `init_order()` DFS Function

## Objective
Add a DFS-based initial ordering function matching Dagre's `initOrder()`. This replaces the arbitrary insertion-order initialization with an ordering that naturally groups connected nodes together.

## Location
Modify: `src/dagre/order.rs` (add new function)

## Implementation

Add this function before `run()`:

```rust
/// DFS-based initial ordering matching Dagre's initOrder().
///
/// Visits nodes sorted by rank, adding each to its layer in DFS visit order.
/// This groups connected nodes together, providing a better starting point
/// for crossing minimization than arbitrary insertion order.
///
/// Reference: Gansner et al., "A Technique for Drawing Directed Graphs"
fn init_order(graph: &mut LayoutGraph) {
    let edges = graph.effective_edges();
    let n = graph.node_ids.len();

    // Build successor adjacency list
    let mut successors: Vec<Vec<usize>> = vec![Vec::new(); n];
    for &(from, to) in &edges {
        successors[from].push(to);
    }

    // Get all nodes sorted by rank (ascending), matching Dagre's
    // `simpleNodes.sort((a, b) => g.node(a).rank - g.node(b).rank)`
    let mut start_nodes: Vec<usize> = (0..n).collect();
    start_nodes.sort_by_key(|&node| graph.ranks[node]);

    // Track visit state and per-rank insertion index
    let mut visited = vec![false; n];
    let max_rank = graph.ranks.iter().max().copied().unwrap_or(0) as usize;
    let mut layer_next_idx: Vec<usize> = vec![0; max_rank + 1];

    // Iterative DFS to avoid stack overflow on deep graphs.
    // Push successors in reverse so first successor is visited first,
    // matching recursive DFS visit order.
    for &root in &start_nodes {
        if visited[root] {
            continue;
        }
        let mut stack = vec![root];
        while let Some(node) = stack.pop() {
            if visited[node] {
                continue;
            }
            visited[node] = true;

            let rank = graph.ranks[node] as usize;
            graph.order[node] = layer_next_idx[rank];
            layer_next_idx[rank] += 1;

            // Push successors in reverse for correct DFS order
            for &succ in successors[node].iter().rev() {
                if !visited[succ] {
                    stack.push(succ);
                }
            }
        }
    }
}
```

## Context

**Dagre reference** (`lib/order/init-order.js`):
```javascript
function initOrder(g) {
    let visited = {};
    let layers = util.range(maxRank + 1).map(() => []);
    function dfs(v) {
        if (visited[v]) return;
        visited[v] = true;
        layers[g.node(v).rank].push(v);
        g.successors(v).forEach(dfs);
    }
    let orderedVs = simpleNodes.sort((a, b) => g.node(a).rank - g.node(b).rank);
    orderedVs.forEach(dfs);
    return layers;
}
```

Key differences from Dagre:
- Uses iterative DFS (manual stack) instead of recursive to handle deep normalized graphs
- Sets `graph.order` directly instead of building a layer matrix (equivalent effect)
- Dagre filters to "simple nodes" (no children) for compound graphs; mmdflux doesn't support compound graphs, so all nodes are "simple"

**Why iterative DFS**: After rank normalization, long edges become chains of dummy nodes. A graph with a long edge spanning 20 ranks creates 19 dummy nodes in a chain. Recursive DFS on these chains could hit Rust's default stack limit on very large diagrams.

This function is called from `run()` but is NOT yet wired in during this task. It will be called in Phase 3 (task 3.1) when `run()` is rewritten. For now, just add the function so it compiles.

## Acceptance Criteria
- [ ] `init_order()` function added to `order.rs`
- [ ] Uses iterative DFS with manual stack
- [ ] Visits nodes sorted by rank ascending
- [ ] Sets `graph.order[node]` values correctly
- [ ] Compiles cleanly (`cargo build`)
- [ ] `cargo clippy` clean

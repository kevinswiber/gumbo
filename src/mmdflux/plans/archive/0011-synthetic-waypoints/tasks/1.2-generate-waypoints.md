# Task 1.2: Add generate_synthetic_waypoints() function for TD layout

## Objective

Create the function that generates waypoints for edges with large horizontal offset in TopDown layout.

## Location

`src/render/router.rs` - add after `analyze_edge()` function

## Implementation

```rust
/// Generate synthetic waypoints for forward edges with large horizontal offset.
/// Returns Some(waypoints) if special routing is needed, None for default routing.
fn generate_synthetic_waypoints(
    from_bounds: &NodeBounds,
    to_bounds: &NodeBounds,
    layout: &Layout,
    direction: Direction,
) -> Option<Vec<(usize, usize)>> {
    let analysis = analyze_edge(from_bounds, to_bounds, layout, direction);

    if !analysis.needs_synthetic_waypoints {
        return None;
    }

    match direction {
        Direction::TopDown => {
            generate_td_waypoints(from_bounds, to_bounds, &analysis)
        }
        Direction::BottomTop => {
            generate_bt_waypoints(from_bounds, to_bounds, &analysis)
        }
        _ => None, // LR/RL handled in Phase 3
    }
}

/// Generate waypoints for TopDown layout
fn generate_td_waypoints(
    from_bounds: &NodeBounds,
    to_bounds: &NodeBounds,
    analysis: &EdgeAnalysis,
) -> Option<Vec<(usize, usize)>> {
    // Strategy: Single waypoint that keeps source X, drops to near target Y
    // This forces vertical-first routing, staying on the source's side

    let waypoint_x = from_bounds.center_x();

    // Place waypoint a few rows above the target to allow horizontal approach
    // The exact offset ensures the final segment is vertical (for proper arrow)
    let waypoint_y = to_bounds.y.saturating_sub(3);

    // Sanity check: waypoint should be below source and above target
    if waypoint_y <= from_bounds.y + from_bounds.height {
        return None; // Not enough vertical space, use default routing
    }

    Some(vec![(waypoint_x, waypoint_y)])
}

/// Generate waypoints for BottomTop layout (inverted TD)
fn generate_bt_waypoints(
    from_bounds: &NodeBounds,
    to_bounds: &NodeBounds,
    analysis: &EdgeAnalysis,
) -> Option<Vec<(usize, usize)>> {
    let waypoint_x = from_bounds.center_x();

    // For BT, waypoint is below source (higher Y) and above target entry
    let waypoint_y = to_bounds.y + to_bounds.height + 3;

    // Sanity check: waypoint should be above source (higher Y in BT means "above")
    if waypoint_y >= from_bounds.y {
        return None;
    }

    Some(vec![(waypoint_x, waypoint_y)])
}
```

## Design Rationale

### Why Single Waypoint?

A single waypoint at `(source_x, near_target_y)` creates this path:

```
Source (right side)
    │
    │ ← vertical segment at source X
    │
    └────────┐ ← waypoint here
             │
             │ ← short horizontal, then vertical to target
             ▼
         Target (center)
```

This is simpler than two waypoints and achieves the goal of avoiding the crowded middle.

### Why waypoint_y = target.y - 3?

- Needs to be above the target to allow final vertical segment
- `-3` provides room for the horizontal turn
- Final segment handled by `build_orthogonal_path_with_waypoints()` which ensures vertical entry

### Edge Cases

1. **Not enough vertical space:** If source and target are very close vertically, the waypoint would be invalid. Return `None` to use default routing.

2. **Source below target:** Not a forward edge (handled by backward edge routing).

## Tests to Add

```rust
#[test]
fn test_generate_synthetic_waypoints_td_right_source() {
    let layout = make_layout(100);
    let from = make_bounds(80, 10, 10, 5); // Right side
    let to = make_bounds(30, 50, 10, 5);   // Center-left

    let waypoints = generate_synthetic_waypoints(&from, &to, &layout, Direction::TopDown);

    assert!(waypoints.is_some());
    let wps = waypoints.unwrap();
    assert_eq!(wps.len(), 1);

    // Waypoint should be at source X
    assert_eq!(wps[0].0, from.center_x());
    // Waypoint should be above target
    assert!(wps[0].1 < to.y);
    // Waypoint should be below source
    assert!(wps[0].1 > from.y + from.height);
}

#[test]
fn test_generate_synthetic_waypoints_small_offset_returns_none() {
    let layout = make_layout(100);
    let from = make_bounds(45, 10, 10, 5);
    let to = make_bounds(50, 50, 10, 5);

    let waypoints = generate_synthetic_waypoints(&from, &to, &layout, Direction::TopDown);

    assert!(waypoints.is_none());
}

#[test]
fn test_generate_synthetic_waypoints_insufficient_vertical_space() {
    let layout = make_layout(100);
    let from = make_bounds(80, 45, 10, 5); // Very close to target
    let to = make_bounds(30, 50, 10, 5);

    let waypoints = generate_synthetic_waypoints(&from, &to, &layout, Direction::TopDown);

    // Should return None because there's not enough space for waypoint
    assert!(waypoints.is_none());
}
```

## Acceptance Criteria

- [ ] `generate_synthetic_waypoints()` returns `None` for small offset edges
- [ ] `generate_synthetic_waypoints()` returns `Some(waypoints)` for large offset TD edges
- [ ] Waypoint X coordinate matches source center
- [ ] Waypoint Y coordinate is above target, below source
- [ ] Returns `None` when insufficient vertical space
- [ ] BT layout generates appropriate waypoints (inverted Y logic)
- [ ] Unit tests pass

# Task 1.3: Integrate into route_edge() decision flow

## Objective

Integrate the synthetic waypoint generation into the main `route_edge()` function so that qualifying edges use the generated waypoints.

## Location

`src/render/router.rs` - modify `route_edge()` function (around line 124-177)

## Current Code Structure

```rust
pub fn route_edge(
    edge: &Edge,
    layout: &Layout,
    diagram_direction: Direction,
) -> Option<RoutedEdge> {
    let from_bounds = layout.get_bounds(&edge.from)?;
    let to_bounds = layout.get_bounds(&edge.to)?;

    // 1. Check if backward edge
    if is_backward_edge(from_bounds, to_bounds, diagram_direction) {
        return route_backward_edge(edge, from_bounds, to_bounds, layout, diagram_direction);
    }

    // 2. Check for existing waypoints (from dagre normalization)
    let edge_key = (edge.from.clone(), edge.to.clone());
    let waypoints = layout.edge_waypoints.get(&edge_key);

    let from_shape = layout.node_shapes.get(&edge.from).copied().unwrap_or(Shape::Rectangle);
    let to_shape = layout.node_shapes.get(&edge.to).copied().unwrap_or(Shape::Rectangle);

    if let Some(wps) = waypoints {
        if !wps.is_empty() {
            return route_edge_with_waypoints(
                edge, from_bounds, from_shape,
                to_bounds, to_shape, wps, diagram_direction
            );
        }
    }

    // 3. Direct routing (current behavior for short edges)
    route_edge_direct(
        edge, from_bounds, from_shape,
        to_bounds, to_shape, diagram_direction
    )
}
```

## Modified Code

```rust
pub fn route_edge(
    edge: &Edge,
    layout: &Layout,
    diagram_direction: Direction,
) -> Option<RoutedEdge> {
    let from_bounds = layout.get_bounds(&edge.from)?;
    let to_bounds = layout.get_bounds(&edge.to)?;

    // 1. Check if backward edge
    if is_backward_edge(from_bounds, to_bounds, diagram_direction) {
        return route_backward_edge(edge, from_bounds, to_bounds, layout, diagram_direction);
    }

    // 2. Check for existing waypoints (from dagre normalization)
    let edge_key = (edge.from.clone(), edge.to.clone());
    let waypoints = layout.edge_waypoints.get(&edge_key);

    let from_shape = layout.node_shapes.get(&edge.from).copied().unwrap_or(Shape::Rectangle);
    let to_shape = layout.node_shapes.get(&edge.to).copied().unwrap_or(Shape::Rectangle);

    if let Some(wps) = waypoints {
        if !wps.is_empty() {
            return route_edge_with_waypoints(
                edge, from_bounds, from_shape,
                to_bounds, to_shape, wps, diagram_direction
            );
        }
    }

    // ============ NEW CODE START ============
    // 3. Check if this forward edge needs synthetic waypoints
    //    (for large horizontal offset edges that didn't get dagre waypoints)
    if let Some(synthetic_wps) = generate_synthetic_waypoints(
        from_bounds, to_bounds, layout, diagram_direction
    ) {
        return route_edge_with_waypoints(
            edge, from_bounds, from_shape,
            to_bounds, to_shape, &synthetic_wps, diagram_direction
        );
    }
    // ============ NEW CODE END ============

    // 4. Direct routing (default for simple edges)
    route_edge_direct(
        edge, from_bounds, from_shape,
        to_bounds, to_shape, diagram_direction
    )
}
```

## Integration Points

The new code is inserted at a specific point in the decision flow:

1. **After backward edge check** - Synthetic waypoints are for forward edges only
2. **After dagre waypoint check** - Don't override dagre's waypoints for long edges
3. **Before direct routing** - Give synthetic waypoints a chance before fallback

## Why This Order Matters

```
Edge arrives at route_edge()
    │
    ▼
Is backward? ──Yes──► route_backward_edge() [corridors]
    │ No
    ▼
Has dagre waypoints? ──Yes──► route_edge_with_waypoints() [dagre path]
    │ No
    ▼
Needs synthetic waypoints? ──Yes──► route_edge_with_waypoints() [synthetic path]
    │ No                                    ↑
    ▼                                       │
route_edge_direct() [mid-y Z-path]    REUSES EXISTING FUNCTION
```

## Tests to Add

```rust
#[test]
fn test_route_edge_uses_synthetic_waypoints_for_large_offset() {
    // Setup: Create a diagram with a right-side source, center target
    let mut layout = create_test_layout();
    // Place "E" on right side, "F" in center, large horizontal offset
    layout.node_bounds.insert("E".to_string(), NodeBounds { x: 80, y: 10, width: 15, height: 5 });
    layout.node_bounds.insert("F".to_string(), NodeBounds { x: 30, y: 50, width: 10, height: 5 });
    layout.node_shapes.insert("E".to_string(), Shape::Diamond);
    layout.node_shapes.insert("F".to_string(), Shape::Rectangle);
    layout.width = 100;

    let edge = Edge {
        from: "E".to_string(),
        to: "F".to_string(),
        label: Some("no".to_string()),
        stroke: Stroke::Solid,
        arrow: Arrow::Normal,
    };

    let routed = route_edge(&edge, &layout, Direction::TopDown);
    assert!(routed.is_some());

    let routed = routed.unwrap();

    // The path should NOT go through the middle
    // Check that the first segment stays at source X (right side)
    if let Segment::Vertical { x, .. } = &routed.segments[0] {
        assert!(*x > 70, "First segment should be on right side, not middle");
    }
}

#[test]
fn test_route_edge_prefers_dagre_waypoints_over_synthetic() {
    // Setup: Edge has dagre waypoints
    let mut layout = create_test_layout();
    layout.node_bounds.insert("A".to_string(), NodeBounds { x: 80, y: 10, width: 10, height: 5 });
    layout.node_bounds.insert("B".to_string(), NodeBounds { x: 30, y: 50, width: 10, height: 5 });

    // Add dagre waypoints
    let dagre_wps = vec![(60, 25), (45, 40)];
    layout.edge_waypoints.insert(("A".to_string(), "B".to_string()), dagre_wps.clone());

    let edge = Edge { from: "A".to_string(), to: "B".to_string(), ..default_edge() };

    let routed = route_edge(&edge, &layout, Direction::TopDown);
    assert!(routed.is_some());

    // Should use dagre waypoints, not synthetic
    // The path should pass near the dagre waypoint coordinates
}
```

## Acceptance Criteria

- [ ] `route_edge()` calls `generate_synthetic_waypoints()` for edges without dagre waypoints
- [ ] `route_edge()` uses synthetic waypoints when returned
- [ ] `route_edge()` falls back to direct routing when synthetic returns `None`
- [ ] Dagre waypoints take precedence over synthetic waypoints
- [ ] Backward edges are unaffected
- [ ] Integration test with `complex.mmd` shows improved E→F routing

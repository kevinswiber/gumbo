# Task 1.4: Add unit tests for waypoint generation

## Objective

Comprehensive unit tests for the synthetic waypoint generation logic.

## Location

`src/render/router.rs` - add to existing test module at bottom of file

## Test Categories

### 1. EdgeAnalysis Tests

```rust
#[cfg(test)]
mod synthetic_waypoint_tests {
    use super::*;

    // Helper to create NodeBounds
    fn bounds(x: usize, y: usize, w: usize, h: usize) -> NodeBounds {
        NodeBounds { x, y, width: w, height: h }
    }

    // Helper to create minimal Layout for testing
    fn test_layout(width: usize, height: usize) -> Layout {
        Layout {
            grid_positions: HashMap::new(),
            draw_positions: HashMap::new(),
            node_bounds: HashMap::new(),
            width,
            height,
            h_spacing: 4,
            v_spacing: 2,
            backward_corridors: 0,
            corridor_width: 0,
            backward_edge_lanes: HashMap::new(),
            edge_waypoints: HashMap::new(),
            edge_label_positions: HashMap::new(),
            node_shapes: HashMap::new(),
        }
    }

    // ==================== analyze_edge tests ====================

    #[test]
    fn analyze_identifies_right_side_source() {
        let layout = test_layout(100, 80);
        let from = bounds(75, 10, 10, 5);  // Right side (center at 80)
        let to = bounds(30, 50, 10, 5);    // Left of center

        let analysis = analyze_edge(&from, &to, &layout, Direction::TopDown);

        assert_eq!(analysis.source_position, SourcePosition::Right);
    }

    #[test]
    fn analyze_identifies_left_side_source() {
        let layout = test_layout(100, 80);
        let from = bounds(10, 10, 10, 5);  // Left side (center at 15)
        let to = bounds(70, 50, 10, 5);    // Right of center

        let analysis = analyze_edge(&from, &to, &layout, Direction::TopDown);

        assert_eq!(analysis.source_position, SourcePosition::Left);
    }

    #[test]
    fn analyze_identifies_center_source() {
        let layout = test_layout(100, 80);
        let from = bounds(45, 10, 10, 5);  // Center (center at 50)
        let to = bounds(70, 50, 10, 5);

        let analysis = analyze_edge(&from, &to, &layout, Direction::TopDown);

        assert_eq!(analysis.source_position, SourcePosition::Center);
    }

    #[test]
    fn analyze_calculates_horizontal_offset() {
        let layout = test_layout(100, 80);
        let from = bounds(70, 10, 10, 5);  // center_x = 75
        let to = bounds(20, 50, 10, 5);    // center_x = 25

        let analysis = analyze_edge(&from, &to, &layout, Direction::TopDown);

        assert_eq!(analysis.horizontal_offset, 50); // |75 - 25|
    }

    #[test]
    fn analyze_needs_waypoints_for_large_offset_non_center() {
        let layout = test_layout(100, 80);
        let from = bounds(75, 10, 10, 5);  // Right side, large offset
        let to = bounds(20, 50, 10, 5);

        let analysis = analyze_edge(&from, &to, &layout, Direction::TopDown);

        assert!(analysis.needs_synthetic_waypoints);
    }

    #[test]
    fn analyze_no_waypoints_for_small_offset() {
        let layout = test_layout(100, 80);
        let from = bounds(45, 10, 10, 5);
        let to = bounds(50, 50, 10, 5);    // Only 5 units offset

        let analysis = analyze_edge(&from, &to, &layout, Direction::TopDown);

        assert!(!analysis.needs_synthetic_waypoints);
    }

    #[test]
    fn analyze_no_waypoints_for_center_source_large_offset() {
        let layout = test_layout(100, 80);
        let from = bounds(45, 10, 10, 5);  // Center source
        let to = bounds(90, 50, 10, 5);    // Large offset, but source is center

        let analysis = analyze_edge(&from, &to, &layout, Direction::TopDown);

        assert!(!analysis.needs_synthetic_waypoints);
    }

    #[test]
    fn analyze_no_waypoints_for_lr_layout() {
        let layout = test_layout(100, 80);
        let from = bounds(75, 10, 10, 5);
        let to = bounds(20, 50, 10, 5);

        let analysis = analyze_edge(&from, &to, &layout, Direction::LeftRight);

        assert!(!analysis.needs_synthetic_waypoints);
    }

    // ==================== generate_synthetic_waypoints tests ====================

    #[test]
    fn generate_returns_none_for_small_offset() {
        let layout = test_layout(100, 80);
        let from = bounds(45, 10, 10, 5);
        let to = bounds(50, 50, 10, 5);

        let result = generate_synthetic_waypoints(&from, &to, &layout, Direction::TopDown);

        assert!(result.is_none());
    }

    #[test]
    fn generate_returns_waypoint_for_large_offset_td() {
        let layout = test_layout(100, 80);
        let from = bounds(75, 10, 10, 5);  // Right side
        let to = bounds(20, 50, 10, 5);    // Left of center

        let result = generate_synthetic_waypoints(&from, &to, &layout, Direction::TopDown);

        assert!(result.is_some());
        let wps = result.unwrap();
        assert_eq!(wps.len(), 1);
    }

    #[test]
    fn generate_waypoint_at_source_x() {
        let layout = test_layout(100, 80);
        let from = bounds(75, 10, 10, 5);  // center_x = 80
        let to = bounds(20, 50, 10, 5);

        let result = generate_synthetic_waypoints(&from, &to, &layout, Direction::TopDown);
        let wps = result.unwrap();

        assert_eq!(wps[0].0, from.center_x());
    }

    #[test]
    fn generate_waypoint_above_target() {
        let layout = test_layout(100, 80);
        let from = bounds(75, 10, 10, 5);
        let to = bounds(20, 50, 10, 5);    // y = 50

        let result = generate_synthetic_waypoints(&from, &to, &layout, Direction::TopDown);
        let wps = result.unwrap();

        assert!(wps[0].1 < to.y, "Waypoint should be above target");
    }

    #[test]
    fn generate_waypoint_below_source() {
        let layout = test_layout(100, 80);
        let from = bounds(75, 10, 10, 5);  // y + height = 15
        let to = bounds(20, 50, 10, 5);

        let result = generate_synthetic_waypoints(&from, &to, &layout, Direction::TopDown);
        let wps = result.unwrap();

        assert!(wps[0].1 > from.y + from.height, "Waypoint should be below source");
    }

    #[test]
    fn generate_returns_none_insufficient_vertical_space() {
        let layout = test_layout(100, 80);
        let from = bounds(75, 45, 10, 5);  // Very close to target vertically
        let to = bounds(20, 50, 10, 5);

        let result = generate_synthetic_waypoints(&from, &to, &layout, Direction::TopDown);

        assert!(result.is_none(), "Should return None when not enough vertical space");
    }

    #[test]
    fn generate_bt_waypoint_inverted_y() {
        let layout = test_layout(100, 80);
        let from = bounds(75, 50, 10, 5);  // Lower (BT: "top")
        let to = bounds(20, 10, 10, 5);    // Higher (BT: "bottom")

        let result = generate_synthetic_waypoints(&from, &to, &layout, Direction::BottomTop);

        assert!(result.is_some());
        let wps = result.unwrap();

        // In BT, waypoint should be below source (higher Y) but above target entry
        assert!(wps[0].1 > to.y + to.height, "BT waypoint should be below target");
        assert!(wps[0].1 < from.y, "BT waypoint should be above source");
    }

    // ==================== Integration with route_edge tests ====================

    #[test]
    fn route_edge_uses_synthetic_when_no_dagre_waypoints() {
        let mut layout = test_layout(100, 80);
        layout.node_bounds.insert("E".to_string(), bounds(75, 10, 15, 5));
        layout.node_bounds.insert("F".to_string(), bounds(20, 50, 10, 5));
        layout.node_shapes.insert("E".to_string(), Shape::Diamond);
        layout.node_shapes.insert("F".to_string(), Shape::Rectangle);
        // Note: no edge_waypoints for Eâ†’F

        let edge = Edge {
            from: "E".to_string(),
            to: "F".to_string(),
            label: Some("no".to_string()),
            stroke: Stroke::Solid,
            arrow: Arrow::Normal,
        };

        let routed = route_edge(&edge, &layout, Direction::TopDown);
        assert!(routed.is_some());

        // First segment should stay on right side (high X)
        let segments = &routed.unwrap().segments;
        match &segments[0] {
            Segment::Vertical { x, .. } => {
                assert!(*x > 60, "Should route via right side, got x={}", x);
            }
            _ => panic!("Expected first segment to be vertical"),
        }
    }

    #[test]
    fn route_edge_prefers_dagre_over_synthetic() {
        let mut layout = test_layout(100, 80);
        layout.node_bounds.insert("A".to_string(), bounds(75, 10, 10, 5));
        layout.node_bounds.insert("B".to_string(), bounds(20, 50, 10, 5));
        layout.node_shapes.insert("A".to_string(), Shape::Rectangle);
        layout.node_shapes.insert("B".to_string(), Shape::Rectangle);

        // Add dagre waypoints that go through middle
        let dagre_wps = vec![(50, 30)];
        layout.edge_waypoints.insert(("A".to_string(), "B".to_string()), dagre_wps);

        let edge = Edge {
            from: "A".to_string(),
            to: "B".to_string(),
            label: None,
            stroke: Stroke::Solid,
            arrow: Arrow::Normal,
        };

        let routed = route_edge(&edge, &layout, Direction::TopDown);
        assert!(routed.is_some());

        // Should use dagre waypoints (middle X), not synthetic (right X)
        let has_middle_segment = routed.unwrap().segments.iter().any(|s| {
            match s {
                Segment::Vertical { x, .. } => *x > 40 && *x < 60,
                Segment::Horizontal { x_start, x_end, .. } => {
                    (*x_start > 40 && *x_start < 60) || (*x_end > 40 && *x_end < 60)
                }
            }
        });
        assert!(has_middle_segment, "Should use dagre waypoints through middle");
    }
}
```

## Test Coverage Goals

| Category | Tests | Purpose |
|----------|-------|---------|
| Source position detection | 3 | Left/Center/Right identification |
| Offset calculation | 1 | Verify horizontal offset math |
| Needs waypoints logic | 4 | Threshold and position combinations |
| Waypoint generation | 6 | Position, bounds, edge cases |
| Integration | 2 | Full route_edge flow |

## Acceptance Criteria

- [ ] All tests in `synthetic_waypoint_tests` module pass
- [ ] Tests cover source position detection (left/center/right)
- [ ] Tests cover threshold behavior
- [ ] Tests cover waypoint positioning (X at source, Y between)
- [ ] Tests cover edge cases (insufficient space)
- [ ] Tests cover BT layout
- [ ] Tests verify integration with `route_edge()`
- [ ] Tests verify dagre waypoints take precedence

# Task 3.1: Compound-Aware Ordering Constraints

## Objective

During crossing reduction, ensure nodes cannot cross their compound parent's border boundaries. Border nodes stay at fixed positions (leftmost/rightmost within parent).

## Location

Modify: `src/dagre/order.rs`

## TDD Phases

### Red: Write Failing Tests

```rust
#[test]
fn test_compound_ordering_borders_at_edges() {
    let mut lg = build_compound_graph_with_borders();
    // sg1 contains A, B, plus border_left and border_right at each rank

    order::run(&mut lg);

    // For each rank containing border nodes, verify:
    // - left border is leftmost among sg1's children
    // - right border is rightmost among sg1's children
    let rank_order = lg.order_at_rank(target_rank);
    let sg1_children_in_rank: Vec<usize> = /* filter to sg1's children */;
    let left_border = lg.border_left[&sg1_idx][rank_offset];
    let right_border = lg.border_right[&sg1_idx][rank_offset];

    assert_eq!(sg1_children_in_rank.first(), Some(&left_border));
    assert_eq!(sg1_children_in_rank.last(), Some(&right_border));
}

#[test]
fn test_compound_ordering_no_interleaving() {
    // Two subgraphs sg1 and sg2 at the same rank
    // Verify nodes from sg1 and sg2 don't interleave
    let mut lg = build_two_subgraph_same_rank();
    order::run(&mut lg);

    // All sg1 children should be contiguous, all sg2 children should be contiguous
}

#[test]
fn test_simple_graph_ordering_unchanged() {
    let mut lg_simple = build_simple_layout_graph();
    let mut lg_reference = lg_simple.clone();

    order::run(&mut lg_simple);
    order::run(&mut lg_reference);

    // Should produce identical orderings
}
```

**What the failing test asserts:** Border nodes at extremes of parent's children; no interleaving between subgraphs; simple graphs unchanged.
**Expected failure reason:** `order::run` doesn't enforce compound constraints.

### Green: Minimal Implementation

After computing barycenter positions in each sweep iteration, add a constraint pass:

```rust
fn apply_compound_constraints(lg: &LayoutGraph, order: &mut Vec<usize>, rank: i32) {
    if lg.compound_nodes.is_empty() {
        return;
    }

    // For each compound node spanning this rank:
    for &compound_idx in &lg.compound_nodes {
        if let (Some(&min_r), Some(&max_r)) = (lg.min_rank.get(&compound_idx), lg.max_rank.get(&compound_idx)) {
            if rank < min_r || rank > max_r {
                continue;
            }

            let rank_offset = (rank - min_r) as usize;

            // Get border nodes for this rank
            if let (Some(left_nodes), Some(right_nodes)) = (lg.border_left.get(&compound_idx), lg.border_right.get(&compound_idx)) {
                let left_border = left_nodes[rank_offset];
                let right_border = right_nodes[rank_offset];

                // Collect all children of this compound in the current order
                // Move left_border to first position among children
                // Move right_border to last position among children
                // Ensure all children are contiguous
            }
        }
    }
}
```

### Refactor: Clean Up

- Extract the constraint application into a well-named helper
- Consider whether constraints should be hard (cannot violate) or applied as a post-pass
- Ensure the constraint logic handles the case where border nodes aren't in the order yet

## Context

- dagre.js applies compound constraints via `addSubgraphConstraints()` which records ordering dependencies between compound siblings
- For single-level subgraphs, the key constraints are: (1) border nodes at extremes, (2) children contiguous
- Reference: [Q2 research](../../../research/0016-compound-graph-subgraphs/q2-dagre-compound-pipeline.md)

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] Border nodes positioned at extremes of parent's children
- [ ] Children of same parent contiguous in ordering
- [ ] Simple graphs produce identical ordering to current behavior
- [ ] All existing ordering tests pass

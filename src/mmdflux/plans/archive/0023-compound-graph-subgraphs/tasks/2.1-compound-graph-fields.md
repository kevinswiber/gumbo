# Task 2.1: Extend LayoutGraph and DiGraph with Compound Fields

## Objective

Add parent-child relationship tracking and compound metadata fields to `LayoutGraph` and `DiGraph`.

## Location

Modify: `src/dagre/graph.rs`

## TDD Phases

### Red: Write Failing Tests

```rust
#[test]
fn test_digraph_set_parent() {
    let mut g = DiGraph::new();
    g.add_node("A", ());
    g.add_node("sg1", ());
    g.set_parent("A", "sg1");
    assert_eq!(g.parent(&"A".into()), Some(&"sg1".into()));
}

#[test]
fn test_digraph_children() {
    let mut g = DiGraph::new();
    g.add_node("A", ());
    g.add_node("B", ());
    g.add_node("sg1", ());
    g.set_parent("A", "sg1");
    g.set_parent("B", "sg1");
    let children = g.children(&"sg1".into());
    assert_eq!(children.len(), 2);
}

#[test]
fn test_digraph_has_compound_nodes_false() {
    let g: DiGraph<()> = DiGraph::new();
    assert!(!g.has_compound_nodes());
}

#[test]
fn test_digraph_has_compound_nodes_true() {
    let mut g = DiGraph::new();
    g.add_node("A", ());
    g.add_node("sg1", ());
    g.set_parent("A", "sg1");
    assert!(g.has_compound_nodes());
}

#[test]
fn test_layout_graph_compound_fields_initialized() {
    // Build a LayoutGraph from a DiGraph with compound nodes
    // Verify parents vec, compound_nodes set, and border maps are initialized
}
```

**What the failing test asserts:** DiGraph supports parent/children/has_compound_nodes; LayoutGraph has compound metadata fields.
**Expected failure reason:** Methods and fields don't exist.

### Green: Minimal Implementation

Add to `DiGraph<N>`:
```rust
parents: HashMap<NodeId, NodeId>,

pub fn set_parent(&mut self, node: impl Into<NodeId>, parent: impl Into<NodeId>) { ... }
pub fn parent(&self, node: &NodeId) -> Option<&NodeId> { ... }
pub fn children(&self, parent: &NodeId) -> Vec<&NodeId> { ... }
pub fn has_compound_nodes(&self) -> bool { !self.parents.is_empty() }
```

Add to `LayoutGraph`:
```rust
pub parents: Vec<Option<usize>>,
pub min_rank: HashMap<usize, i32>,
pub max_rank: HashMap<usize, i32>,
pub border_top: HashMap<usize, usize>,
pub border_bottom: HashMap<usize, usize>,
pub border_left: HashMap<usize, Vec<usize>>,
pub border_right: HashMap<usize, Vec<usize>>,
pub border_type: HashMap<usize, BorderType>,
pub nesting_root: Option<usize>,
pub nesting_edges: HashSet<usize>,
pub compound_nodes: HashSet<usize>,
```

Add `BorderType` enum:
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BorderType { Left, Right }
```

Update `LayoutGraph::from_digraph` to populate `parents` and `compound_nodes` from DiGraph.

### Refactor: Clean Up

- Ensure all new fields have sensible defaults
- Group compound fields together in struct definition with a comment block
- Verify `from_digraph` handles the case where DiGraph has no compound nodes (all fields empty)

## Context

- `DiGraph` is the input graph type in `src/dagre/graph.rs`
- `LayoutGraph` is the internal representation used during layout
- `from_digraph` converts DiGraph -> LayoutGraph; this must carry parent info
- Reference: [Q5 research](../../../research/0016-compound-graph-subgraphs/q5-dagre-pipeline-changes.md)

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] DiGraph: `set_parent`, `parent`, `children`, `has_compound_nodes` methods work
- [ ] LayoutGraph: all compound fields added and initialized
- [ ] `BorderType` enum defined
- [ ] `from_digraph` propagates parent relationships
- [ ] All existing layout tests pass unchanged

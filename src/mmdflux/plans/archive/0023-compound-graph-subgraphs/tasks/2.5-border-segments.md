# Task 2.5: Implement Border Segment Module

## Objective

Create `src/dagre/border.rs` with `border::add_segments()` (creates left/right border nodes per rank) and `border::remove_nodes()` (extracts bounding boxes and removes border nodes after positioning).

## Location

New file: `src/dagre/border.rs`
Modify: `src/dagre/mod.rs` (add module declaration)

## TDD Phases

### Red: Write Failing Tests

```rust
#[test]
fn test_add_segments_creates_border_nodes() {
    let mut lg = build_ranked_compound_graph();
    // lg has compound node sg1 with min_rank=0, max_rank=2

    border::add_segments(&mut lg);

    let sg1_idx = /* compound index */;
    assert!(lg.border_left.contains_key(&sg1_idx));
    assert!(lg.border_right.contains_key(&sg1_idx));
    // 3 ranks (0,1,2) -> 3 left border nodes + 3 right border nodes
    assert_eq!(lg.border_left[&sg1_idx].len(), 3);
    assert_eq!(lg.border_right[&sg1_idx].len(), 3);
}

#[test]
fn test_border_nodes_have_correct_type() {
    let mut lg = build_ranked_compound_graph();
    border::add_segments(&mut lg);

    let sg1_idx = /* compound index */;
    for &left_idx in &lg.border_left[&sg1_idx] {
        assert_eq!(lg.border_type[&left_idx], BorderType::Left);
    }
    for &right_idx in &lg.border_right[&sg1_idx] {
        assert_eq!(lg.border_type[&right_idx], BorderType::Right);
    }
}

#[test]
fn test_border_nodes_linked_vertically() {
    let mut lg = build_ranked_compound_graph();
    border::add_segments(&mut lg);

    // Consecutive left border nodes should be connected by edges
    let sg1_idx = /* compound index */;
    let left = &lg.border_left[&sg1_idx];
    for i in 0..left.len() - 1 {
        assert!(lg.has_edge(left[i], left[i + 1]));
    }
}

#[test]
fn test_remove_nodes_extracts_bounds() {
    let mut lg = build_positioned_compound_graph();
    // After ordering and positioning, border nodes have coordinates

    let bounds = border::remove_nodes(&mut lg);

    assert!(bounds.contains_key("sg1"));
    let b = &bounds["sg1"];
    assert!(b.width > 0.0);
    assert!(b.height > 0.0);
}
```

**What the failing test asserts:** add_segments creates left/right border nodes per rank with correct types and vertical links; remove_nodes extracts bounding boxes.
**Expected failure reason:** `border` module does not exist.

### Green: Minimal Implementation

```rust
// src/dagre/border.rs

pub fn add_segments(lg: &mut LayoutGraph) {
    for compound_idx in lg.compound_nodes.clone() {
        let min_r = lg.min_rank[&compound_idx];
        let max_r = lg.max_rank[&compound_idx];

        let mut left_nodes = Vec::new();
        let mut right_nodes = Vec::new();

        for rank in min_r..=max_r {
            let left_idx = lg.add_dummy_node(/* zero size */);
            lg.border_type.insert(left_idx, BorderType::Left);
            lg.set_rank(left_idx, rank);
            lg.set_parent(left_idx, Some(compound_idx));
            left_nodes.push(left_idx);

            let right_idx = lg.add_dummy_node(/* zero size */);
            lg.border_type.insert(right_idx, BorderType::Right);
            lg.set_rank(right_idx, rank);
            lg.set_parent(right_idx, Some(compound_idx));
            right_nodes.push(right_idx);
        }

        // Link consecutive border nodes vertically
        for i in 0..left_nodes.len().saturating_sub(1) {
            lg.add_edge(left_nodes[i], left_nodes[i + 1], /* weight 1 */);
            lg.add_edge(right_nodes[i], right_nodes[i + 1], /* weight 1 */);
        }

        lg.border_left.insert(compound_idx, left_nodes);
        lg.border_right.insert(compound_idx, right_nodes);
    }
}

pub fn remove_nodes(lg: &mut LayoutGraph) -> HashMap<String, Rect> {
    let mut bounds = HashMap::new();

    for compound_idx in lg.compound_nodes.clone() {
        let left = &lg.border_left[&compound_idx];
        let right = &lg.border_right[&compound_idx];

        // Compute bounding box from border node positions
        let x_min = left.iter().map(|&i| lg.xs[i]).fold(f64::INFINITY, f64::min);
        let x_max = right.iter().map(|&i| lg.xs[i]).fold(f64::NEG_INFINITY, f64::max);
        let y_min = lg.ys[lg.border_top[&compound_idx]];
        let y_max = lg.ys[lg.border_bottom[&compound_idx]];

        let name = lg.node_id(compound_idx).to_string();
        bounds.insert(name, Rect {
            x: (x_min + x_max) / 2.0,
            y: (y_min + y_max) / 2.0,
            width: x_max - x_min,
            height: y_max - y_min,
        });

        // Remove border nodes
        // ... remove from graph
    }

    bounds
}
```

### Refactor: Clean Up

- Ensure border node removal doesn't leave dangling edge references
- Consider whether `remove_nodes` should also clean up border_top/border_bottom nodes
- Verify that border nodes participate correctly in ordering (they should be at edges of their parent's children)

## Context

- Border segments are invisible left/right boundary markers at each rank within a compound node
- They constrain ordering: left borders must be leftmost, right borders rightmost among siblings
- After positioning, their coordinates define the subgraph bounding box
- Reference: [Q2 research](../../../research/0016-compound-graph-subgraphs/q2-dagre-compound-pipeline.md), [Q5 research](../../../research/0016-compound-graph-subgraphs/q5-dagre-pipeline-changes.md)

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] `add_segments` creates left/right border nodes with correct types, ranks, and vertical links
- [ ] `remove_nodes` computes bounding boxes from border positions
- [ ] Border nodes cleaned up after removal
- [ ] Tests pass

# Task 2.3: Implement Nesting Graph Module

## Objective

Create `src/dagre/nesting.rs` implementing `nesting::run()` (adds border top/bottom nodes and weighted nesting edges) and `nesting::cleanup()` (removes nesting edges after ranking).

## Location

New file: `src/dagre/nesting.rs`
Modify: `src/dagre/mod.rs` (add module declaration)

## TDD Phases

### Red: Write Failing Tests

```rust
#[test]
fn test_nesting_run_adds_border_nodes() {
    let mut lg = build_test_compound_layout_graph();
    // lg has compound node "sg1" with children "A", "B"
    let initial_node_count = lg.node_count();

    nesting::run(&mut lg);

    // Should add border_top and border_bottom nodes for sg1
    assert!(lg.border_top.contains_key(&sg1_idx));
    assert!(lg.border_bottom.contains_key(&sg1_idx));
    assert!(lg.node_count() > initial_node_count);
}

#[test]
fn test_nesting_run_adds_nesting_edges() {
    let mut lg = build_test_compound_layout_graph();

    nesting::run(&mut lg);

    // Should have nesting edges connecting border nodes to children
    assert!(!lg.nesting_edges.is_empty());
}

#[test]
fn test_nesting_run_creates_root() {
    let mut lg = build_test_compound_layout_graph();

    nesting::run(&mut lg);

    assert!(lg.nesting_root.is_some());
}

#[test]
fn test_nesting_cleanup_removes_edges() {
    let mut lg = build_test_compound_layout_graph();
    nesting::run(&mut lg);
    let nesting_edge_count = lg.nesting_edges.len();
    assert!(nesting_edge_count > 0);

    nesting::cleanup(&mut lg);

    // Nesting edges removed; root removed
    assert!(lg.nesting_root.is_none());
    // nesting_edges set cleared
    assert!(lg.nesting_edges.is_empty());
}

#[test]
fn test_nesting_run_noop_simple_graph() {
    let mut lg = build_test_simple_layout_graph(); // no compound nodes
    let initial = lg.node_count();

    nesting::run(&mut lg);

    assert_eq!(lg.node_count(), initial);
}
```

**What the failing test asserts:** nesting::run adds border nodes, nesting edges, and root; cleanup removes them; no-op for simple graphs.
**Expected failure reason:** `nesting` module does not exist.

### Green: Minimal Implementation

```rust
// src/dagre/nesting.rs

pub fn run(lg: &mut LayoutGraph) {
    if lg.compound_nodes.is_empty() {
        return;
    }

    // For each compound node, create borderTop and borderBottom dummy nodes
    for compound_idx in lg.compound_nodes.clone() {
        let top_idx = lg.add_dummy_node(/* zero size */);
        lg.border_top.insert(compound_idx, top_idx);

        let bot_idx = lg.add_dummy_node(/* zero size */);
        lg.border_bottom.insert(compound_idx, bot_idx);

        // Find children of this compound node
        let children: Vec<usize> = lg.parents.iter().enumerate()
            .filter(|(_, p)| *p == Some(compound_idx))
            .map(|(i, _)| i)
            .collect();

        // Add nesting edges: top -> child, child -> bottom
        for child in children {
            let e1 = lg.add_edge(top_idx, child, /* high weight */);
            lg.nesting_edges.insert(e1);
            let e2 = lg.add_edge(child, bot_idx, /* high weight */);
            lg.nesting_edges.insert(e2);
        }
    }

    // Create root connecting to all top-level nodes
    let root_idx = lg.add_dummy_node(/* zero size */);
    lg.nesting_root = Some(root_idx);
    // ... connect root to top-level nodes and compound border_tops
}

pub fn cleanup(lg: &mut LayoutGraph) {
    // Remove nesting edges
    for &edge_idx in &lg.nesting_edges.clone() {
        lg.remove_edge(edge_idx);
    }
    lg.nesting_edges.clear();

    // Remove root
    if let Some(root) = lg.nesting_root.take() {
        lg.remove_node(root);
    }
}
```

### Refactor: Clean Up

- Extract helper for computing nesting edge weight (dagre.js uses `depth * node_count * 2`)
- Ensure dummy node IDs are distinguishable for debugging
- Add `add_dummy_node` and `remove_node`/`remove_edge` helpers to LayoutGraph if they don't exist

## Context

- dagre.js creates nesting edges with weight proportional to graph size to ensure they dominate ranking
- The root node ensures all top-level nodes are reachable from a single source
- After ranking, nesting edges are cleaned up but border_top/border_bottom nodes remain for rank extraction
- Reference: [Q2 research](../../../research/0016-compound-graph-subgraphs/q2-dagre-compound-pipeline.md), [Q5 research](../../../research/0016-compound-graph-subgraphs/q5-dagre-pipeline-changes.md)

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] `nesting::run()` creates border top/bottom nodes and nesting edges
- [ ] `nesting::cleanup()` removes nesting edges and root
- [ ] Simple graphs unaffected
- [ ] Tests pass

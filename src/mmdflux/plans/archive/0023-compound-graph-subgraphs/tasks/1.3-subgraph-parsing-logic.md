# Task 1.3: Add Subgraph Parsing Logic

## Objective

Implement `parse_subgraph()` in the parser that transforms `subgraph_stmt` pest pairs into `Statement::Subgraph(SubgraphSpec)` AST nodes.

## Location

Modify: `src/parser/flowchart.rs`

## TDD Phases

### Red: Write Failing Tests

```rust
#[test]
fn test_parse_subgraph_produces_ast() {
    let input = "graph TD\nsubgraph sg1[Title]\nA --> B\nend\n";
    let flowchart = parse_flowchart(input).unwrap();

    // Should contain a Subgraph statement
    let subgraph = flowchart.statements.iter().find_map(|s| {
        if let Statement::Subgraph(sg) = s { Some(sg) } else { None }
    });
    assert!(subgraph.is_some(), "Expected Subgraph statement");
    let sg = subgraph.unwrap();
    assert_eq!(sg.id, "sg1");
    assert_eq!(sg.title, "Title");
    assert!(!sg.statements.is_empty(), "Subgraph should contain statements");
}

#[test]
fn test_parse_subgraph_no_title() {
    let input = "graph TD\nsubgraph sg1\nA\nend\n";
    let flowchart = parse_flowchart(input).unwrap();
    let sg = flowchart.statements.iter().find_map(|s| {
        if let Statement::Subgraph(sg) = s { Some(sg) } else { None }
    }).unwrap();
    assert_eq!(sg.id, "sg1");
    assert_eq!(sg.title, "sg1"); // title defaults to id
}

#[test]
fn test_parse_flowchart_with_subgraph_and_external() {
    let input = "graph TD\nsubgraph sg1[Group]\nA --> B\nend\nC --> A\n";
    let flowchart = parse_flowchart(input).unwrap();
    // Should have Subgraph + Edge statements at top level
    let has_subgraph = flowchart.statements.iter().any(|s| matches!(s, Statement::Subgraph(_)));
    let has_edge = flowchart.statements.iter().any(|s| matches!(s, Statement::Edge(_)));
    assert!(has_subgraph);
    assert!(has_edge);
}
```

**What the failing test asserts:** Parsing produces correct `SubgraphSpec` with id, title, and inner statements.
**Expected failure reason:** `parse_statement()` does not handle `Rule::subgraph_stmt`; returns empty or panics.

### Green: Minimal Implementation

Update `parse_statement()` to handle the new rule:

```rust
fn parse_statement(pair: Pair<Rule>) -> Vec<Statement> {
    let mut statements = Vec::new();
    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::vertex_statement => {
                statements.extend(parse_vertex_statement(inner));
            }
            Rule::subgraph_stmt => {
                statements.push(parse_subgraph(inner));
            }
            _ => {}
        }
    }
    statements
}

fn parse_subgraph(pair: Pair<Rule>) -> Statement {
    let mut id = String::new();
    let mut title = String::new();
    let mut inner_statements = Vec::new();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::subgraph_spec => {
                for spec_part in inner.into_inner() {
                    match spec_part.as_rule() {
                        Rule::subgraph_id => {
                            id = spec_part.as_str().to_string();
                            title = id.clone();
                        }
                        Rule::subgraph_title_bracket => {
                            for title_part in spec_part.into_inner() {
                                if title_part.as_rule() == Rule::subgraph_title_text {
                                    title = title_part.as_str().to_string();
                                }
                            }
                        }
                        _ => {}
                    }
                }
            }
            Rule::statement => {
                inner_statements.extend(parse_statement(inner));
            }
            _ => {} // keywords, newlines
        }
    }

    Statement::Subgraph(SubgraphSpec {
        id,
        title,
        statements: inner_statements,
    })
}
```

### Refactor: Clean Up

- Factor out `parse_subgraph_spec()` if the spec parsing is complex
- Ensure error handling is consistent with existing parser functions
- Consider whether `Flowchart` needs helper methods to iterate over all statements recursively

## Context

- Current `parse_statement()` only handles `Rule::vertex_statement`
- The `parse_subgraph` function recursively calls `parse_statement` for inner statements
- Reference: [Q3 research](../../../research/0016-compound-graph-subgraphs/q3-parser-extension-design.md)

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] `parse_subgraph()` implemented
- [ ] `parse_statement()` updated to handle `Rule::subgraph_stmt`
- [ ] All three test cases pass
- [ ] Existing parser tests pass unchanged

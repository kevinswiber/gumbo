# Task 1.5: Update build_diagram to Process Subgraphs

## Objective

Handle `Statement::Subgraph` in `build_diagram()` to populate `Diagram.subgraphs` and set `Node.parent` fields.

## Location

Modify: `src/graph/builder.rs`

## TDD Phases

### Red: Write Failing Tests

```rust
#[test]
fn test_build_diagram_with_subgraph() {
    let input = "graph TD\nsubgraph sg1[Group]\nA --> B\nend\n";
    let flowchart = parse_flowchart(input).unwrap();
    let diagram = build_diagram(&flowchart);

    assert!(diagram.has_subgraphs());
    assert!(diagram.subgraphs.contains_key("sg1"));
    let sg = &diagram.subgraphs["sg1"];
    assert_eq!(sg.title, "Group");
    assert!(sg.nodes.contains(&"A".to_string()));
    assert!(sg.nodes.contains(&"B".to_string()));
}

#[test]
fn test_build_diagram_node_parent_set() {
    let input = "graph TD\nsubgraph sg1[Group]\nA --> B\nend\nC --> A\n";
    let flowchart = parse_flowchart(input).unwrap();
    let diagram = build_diagram(&flowchart);

    assert_eq!(diagram.nodes["A"].parent, Some("sg1".to_string()));
    assert_eq!(diagram.nodes["B"].parent, Some("sg1".to_string()));
    assert_eq!(diagram.nodes["C"].parent, None);
}

#[test]
fn test_build_diagram_subgraph_edges_cross_boundary() {
    let input = "graph TD\nsubgraph sg1[Group]\nA\nB\nend\nA --> C\nC --> B\n";
    let flowchart = parse_flowchart(input).unwrap();
    let diagram = build_diagram(&flowchart);

    // Edges exist normally regardless of subgraph boundaries
    assert_eq!(diagram.edges.len(), 2);
    assert_eq!(diagram.nodes["A"].parent, Some("sg1".to_string()));
    assert_eq!(diagram.nodes["C"].parent, None);
}
```

**What the failing test asserts:** build_diagram populates subgraphs, sets node parent fields, handles boundary-crossing edges.
**Expected failure reason:** `build_diagram` does not process `Statement::Subgraph` variant; subgraphs map is empty; parent fields are None.

### Green: Minimal Implementation

Refactor `build_diagram` to use a recursive `process_statements` helper:

```rust
pub fn build_diagram(flowchart: &Flowchart) -> Diagram {
    let direction = convert_direction(flowchart.direction);
    let mut diagram = Diagram::new(direction);
    process_statements(&mut diagram, &flowchart.statements, None);
    diagram
}

fn process_statements(
    diagram: &mut Diagram,
    statements: &[Statement],
    parent_subgraph: Option<&str>,
) {
    for statement in statements {
        match statement {
            Statement::Vertex(vertex) => {
                add_vertex(diagram, vertex, parent_subgraph);
            }
            Statement::Edge(edge_spec) => {
                // Add vertices from edge with parent context
                add_vertex(diagram, &edge_spec.from, parent_subgraph);
                add_vertex(diagram, &edge_spec.to, parent_subgraph);
                let edge = convert_edge(edge_spec);
                diagram.add_edge(edge);
            }
            Statement::Subgraph(sg_spec) => {
                // Recursively process inner statements
                process_statements(diagram, &sg_spec.statements, Some(&sg_spec.id));

                // Collect member node IDs
                let node_ids = collect_node_ids(&sg_spec.statements);

                diagram.subgraphs.insert(sg_spec.id.clone(), Subgraph {
                    id: sg_spec.id.clone(),
                    title: sg_spec.title.clone(),
                    nodes: node_ids,
                });
            }
        }
    }
}

fn add_vertex(diagram: &mut Diagram, vertex: &Vertex, parent: Option<&str>) {
    // If node exists, update parent if not already set
    // If node doesn't exist, create with parent
    // ... (adapt existing add_vertex logic)
}

fn collect_node_ids(statements: &[Statement]) -> Vec<String> {
    statements.iter().flat_map(|s| match s {
        Statement::Vertex(v) => vec![v.id.clone()],
        Statement::Edge(e) => vec![e.from.id.clone(), e.to.id.clone()],
        Statement::Subgraph(_) => vec![], // nested subgraphs deferred
    }).collect()
}
```

### Refactor: Clean Up

- Deduplicate node IDs in `collect_node_ids` (use a seen set)
- Factor out vertex-adding logic shared between Vertex and Edge statement handling
- Ensure the existing `build_diagram` function signature is unchanged

## Context

- Current `build_diagram` iterates statements and calls `add_vertex_to_diagram` for Vertex/Edge variants
- The refactoring to `process_statements` adds a `parent_subgraph` parameter for recursive context
- Existing edges are added without modification; boundary crossing is handled at layout time
- Reference: [Q4 research](../../../research/0016-compound-graph-subgraphs/q4-graph-layer-design.md)

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] `build_diagram` processes `Statement::Subgraph` variant
- [ ] Subgraph nodes have correct `parent` field
- [ ] Non-subgraph nodes have `parent == None`
- [ ] Edges cross boundaries normally
- [ ] All existing builder tests pass unchanged

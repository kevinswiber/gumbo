# Task 3.3: Integrate Compound Phases into Layout Pipeline

## Objective

Wire all compound phases into `layout_with_labels()` gated on `has_compound_nodes()`, and add `subgraph_bounds` to `LayoutResult`.

## Location

Modify: `src/dagre/mod.rs`, `src/dagre/types.rs`

## TDD Phases

### Red: Write Failing Tests

```rust
#[test]
fn test_layout_compound_graph_end_to_end() {
    let mut graph = DiGraph::new();
    graph.add_node("sg1", (0.0, 0.0)); // compound node
    graph.add_node("A", (40.0, 20.0));
    graph.add_node("B", (40.0, 20.0));
    graph.add_edge("A", "B");
    graph.set_parent("A", "sg1");
    graph.set_parent("B", "sg1");

    let result = layout(&graph, &LayoutConfig::default());

    // Nodes should be laid out
    assert!(result.nodes.contains_key("A"));
    assert!(result.nodes.contains_key("B"));
    // Subgraph bounds should exist
    assert!(result.subgraph_bounds.contains_key("sg1"));
    let bounds = &result.subgraph_bounds["sg1"];
    assert!(bounds.width > 0.0);
    assert!(bounds.height > 0.0);
}

#[test]
fn test_layout_simple_graph_no_subgraph_bounds() {
    let mut graph = DiGraph::new();
    graph.add_node("A", (40.0, 20.0));
    graph.add_node("B", (40.0, 20.0));
    graph.add_edge("A", "B");

    let result = layout(&graph, &LayoutConfig::default());

    assert!(result.subgraph_bounds.is_empty());
}

#[test]
fn test_existing_fixtures_unchanged() {
    // Run layout on all existing test fixtures and verify outputs match
    // (regression test)
}
```

**What the failing test asserts:** Full compound pipeline produces subgraph bounds; simple graphs unaffected.
**Expected failure reason:** Pipeline doesn't call compound phases; LayoutResult lacks subgraph_bounds.

### Green: Minimal Implementation

Update `layout_with_labels` in `src/dagre/mod.rs`:

```rust
pub fn layout_with_labels<N, F>(...) -> LayoutResult {
    let mut lg = LayoutGraph::from_digraph(graph, get_dimensions);
    let has_compound = !lg.compound_nodes.is_empty();

    if config.acyclic { acyclic::run(&mut lg); }

    if has_compound { nesting::run(&mut lg); }

    rank::run(&mut lg);
    rank::normalize(&mut lg);

    if has_compound {
        nesting::cleanup(&mut lg);
        nesting::assign_rank_minmax(&mut lg);
    }

    // ... reversed edge handling ...

    normalize::run(&mut lg, edge_labels);

    if has_compound {
        border::add_segments(&mut lg);
    }

    order::run(&mut lg);
    position::run(&mut lg, config);

    let subgraph_bounds = if has_compound {
        border::remove_nodes(&mut lg)
    } else {
        HashMap::new()
    };

    // ... extract nodes, edges ...

    LayoutResult {
        nodes: ...,
        edges: ...,
        subgraph_bounds,
        // ...
    }
}
```

Add to `LayoutResult` in `src/dagre/types.rs`:
```rust
pub subgraph_bounds: HashMap<String, Rect>,
```

### Refactor: Clean Up

- Ensure all compound phase calls are clearly commented
- Verify the phase ordering matches dagre.js exactly
- Run full test suite to confirm no regressions

## Context

- This task wires together all the individual compound phases from Tasks 2.3-2.5 and 3.1-3.2
- The pipeline order is critical and must match dagre.js
- `LayoutResult.subgraph_bounds` is consumed by the rendering layer in Phase D
- Reference: [Q5 research](../../../research/0016-compound-graph-subgraphs/q5-dagre-pipeline-changes.md)

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] All compound phases wired into pipeline with correct ordering
- [ ] Gated on `has_compound_nodes()` / `compound_nodes.is_empty()`
- [ ] `LayoutResult.subgraph_bounds` populated for compound graphs
- [ ] Simple graphs produce identical output to current behavior
- [ ] All existing tests pass

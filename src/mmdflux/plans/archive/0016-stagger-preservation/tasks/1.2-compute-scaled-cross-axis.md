# Task 1.2: Compute Scaled Cross-Axis Draw Positions

## Objective

Create a function that converts dagre's continuous cross-axis coordinates to ASCII character positions, preserving relative offsets (stagger) between nodes.

## Location

New function in `src/render/layout.rs`.

## Implementation

```rust
/// Compute cross-axis draw positions by scaling dagre coordinates to ASCII space.
///
/// For each layer, computes where each node's cross-axis center should be
/// in draw coordinates, preserving dagre's relative positioning (stagger).
///
/// Returns: HashMap<node_id, cross_axis_center_draw_position>
fn compute_stagger_positions(
    layers: &[Vec<String>],
    dagre_cross: &HashMap<String, f64>,
    node_dims: &HashMap<String, (usize, usize)>,
    cross_dim_fn: impl Fn(&(usize, usize)) -> usize, // width for TD/BT, height for LR/RL
    spacing: usize,  // h_spacing for TD/BT, v_spacing for LR/RL
    padding: usize,
    label_margin_before: usize, // left_label_margin for TD/BT, 0 for LR/RL
) -> HashMap<String, usize> {
    let mut positions = HashMap::new();

    // Step 1: Find the global dagre cross-axis range across ALL layers
    let all_dagre_vals: Vec<f64> = layers
        .iter()
        .flat_map(|layer| layer.iter().filter_map(|id| dagre_cross.get(id).copied()))
        .collect();

    if all_dagre_vals.is_empty() {
        return positions;
    }

    let dagre_min = all_dagre_vals.iter().cloned().fold(f64::INFINITY, f64::min);
    let dagre_max = all_dagre_vals.iter().cloned().fold(f64::NEG_INFINITY, f64::max);
    let dagre_range = dagre_max - dagre_min;

    // Step 2: For each layer, compute the required content width at grid spacing
    // (this is used as a minimum; stagger may expand it)
    let max_layer_content: usize = layers
        .iter()
        .map(|layer| {
            let content: usize = layer
                .iter()
                .filter_map(|id| node_dims.get(id).map(|d| cross_dim_fn(d)))
                .sum();
            let sp = if layer.len() > 1 { (layer.len() - 1) * spacing } else { 0 };
            content + sp
        })
        .max()
        .unwrap_or(0);

    // Step 3: Determine if stagger is present
    // If all dagre cross-axis values are effectively the same (<1.0 apart),
    // fall back to centered grid positioning (no stagger).
    if dagre_range < 1.0 {
        // No stagger — use existing centering logic (return empty; caller falls back)
        return positions;
    }

    // Step 4: Compute scale factor
    // Map dagre_range to a target ASCII range that accommodates the widest layer
    // plus some margin for the stagger.
    // The stagger offset in ASCII should be proportional to dagre's offset.
    // dagre uses nodesep=50. A reasonable scale: dagre_range maps to
    // max_half_node_width * 2 + a few chars.
    let max_half_cross: usize = layers
        .iter()
        .flat_map(|layer| layer.iter())
        .filter_map(|id| node_dims.get(id).map(|d| cross_dim_fn(d) / 2))
        .max()
        .unwrap_or(0);

    // Target stagger in ASCII chars: proportional but reasonable
    // Minimum: enough to differentiate attachment points (at least 2 chars offset)
    // Maximum: don't make the diagram absurdly wide
    //
    // NOTE: The divisor 50.0 here assumes nodesep=50 (hardcoded at layout.rs line 239).
    // If nodesep ever becomes configurable, this must use the actual config value
    // instead of a hardcoded constant. Consider passing nodesep as a parameter.
    let target_stagger = (dagre_range / 50.0 * (spacing as f64 + 2.0))
        .round()
        .max(2.0)
        .min(max_layer_content as f64 / 2.0) as usize;

    let scale = if dagre_range > f64::EPSILON {
        target_stagger as f64 / dagre_range
    } else {
        0.0
    };

    // Step 5: For each node, compute its cross-axis center position
    // Center the staggered layout within the canvas content area
    let canvas_content_start = padding + label_margin_before;
    let total_content_width = max_layer_content.max(target_stagger + max_half_cross * 2);
    let canvas_center = canvas_content_start + total_content_width / 2;

    let dagre_center = (dagre_min + dagre_max) / 2.0;

    for layer in layers {
        for node_id in layer {
            if let (Some(&dagre_val), Some(dims)) =
                (dagre_cross.get(node_id), node_dims.get(node_id))
            {
                let offset = (dagre_val - dagre_center) * scale;
                let cross_center = (canvas_center as f64 + offset).round().max(
                    (canvas_content_start + cross_dim_fn(dims) / 2) as f64
                ) as usize;
                positions.insert(node_id.clone(), cross_center);
            }
        }
    }

    positions
}
```

## Known Issue: Multi-Node Layer Overlap

When a layer has multiple nodes whose dagre cross-axis values are close together, applying stagger offsets could cause nodes within the same layer to overlap. The current implementation positions each node independently by its stagger center, with no check that adjacent nodes in the same layer maintain minimum spacing.

**Example:** If layer 1 has nodes B (dagre x=16.75) and a dummy-aligned node D (dagre x=18.0), the scaled positions might place them only 1 char apart, which could cause their bounding boxes to overlap.

**Mitigation during implementation:** After computing stagger centers for a multi-node layer, verify that adjacent nodes (sorted by stagger center) maintain at least `spacing` chars between their bounding box edges. If they don't, expand the gap by shifting nodes outward from the layer's center of mass. This is the same constraint the existing grid logic enforces via sequential `x += w + h_spacing` placement — stagger mode needs an equivalent guarantee.

## Known Issue: Hardcoded nodesep=50 Coupling

The scale formula `dagre_range / 50.0` assumes `nodesep=50`, which is hardcoded at `layout.rs:239`. If nodesep becomes configurable, this formula silently breaks. During implementation, consider passing the actual nodesep value as a parameter rather than hardcoding the divisor.

## Context

- The scale factor maps dagre's coordinate range (typically 25-100 px for stagger cases) to a reasonable ASCII character offset (2-8 chars).
- When dagre produces no stagger (dagre_range < 1.0), the function returns an empty map, signaling the caller to use existing centering logic. This ensures no visual regression for non-staggered diagrams.
- `cross_dim_fn` abstracts over width (TD/BT) vs height (LR/RL) so the function works for both orientations.

## Acceptance Criteria

- [ ] Function computes scaled positions preserving dagre's relative node offsets
- [ ] Returns empty map when no stagger is present (dagre_range < 1.0)
- [ ] Stagger offset is at least 2 chars when present (enough to differentiate attachment points)
- [ ] Node positions don't go below padding boundary
- [ ] Multi-node layers maintain minimum spacing between adjacent nodes (no overlap)
- [ ] Scale formula uses nodesep from config, not hardcoded 50.0

# Task 2.1: Update map_cross_axis() Anchors

## Objective

Ensure the per-rank anchor mapping for `map_cross_axis()` uses the new stagger-aware draw positions. Currently, anchors are built from draw positions that already lost the stagger. After tasks 1.3/1.4, draw positions preserve stagger, so anchors will automatically be correct — but verify this.

## Location

Verify/modify: `src/render/layout.rs` — anchor building code at lines ~361-388, inside `compute_layout_dagre()`.

## Implementation

The anchor building code at lines 361-388 already reads from `draw_positions` and `node_dims`:

```rust
let rank_cross_anchors: Vec<Vec<(f64, f64)>> = layers
    .iter()
    .map(|layer| {
        let mut anchors: Vec<(f64, f64)> = layer
            .iter()
            .filter_map(|node_id| {
                let dagre_node = result.nodes.get(&dagre::NodeId(node_id.clone()))?;
                let &(draw_x, draw_y) = draw_positions.get(node_id)?;
                let &(w, h) = node_dims.get(node_id)?;
                // ... computes (dagre_center, draw_center) pairs
            })
            .collect();
        anchors.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap());
        anchors
    })
    .collect();
```

After tasks 1.3/1.4, `draw_positions` now reflects stagger. This means:
- `draw_center_x = (draw_x + w/2)` will be different for staggered nodes
- Anchors will correctly map dagre cross-axis values to stagger-aware draw centers
- `map_cross_axis()` will interpolate/extrapolate waypoints relative to the staggered node positions

**This should work automatically.** The key verification is that `draw_positions` is populated (by tasks 1.3/1.4) BEFORE this anchor building code runs. Check the execution order in `compute_layout_dagre()`.

### Potential issue: single-node layers

When a layer has 1 node (common in stagger cases like `multiple_cycles.mmd`), there's only 1 anchor. The single-anchor case in `map_cross_axis()` (lines 869-881) uses a fixed scale factor of 0.1:

```rust
1 => {
    let (dagre_anchor, draw_anchor) = anchors[0];
    let offset = dagre_pos - dagre_anchor;
    let scaled_offset = offset * 0.1;
    let result = draw_anchor + scaled_offset;
    ...
}
```

This `0.1` factor was set when nodes were centered (no stagger). With stagger-aware anchors, the relationship between dagre coords and draw coords is different. The scaling should now use the actual ratio derived from the stagger scaling.

**Two options for fixing this:**

**Option 1 (Preferred): Derive scale from global anchor pairs.** Since the anchors now encode stagger-aware draw positions, we can compute the actual dagre→draw ratio from any two anchors across different ranks. Collect all `(dagre_cross, draw_cross)` pairs globally, compute a least-squares or min/max ratio, and use that as the single-anchor fallback scale. This avoids threading a new parameter through `map_cross_axis()`.

**Option 2: Pass stagger scale explicitly.** Have `compute_stagger_positions()` return both the positions and the scale factor. Thread this as `Option<f64>` into `map_cross_axis()`. More invasive to the interface but explicit.

```rust
// Option 1: Derive from global anchors
let global_scale: f64 = {
    let all_anchors: Vec<(f64, f64)> = rank_cross_anchors.iter().flatten().copied().collect();
    if all_anchors.len() >= 2 {
        let (d0, w0) = all_anchors[0];
        let (d1, w1) = all_anchors[all_anchors.len() - 1];
        if (d1 - d0).abs() > f64::EPSILON {
            (w1 - w0) / (d1 - d0)
        } else {
            0.1
        }
    } else {
        0.1 // no stagger, default is fine
    }
};
```

Then in the single-anchor case:
```rust
1 => {
    let (dagre_anchor, draw_anchor) = anchors[0];
    let offset = dagre_pos - dagre_anchor;
    let scaled_offset = offset * global_scale;
    let result = draw_anchor + scaled_offset;
    ...
}
```

## Context

- `map_cross_axis()` is used to convert dagre waypoint positions to draw coordinates (lines 401-436).
- The anchors are `(dagre_cross_pos, draw_cross_center)` pairs for real nodes at each rank.
- For ranks with only dummy nodes (no real nodes), the anchor list may be empty → falls back to canvas center.
- The multi-anchor interpolation case (2+ anchors at same rank) works automatically since the anchors encode stagger. Only the single-anchor extrapolation needs the scale fix.
- After stagger preservation, `draw_positions` reflects stagger, so anchors built from draw_positions are automatically correct. The execution order in `compute_layout_dagre()` already builds anchors after draw positions — verify this still holds after the changes from tasks 1.3/1.4.

## Acceptance Criteria

- [ ] Verified that draw_positions is populated before anchor building runs
- [ ] Anchors correctly reflect stagger-aware draw positions
- [ ] Single-anchor waypoint scaling uses consistent scale factor (not hardcoded 0.1)
- [ ] Waypoints for long backward edges map to positions consistent with staggered nodes
- [ ] `map_cross_axis()` produces correct results for `multiple_cycles.mmd` waypoints

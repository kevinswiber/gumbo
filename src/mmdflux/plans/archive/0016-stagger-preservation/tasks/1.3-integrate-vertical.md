# Task 1.3: Integrate Stagger Into grid_to_draw_vertical()

## Objective

Modify `grid_to_draw_vertical()` to use dagre's staggered cross-axis positions when available, instead of always centering each layer independently.

## Location

Modify: `src/render/layout.rs` â€” `grid_to_draw_vertical()` (lines ~630-731) and its call site in `compute_layout_dagre()` (line ~322).

## Implementation

### Add parameter to `grid_to_draw_vertical()`

```rust
fn grid_to_draw_vertical(
    grid_positions: &HashMap<String, GridPos>,
    node_dims: &HashMap<String, (usize, usize)>,
    layers: &[Vec<String>],
    layer_heights: &[usize],
    config: &LayoutConfig,
    reverse: bool,
    stagger_centers: &HashMap<String, usize>, // NEW: dagre stagger positions (cross-axis center)
) -> VerticalLayoutResult {
```

### Modify the node positioning loop (lines ~679-721)

For each layer, check if stagger positions are available. If so, position nodes using stagger centers. If not (empty map = no stagger), use existing centering logic.

```rust
    for (layer_idx, layer) in layers.iter().enumerate() {
        if layer.is_empty() {
            continue;
        }

        let mut sorted_nodes: Vec<_> = layer.iter().collect();
        sorted_nodes.sort_by_key(|id| grid_positions.get(*id).map(|p| p.pos).unwrap_or(0));

        if !stagger_centers.is_empty() && sorted_nodes.iter().any(|id| stagger_centers.contains_key(*id)) {
            // Stagger mode: use dagre-derived cross-axis centers
            for node_id in &sorted_nodes {
                if let Some(&(w, h)) = node_dims.get(*node_id) {
                    let y = layer_y_starts[layer_idx];
                    let x = stagger_centers
                        .get(*node_id)
                        .map(|&center| center.saturating_sub(w / 2))
                        .unwrap_or_else(|| {
                            // Fallback: center in canvas
                            config.padding + config.left_label_margin
                                + (max_layer_content_width.saturating_sub(w)) / 2
                        });
                    draw_positions.insert((*node_id).clone(), (x, y));
                    node_bounds.insert(
                        (*node_id).clone(),
                        NodeBounds { x, y, width: w, height: h },
                    );
                }
            }
        } else {
            // Original centering logic (no stagger)
            let content_width: usize = sorted_nodes
                .iter()
                .filter_map(|id| node_dims.get(*id).map(|(w, _)| *w))
                .sum();
            let spacing = if sorted_nodes.len() > 1 {
                (sorted_nodes.len() - 1) * config.h_spacing
            } else {
                0
            };
            let total_layer_width = content_width + spacing;
            let layer_start_x = config.padding
                + config.left_label_margin
                + (max_layer_content_width - total_layer_width) / 2;

            let mut x = layer_start_x;
            for node_id in &sorted_nodes {
                if let Some(&(w, h)) = node_dims.get(*node_id) {
                    let y = layer_y_starts[layer_idx];
                    draw_positions.insert((*node_id).clone(), (x, y));
                    node_bounds.insert(
                        (*node_id).clone(),
                        NodeBounds { x, y, width: w, height: h },
                    );
                    x += w + config.h_spacing;
                }
            }
        }
    }
```

### Update canvas_width calculation

When stagger is active, `max_layer_content_width` may need to be larger to accommodate the stagger offset. Compute the actual extent from stagger positions:

```rust
    // After positioning all nodes, recalculate canvas width from actual positions
    let actual_max_x = node_bounds.values()
        .map(|b| b.x + b.width)
        .max()
        .unwrap_or(0);
    let canvas_width = actual_max_x + config.padding + config.right_label_margin;
```

### Update call site in `compute_layout_dagre()`

```rust
    let stagger_positions = compute_stagger_positions(
        &layers,
        &dagre_cross_positions,
        &node_dims,
        |d| d.0, // width for TD/BT
        config.h_spacing,
        config.padding,
        config.left_label_margin,
    );

    // In the match arm for TopDown | BottomTop:
    let result = grid_to_draw_vertical(
        &grid_positions,
        &node_dims,
        &layers,
        &layer_heights,
        config,
        diagram.direction == Direction::BottomTop,
        &stagger_positions, // NEW parameter
    );
```

## Context

- The `grid_to_draw_vertical()` function is also called from `compute_layout()` (non-dagre path). That call site should pass an empty HashMap for stagger_centers (no dagre data available).
- Multi-node layers: When a layer has multiple nodes AND stagger is active, each node gets its stagger center independently. The nodes may overlap if dagre positions are too close. The scale factor in task 1.2 should prevent this, but we should clamp/check.
- See [stagger-preservation-analysis.md](../../../research/archive/0009-attachment-point-spreading/stagger-preservation-analysis.md) for the 4 stages where stagger was previously lost.

## Acceptance Criteria

- [ ] `grid_to_draw_vertical()` accepts stagger_centers parameter
- [ ] When stagger_centers is non-empty, nodes positioned by dagre-derived centers
- [ ] When stagger_centers is empty, existing centering logic unchanged
- [ ] Canvas width correctly accounts for stagger offsets
- [ ] Non-dagre call site passes empty HashMap (no regression)
- [ ] `multiple_cycles.mmd` nodes appear at different x positions

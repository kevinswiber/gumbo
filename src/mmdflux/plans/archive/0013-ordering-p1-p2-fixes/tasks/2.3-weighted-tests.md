# Task 2.3: Add Unit Tests for Weighted Barycenter

## Objective

Add tests that verify the weighted barycenter computation works correctly, both with uniform and non-uniform weights.

## Location

Modify: `src/dagre/order.rs` â€” add tests in the `mod tests` block

## Implementation

```rust
#[test]
fn test_weighted_barycenter_uniform_weights() {
    // With all weights = 1.0, weighted barycenter should equal unweighted.
    // Fan-out: A -> B, A -> C
    // B and C have same barycenter from A, so order depends on tie-breaking.
    let mut graph: DiGraph<()> = DiGraph::new();
    graph.add_node("A", ());
    graph.add_node("B", ());
    graph.add_node("C", ());
    graph.add_edge("A", "B");
    graph.add_edge("A", "C");

    let mut lg = LayoutGraph::from_digraph(&graph, |_, _| (10.0, 10.0));
    rank::run(&mut lg);
    rank::normalize(&mut lg);

    // All edge_weights should be 1.0
    assert!(lg.edge_weights.iter().all(|&w| w == 1.0));

    run(&mut lg);

    let layers = rank::by_rank(&lg);
    let edges = lg.effective_edges_weighted();
    assert_eq!(count_all_crossings(&lg, &layers, &edges), 0);
}

#[test]
fn test_weighted_barycenter_nonuniform() {
    // Manually set up a scenario with different weights to verify
    // the weighted formula: sum(w * pos) / sum(w)
    //
    // Layer 0: X(order=0), Y(order=1)
    // Layer 1: A has edges from X (weight=3) and Y (weight=1)
    // Weighted barycenter of A = (3*0 + 1*1) / (3+1) = 0.25
    // Unweighted would be (0+1)/2 = 0.5
    //
    // This test verifies the weighted path by checking that A's
    // barycenter pulls it closer to X (the heavier connection).
    let mut graph: DiGraph<()> = DiGraph::new();
    graph.add_node("X", ());
    graph.add_node("Y", ());
    graph.add_node("A", ());
    graph.add_node("B", ());
    graph.add_edge("X", "A");
    graph.add_edge("Y", "A");
    graph.add_edge("Y", "B");

    let mut lg = LayoutGraph::from_digraph(&graph, |_, _| (10.0, 10.0));
    rank::run(&mut lg);
    rank::normalize(&mut lg);

    // Set non-uniform weight on the X->A edge
    // Find the edge index for X->A
    let x = lg.node_index[&NodeId::from("X")];
    let a = lg.node_index[&NodeId::from("A")];
    for (idx, &(from, to, _)) in lg.edges.iter().enumerate() {
        let (eff_from, eff_to) = if lg.reversed_edges.contains(&idx) {
            (to, from)
        } else {
            (from, to)
        };
        if eff_from == x && eff_to == a {
            lg.edge_weights[idx] = 3.0;
        }
    }

    // Set up orders
    lg.order[x] = 0;
    let y = lg.node_index[&NodeId::from("Y")];
    lg.order[y] = 1;

    let edges = lg.effective_edges_weighted();
    let fixed = vec![x, y];
    let b = lg.node_index[&NodeId::from("B")];
    let free = vec![a, b];
    lg.order[a] = 0;
    lg.order[b] = 1;

    reorder_layer(&mut lg, &fixed, &free, &edges, true, false);

    // A has weighted barycenter 0.25, B has barycenter 1.0
    // So A should be at position 0, B at position 1
    assert_eq!(lg.order[a], 0, "A (weighted barycenter 0.25) should be first");
    assert_eq!(lg.order[b], 1, "B (barycenter 1.0) should be second");
}
```

## Context

The uniform-weights test ensures P2 doesn't regress behavior. The non-uniform test verifies the weighted formula works by giving one edge a weight of 3.0 and checking that the node is pulled toward the heavier connection.

## Acceptance Criteria

- [ ] Uniform weight test passes (no behavior change from P2)
- [ ] Non-uniform weight test passes (weighted barycenter computed correctly)
- [ ] All existing tests still pass

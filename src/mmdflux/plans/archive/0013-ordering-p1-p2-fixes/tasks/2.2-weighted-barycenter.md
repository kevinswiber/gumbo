# Task 2.2: Update reorder_layer() and Callers for Weighted Edges

## Objective

Change the barycenter computation in `reorder_layer()` to use edge weights, and update all callers to pass weighted edges.

## Location

Modify: `src/dagre/order.rs` — `reorder_layer()`, `sweep_up()`, `sweep_down()`, `run()`

## Implementation

### Change edges type in reorder_layer()

Update the `edges` parameter from `&[(usize, usize)]` to `&[(usize, usize, f64)]`:

```rust
fn reorder_layer(
    graph: &mut LayoutGraph,
    fixed: &[usize],
    free: &[usize],
    edges: &[(usize, usize, f64)],  // changed: now includes weight
    downward: bool,
    bias_right: bool,
) {
```

### Update neighbor collection to capture weights

In the neighbor-finding block, collect `(neighbor, weight)` pairs instead of just neighbors:

```rust
let neighbor_weights: Vec<(usize, f64)> = if downward {
    edges
        .iter()
        .filter(|&&(_, to, _)| to == node)
        .map(|&(from, _, w)| (from, w))
        .filter(|&(n, _)| fixed.contains(&n))
        .collect()
} else {
    edges
        .iter()
        .filter(|&&(from, _, _)| from == node)
        .map(|&(_, to, w)| (to, w))
        .filter(|&(n, _)| fixed.contains(&n))
        .collect()
};

if neighbor_weights.is_empty() {
    unsortable.push((node, original_pos));
} else {
    let weighted_sum: f64 = neighbor_weights
        .iter()
        .map(|&(n, w)| w * graph.order[n] as f64)
        .sum();
    let total_weight: f64 = neighbor_weights.iter().map(|&(_, w)| w).sum();
    let barycenter = weighted_sum / total_weight;
    sortable.push((node, barycenter, original_pos));
}
```

### Update sweep_up, sweep_down, run

Change these functions to use `effective_edges_weighted()`:

```rust
pub fn run(graph: &mut LayoutGraph) {
    // ...
    let edges = graph.effective_edges_weighted();  // changed
    // ... rest uses edges as before
}

fn sweep_down(
    graph: &mut LayoutGraph,
    layers: &[Vec<usize>],
    edges: &[(usize, usize, f64)],  // changed
    bias_right: bool,
) { /* body unchanged */ }

fn sweep_up(
    graph: &mut LayoutGraph,
    layers: &[Vec<usize>],
    edges: &[(usize, usize, f64)],  // changed
    bias_right: bool,
) { /* body unchanged */ }
```

### Update count_all_crossings and count_crossings_between

These also receive `edges`. Two options:
1. Change them to accept `&[(usize, usize, f64)]` and ignore the weight (simplest)
2. Keep them using the unweighted `effective_edges()` separately

Option 1 is simpler — just update the destructuring patterns:

```rust
fn count_all_crossings(
    graph: &LayoutGraph,
    layers: &[Vec<usize>],
    edges: &[(usize, usize, f64)],  // changed
) -> usize {
    // ... same logic, destructure as (from, to, _)
}

fn count_crossings_between(
    graph: &LayoutGraph,
    layer1: &[usize],
    layer2: &[usize],
    edges: &[(usize, usize, f64)],  // changed
) -> usize {
    let mut edge_positions: Vec<(usize, usize)> = Vec::new();
    for &(from, to, _) in edges {  // changed: ignore weight
        // ... rest unchanged
    }
    // ... rest unchanged
}
```

### Update test helpers

Tests that call `effective_edges()` need to switch to `effective_edges_weighted()` or keep using the unweighted version. Since tests call `count_all_crossings` which now takes weighted edges, update test code to use `effective_edges_weighted()`.

## Context

When all weights are 1.0 (the current state), the weighted formula `sum(1.0 * order) / sum(1.0)` = `sum(order) / count` — identical to the previous unweighted formula. So this change is a no-op for existing inputs.

## Acceptance Criteria

- [ ] `reorder_layer()` accepts weighted edges and computes weighted barycenter
- [ ] `sweep_up()`, `sweep_down()`, `run()` pass weighted edges
- [ ] `count_all_crossings()`, `count_crossings_between()` accept weighted edges (ignore weight)
- [ ] All existing tests pass (behavior unchanged with weight=1.0)

# Task 1.1: Refactor reorder_layer() with Unsortable Interleaving

## Objective

Replace the current uniform-sort approach in `reorder_layer()` with dagre v0.8.5's partition-and-interleave algorithm, where nodes without neighbors in the fixed layer are treated as "unsortable" and placed at their original positions.

## Location

Modify: `src/dagre/order.rs` — function `reorder_layer()` (lines 162-221)

## Implementation

Replace the entire `reorder_layer()` function body:

```rust
fn reorder_layer(
    graph: &mut LayoutGraph,
    fixed: &[usize],
    free: &[usize],
    edges: &[(usize, usize)],
    downward: bool,
    bias_right: bool,
) {
    // Step 1: Compute barycenters, partition into sortable/unsortable
    let mut sortable: Vec<(usize, f64, usize)> = Vec::new(); // (node, barycenter, original_pos)
    let mut unsortable: Vec<(usize, usize)> = Vec::new();     // (node, original_pos)

    for (original_pos, &node) in free.iter().enumerate() {
        let neighbors: Vec<usize> = if downward {
            edges
                .iter()
                .filter(|&&(_, to)| to == node)
                .map(|&(from, _)| from)
                .filter(|n| fixed.contains(n))
                .collect()
        } else {
            edges
                .iter()
                .filter(|&&(from, _)| from == node)
                .map(|&(_, to)| to)
                .filter(|n| fixed.contains(n))
                .collect()
        };

        if neighbors.is_empty() {
            unsortable.push((node, original_pos));
        } else {
            let sum: f64 = neighbors.iter().map(|&n| graph.order[n] as f64).sum();
            let barycenter = sum / neighbors.len() as f64;
            sortable.push((node, barycenter, original_pos));
        }
    }

    // Step 2: Sort sortable by barycenter with bias-aware tie-breaking
    sortable.sort_by(|a, b| {
        a.1.partial_cmp(&b.1)
            .unwrap_or(std::cmp::Ordering::Equal)
            .then_with(|| {
                if bias_right {
                    b.2.cmp(&a.2)
                } else {
                    a.2.cmp(&b.2)
                }
            })
    });

    // Step 3: Sort unsortable by descending original_pos (stack: pop from back)
    unsortable.sort_by(|a, b| b.1.cmp(&a.1));

    // Step 4: Interleave using consumeUnsortable pattern
    let mut result: Vec<usize> = Vec::with_capacity(free.len());
    let mut vs_index: usize = 0;

    // Helper: consume unsortable entries whose original_pos <= vs_index
    fn consume_unsortable(
        result: &mut Vec<usize>,
        unsortable: &mut Vec<(usize, usize)>,
        vs_index: &mut usize,
    ) {
        while let Some(&(_, orig_pos)) = unsortable.last() {
            if orig_pos <= *vs_index {
                let (node, _) = unsortable.pop().unwrap();
                result.push(node);
                *vs_index += 1;
            } else {
                break;
            }
        }
    }

    consume_unsortable(&mut result, &mut unsortable, &mut vs_index);

    for &(node, _, _) in &sortable {
        result.push(node);
        vs_index += 1;
        consume_unsortable(&mut result, &mut unsortable, &mut vs_index);
    }

    // Drain any remaining unsortable entries
    while let Some((node, _)) = unsortable.pop() {
        result.push(node);
    }

    // Step 5: Assign new order positions
    for (new_pos, &node) in result.iter().enumerate() {
        graph.order[node] = new_pos;
    }
}
```

## Context

**Dagre reference:** `sort.js` in dagre v0.8.5 — see [sort-pipeline.md](../../../research/archive/0007-ordering-algorithm/v085-audit/sort-pipeline.md) section 2 (sort.js) and section 4.1 (handling of nodes with NO neighbors).

**Key behavioral difference:** In the current code, neighborless nodes get `graph.order[node]` as a synthetic barycenter and compete with connected nodes in the sort. In dagre, they are kept separate and interleaved at their original positions — they never displace barycenter-sorted nodes.

**The `consumeUnsortable` algorithm:** After placing each sortable entry, check if any unsortable entries have an original index that "fits" at the current output position. This preserves the positional stability of disconnected nodes.

**Impact scope:** For fully-connected graphs (where every node has at least one neighbor in the adjacent layer), all nodes are sortable and the interleaving loop is a no-op — behavior is identical to the current code. Only layers with a mix of connected and disconnected nodes will see different ordering.

## Acceptance Criteria

- [ ] `reorder_layer()` partitions nodes into sortable and unsortable sets
- [ ] Sortable nodes are sorted by barycenter with bias-aware tie-breaking (unchanged)
- [ ] Unsortable nodes are interleaved at their original positions using the `consumeUnsortable` pattern
- [ ] All 9 existing `order::tests` pass without modification

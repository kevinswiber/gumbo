# Task 1.3: Add Unit Tests for Unsortable Interleaving

## Objective

Add targeted unit tests that verify the unsortable interleaving behavior works correctly for various edge cases.

## Location

Modify: `src/dagre/order.rs` — add tests in the `mod tests` block (after line 559)

## Implementation

```rust
#[test]
fn test_unsortable_nodes_preserve_position() {
    // Layer 0: A, B
    // Layer 1: C (connected to A), D (disconnected), E (connected to B)
    // After ordering layer 1 with layer 0 fixed, D should stay between C and E
    let mut graph: DiGraph<()> = DiGraph::new();
    graph.add_node("A", ());
    graph.add_node("B", ());
    graph.add_node("C", ());
    graph.add_node("D", ());
    graph.add_node("E", ());
    graph.add_edge("A", "C");
    graph.add_edge("B", "E");

    let mut lg = LayoutGraph::from_digraph(&graph, |_, _| (10.0, 10.0));
    rank::run(&mut lg);
    rank::normalize(&mut lg);

    run(&mut lg);

    // D should not be displaced to position 0 or 2
    let d = lg.node_index[&NodeId::from("D")];
    let c = lg.node_index[&NodeId::from("C")];
    let e = lg.node_index[&NodeId::from("E")];
    // All three should have distinct consecutive orders
    let mut orders = vec![lg.order[c], lg.order[d], lg.order[e]];
    orders.sort();
    assert_eq!(orders, vec![0, 1, 2]);
}

#[test]
fn test_all_unsortable_preserves_order() {
    // Two layers with no edges between them.
    // Layer 1 nodes should maintain their init_order positions.
    let mut graph: DiGraph<()> = DiGraph::new();
    graph.add_node("A", ());
    graph.add_node("B", ());
    graph.add_node("C", ());
    graph.add_node("D", ());
    // A->B puts A at rank 0, B at rank 1
    // C->D puts C at rank 0, D at rank 1
    // No cross-layer edges between {A,C} and {B,D} other than A->B, C->D
    graph.add_edge("A", "B");
    graph.add_edge("C", "D");

    let mut lg = LayoutGraph::from_digraph(&graph, |_, _| (10.0, 10.0));
    rank::run(&mut lg);
    rank::normalize(&mut lg);

    run(&mut lg);

    let layers = rank::by_rank(&lg);
    let edges = lg.effective_edges();
    assert_eq!(count_all_crossings(&lg, &layers, &edges), 0);
}

#[test]
fn test_all_sortable_unchanged() {
    // Diamond: A -> B, A -> C, B -> D, C -> D
    // All nodes have neighbors — sortable path only.
    // Should produce zero crossings (same as before).
    let mut graph: DiGraph<()> = DiGraph::new();
    graph.add_node("A", ());
    graph.add_node("B", ());
    graph.add_node("C", ());
    graph.add_node("D", ());
    graph.add_edge("A", "B");
    graph.add_edge("A", "C");
    graph.add_edge("B", "D");
    graph.add_edge("C", "D");

    let mut lg = LayoutGraph::from_digraph(&graph, |_, _| (10.0, 10.0));
    rank::run(&mut lg);
    rank::normalize(&mut lg);

    run(&mut lg);

    let layers = rank::by_rank(&lg);
    let edges = lg.effective_edges();
    assert_eq!(count_all_crossings(&lg, &layers, &edges), 0);
}

#[test]
fn test_reorder_layer_unsortable_interleaving() {
    // Directly test reorder_layer with a controlled setup:
    // Fixed layer [X, Y] at positions 0, 1
    // Free layer [A, B, C] where A connects to X, C connects to Y, B has no neighbors
    // B (unsortable, original_pos=1) should stay at position 1
    let mut graph: DiGraph<()> = DiGraph::new();
    graph.add_node("X", ());
    graph.add_node("Y", ());
    graph.add_node("A", ());
    graph.add_node("B", ());
    graph.add_node("C", ());
    graph.add_edge("X", "A");
    graph.add_edge("Y", "C");

    let mut lg = LayoutGraph::from_digraph(&graph, |_, _| (10.0, 10.0));
    rank::run(&mut lg);
    rank::normalize(&mut lg);

    let x = lg.node_index[&NodeId::from("X")];
    let y = lg.node_index[&NodeId::from("Y")];
    let a = lg.node_index[&NodeId::from("A")];
    let b = lg.node_index[&NodeId::from("B")];
    let c = lg.node_index[&NodeId::from("C")];

    // Set up fixed layer order
    lg.order[x] = 0;
    lg.order[y] = 1;
    // Set up free layer order: A=0, B=1, C=2
    lg.order[a] = 0;
    lg.order[b] = 1;
    lg.order[c] = 2;

    let edges = lg.effective_edges();
    let fixed = vec![x, y];
    let free = vec![a, b, c];
    reorder_layer(&mut lg, &fixed, &free, &edges, true, false);

    // A should be at 0 (barycenter from X at pos 0)
    // B should be at 1 (unsortable, original_pos=1, interleaved)
    // C should be at 2 (barycenter from Y at pos 1)
    assert_eq!(lg.order[a], 0);
    assert_eq!(lg.order[b], 1);
    assert_eq!(lg.order[c], 2);
}
```

## Context

These tests exercise the partition-and-interleave logic from Task 1.1. The key test is `test_reorder_layer_unsortable_interleaving` which directly calls `reorder_layer()` with a controlled setup to verify exact placement.

Note: Some tests may need adjustment depending on how `rank::run` assigns ranks to disconnected nodes. The `test_reorder_layer_unsortable_interleaving` test avoids this by setting up orders manually.

## Acceptance Criteria

- [ ] All new tests pass
- [ ] Tests cover: mixed sortable/unsortable, all unsortable, all sortable, direct reorder_layer call
- [ ] All existing tests still pass

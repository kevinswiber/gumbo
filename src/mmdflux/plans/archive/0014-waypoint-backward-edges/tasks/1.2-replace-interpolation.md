# Task 1.2: Replace Linear Interpolation with Anchor-Based Mapping

## Objective

Replace the linear interpolation in the waypoint coordinate conversion loop with the anchor-based `map_cross_axis()` function from Task 1.1.

## Location

Modify: `src/render/layout.rs` — the waypoint conversion loop at lines 440-468 inside `compute_layout_dagre()`.

## Implementation

Replace the current waypoint conversion code (lines 440-468):

```rust
// BEFORE (current code):
let converted: Vec<(usize, usize)> = waypoints
    .iter()
    .map(|wp| {
        let rank_idx = wp.rank as usize;
        if is_vertical {
            let y = layer_starts.get(rank_idx).copied().unwrap_or(0);
            let total_ranks = waypoints.len() + 1;
            let progress = (rank_idx as f64) / (total_ranks as f64);
            let x = src_center_x as f64
                + (tgt_center_x as f64 - src_center_x as f64) * progress;
            (x.round() as usize, y)
        } else {
            let x = layer_starts.get(rank_idx).copied().unwrap_or(0);
            let total_ranks = waypoints.len() + 1;
            let progress = (rank_idx as f64) / (total_ranks as f64);
            let y = src_center_y as f64
                + (tgt_center_y as f64 - src_center_y as f64) * progress;
            (x, y.round() as usize)
        }
    })
    .collect();
```

With:

```rust
// AFTER (anchor-based mapping):
let canvas_cross_extent = if is_vertical { width } else { height };

let converted: Vec<(usize, usize)> = waypoints
    .iter()
    .map(|wp| {
        let rank_idx = wp.rank as usize;

        if is_vertical {
            // TD/BT: primary axis = Y (from layer_starts), cross axis = X (from dagre)
            let y = layer_starts.get(rank_idx).copied().unwrap_or(0);
            let anchors = rank_cross_anchors.get(rank_idx).map(|a| a.as_slice()).unwrap_or(&[]);
            let x = map_cross_axis(wp.point.x, anchors, canvas_cross_extent);
            (x, y)
        } else {
            // LR/RL: primary axis = X (from layer_starts), cross axis = Y (from dagre)
            let x = layer_starts.get(rank_idx).copied().unwrap_or(0);
            let anchors = rank_cross_anchors.get(rank_idx).map(|a| a.as_slice()).unwrap_or(&[]);
            let y = map_cross_axis(wp.point.y, anchors, canvas_cross_extent);
            (x, y)
        }
    })
    .collect();
```

Note: `wp.point.x` and `wp.point.y` are the dagre coordinates stored in `WaypointWithRank.point` (a `dagre::Point` with `f64` fields). These come from `denormalize()` in `src/dagre/normalize.rs` which extracts them from dummy node positions.

## Context

The key change is that we now use **dagre's actual cross-axis position** for the waypoint instead of interpolating between source and target. For forward edges this is a refinement (often similar to interpolation). For backward edges this is essential — dagre places their dummy nodes to the **side** of real nodes at intermediate ranks, not between source and target.

The `rank_cross_anchors` variable was built in Task 1.1. It provides the (dagre, draw) coordinate pairs for all real nodes at each rank.

The `src_center_x`, `src_center_y`, `tgt_center_x`, `tgt_center_y` variables that were previously used for interpolation are no longer needed for this code block (they may still be used elsewhere for label position conversion — check before removing).

## Acceptance Criteria

- [ ] Waypoint cross-axis coordinates use dagre's actual position via `map_cross_axis()`
- [ ] Forward edge waypoint tests (`test_waypoint_transformation_vertical`, `test_waypoint_transformation_horizontal`) still pass — positions may shift slightly
- [ ] `cargo test` passes
- [ ] `cargo run -- tests/fixtures/complex.mmd` renders without panics

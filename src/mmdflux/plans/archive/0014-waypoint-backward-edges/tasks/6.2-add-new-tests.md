# Task 6.2: Add New Backward Edge Waypoint Tests

## Objective

Add new test cases that verify backward edges are correctly routed through waypoints, waypoints are reversed, entry direction is computed correctly, and all 4 layout directions work.

## Location

Add to: `src/render/router.rs` (tests module, after existing backward edge tests)

## Implementation

### Test 1: Backward edge spanning 2+ ranks uses waypoints

```rust
#[test]
fn test_backward_edge_with_waypoints_td() {
    // Create a diagram where the backward edge spans 2+ ranks,
    // forcing dummy node creation and waypoints
    let mut diagram = Diagram::new(Direction::TopDown);
    diagram.add_node(Node::new("A").with_label("Top"));
    diagram.add_node(Node::new("B").with_label("Middle"));
    diagram.add_node(Node::new("C").with_label("Bottom"));
    diagram.add_edge(Edge::new("A", "B")); // Forward
    diagram.add_edge(Edge::new("B", "C")); // Forward
    diagram.add_edge(Edge::new("C", "A")); // Backward spanning 2 ranks

    let config = LayoutConfig::default();
    let layout = compute_layout_dagre(&diagram, &config);

    // The C→A backward edge should have waypoints (dummy at intermediate rank)
    let key = ("C".to_string(), "A".to_string());
    let has_waypoints = layout.edge_waypoints.get(&key).map_or(false, |wps| !wps.is_empty());

    // Route the backward edge
    let backward_edge = &diagram.edges[2];
    let routed = route_edge(backward_edge, &layout, Direction::TopDown).unwrap();

    // Should have multiple segments (not just 3 corridor segments)
    assert!(
        routed.segments.len() >= 2,
        "Backward edge should have routing segments, got {}",
        routed.segments.len()
    );

    // Entry direction should be determined by segment geometry, not hardcoded
    // For a TD backward edge coming from below, entry is from Bottom (arrow points up)
    // or from a side depending on path geometry
}
```

### Test 2: Short backward edge (1 rank span, no waypoints)

```rust
#[test]
fn test_short_backward_edge_no_waypoints() {
    // B→A backward edge spanning exactly 1 rank — no dummies, no waypoints
    let mut diagram = Diagram::new(Direction::TopDown);
    diagram.add_node(Node::new("A").with_label("Top"));
    diagram.add_node(Node::new("B").with_label("Bottom"));
    diagram.add_edge(Edge::new("A", "B")); // Forward
    diagram.add_edge(Edge::new("B", "A")); // Backward, 1 rank

    let config = LayoutConfig::default();
    let layout = compute_layout_dagre(&diagram, &config);

    // Should NOT have waypoints for the backward edge
    let key = ("B".to_string(), "A".to_string());
    let has_waypoints = layout.edge_waypoints.get(&key).map_or(false, |wps| !wps.is_empty());

    // Route should still succeed
    let backward_edge = &diagram.edges[1];
    let routed = route_edge(backward_edge, &layout, Direction::TopDown);
    assert!(routed.is_some(), "Short backward edge should route successfully");
}
```

### Test 3: Backward edge in LR direction

```rust
#[test]
fn test_backward_edge_lr_with_waypoints() {
    let mut diagram = Diagram::new(Direction::LeftRight);
    diagram.add_node(Node::new("A").with_label("Left"));
    diagram.add_node(Node::new("B").with_label("Mid"));
    diagram.add_node(Node::new("C").with_label("Right"));
    diagram.add_edge(Edge::new("A", "B"));
    diagram.add_edge(Edge::new("B", "C"));
    diagram.add_edge(Edge::new("C", "A")); // Backward, spans 2 ranks

    let config = LayoutConfig::default();
    let layout = compute_layout_dagre(&diagram, &config);

    let backward_edge = &diagram.edges[2];
    let routed = route_edge(backward_edge, &layout, Direction::LeftRight);
    assert!(routed.is_some(), "LR backward edge should route successfully");
}
```

### Test 4: Canvas size does not include corridor space

```rust
#[test]
fn test_no_corridor_canvas_expansion() {
    // Create diagram with backward edge
    let mut diagram_with_cycle = Diagram::new(Direction::TopDown);
    diagram_with_cycle.add_node(Node::new("A").with_label("Top"));
    diagram_with_cycle.add_node(Node::new("B").with_label("Bottom"));
    diagram_with_cycle.add_edge(Edge::new("A", "B"));
    diagram_with_cycle.add_edge(Edge::new("B", "A")); // Backward

    // Create same diagram without backward edge
    let mut diagram_no_cycle = Diagram::new(Direction::TopDown);
    diagram_no_cycle.add_node(Node::new("A").with_label("Top"));
    diagram_no_cycle.add_node(Node::new("B").with_label("Bottom"));
    diagram_no_cycle.add_edge(Edge::new("A", "B"));

    let config = LayoutConfig::default();
    let layout_cycle = compute_layout_dagre(&diagram_with_cycle, &config);
    let layout_no_cycle = compute_layout_dagre(&diagram_no_cycle, &config);

    // Canvas width should be the same — no corridor expansion
    assert_eq!(
        layout_cycle.width, layout_no_cycle.width,
        "Backward edge should not expand canvas width (no corridor). With cycle: {}, without: {}",
        layout_cycle.width, layout_no_cycle.width
    );
}
```

## Context

- Use `compute_layout_dagre()` (not `compute_layout()`) for these tests since dagre is the layout engine that produces waypoints
- Import `compute_layout_dagre` at the test module top if not already imported
- The exact waypoint presence depends on dagre's acyclic/normalization behavior — a backward edge spanning 2+ ranks should produce dummies, but 1-rank spans should not

## Acceptance Criteria

- [ ] All 4 new tests added and passing
- [ ] Tests verify backward edge routing works without corridors
- [ ] Tests cover TD and LR directions
- [ ] Canvas width test confirms no corridor expansion

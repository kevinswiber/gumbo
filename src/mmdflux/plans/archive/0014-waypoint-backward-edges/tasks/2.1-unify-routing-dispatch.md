# Task 2.1: Unify Routing Dispatch in route_edge()

## Objective

Modify `route_edge()` so that backward edges with waypoints are routed through `route_edge_with_waypoints()` instead of `route_backward_edge()`. The waypoint list is reversed for backward edges so the router sees source→target order.

## Location

Modify: `src/render/router.rs` — function `route_edge()` at lines 123-177.

## Implementation

Replace the current `route_edge()` function body:

```rust
/// Route an edge between two nodes.
pub fn route_edge(
    edge: &Edge,
    layout: &Layout,
    diagram_direction: Direction,
) -> Option<RoutedEdge> {
    let from_bounds = layout.get_bounds(&edge.from)?;
    let to_bounds = layout.get_bounds(&edge.to)?;

    // Get node shapes for intersection calculation
    let from_shape = layout
        .node_shapes
        .get(&edge.from)
        .copied()
        .unwrap_or(Shape::Rectangle);
    let to_shape = layout
        .node_shapes
        .get(&edge.to)
        .copied()
        .unwrap_or(Shape::Rectangle);

    // Check for waypoints from normalization — works for both forward and backward long edges
    let edge_key = (edge.from.clone(), edge.to.clone());
    if let Some(wps) = layout.edge_waypoints.get(&edge_key) {
        if !wps.is_empty() {
            let is_backward = is_backward_edge(from_bounds, to_bounds, diagram_direction);

            // For backward edges, reverse waypoints so they go from source to target.
            // Dagre stores them in effective/forward order (low rank → high rank),
            // but the backward edge goes from high rank → low rank.
            let waypoints: Vec<(usize, usize)> = if is_backward {
                wps.iter().rev().copied().collect()
            } else {
                wps.to_vec()
            };

            return route_edge_with_waypoints(
                edge,
                from_bounds,
                from_shape,
                to_bounds,
                to_shape,
                &waypoints,
                diagram_direction,
            );
        }
    }

    // No waypoints: direct routing (works for both forward and short backward edges)
    // For short backward edges (1 rank span, no dummies), the direct router
    // produces correct entry direction from segment geometry.
    route_edge_direct(
        edge,
        from_bounds,
        from_shape,
        to_bounds,
        to_shape,
        diagram_direction,
    )
}
```

### Key changes from current code:

1. **Removed**: The early `is_backward_edge` check and `route_backward_edge()` call (lines 132-135)
2. **Added**: `is_backward` check inside the waypoint branch, with `wps.iter().rev()` for backward edges
3. **Simplified fallback**: Both forward and backward edges without waypoints use `route_edge_direct()`. Short backward edges (1 rank span) have no dummy nodes and thus no waypoints — they route directly, and the `entry_direction_from_segments()` function will compute the correct arrow direction from the final segment geometry.

## Context

- `route_edge_with_waypoints()` (lines 183-237) already handles arbitrary waypoint lists. It calls `calculate_attachment_points()` which determines entry/exit points based on waypoint positions relative to node bounds. For backward edges, the reversed waypoints will cause the first waypoint to be near the source and the last near the target — exactly what the function expects.

- `route_edge_direct()` (around line 240) handles direct routing between two nodes. For a backward edge spanning only 1 rank, the target is above the source (TD). The `build_orthogonal_path_for_direction()` function will produce a path that goes upward, and `entry_direction_from_segments()` will correctly compute `AttachDirection::Bottom` (arrow pointing up).

- `is_backward_edge()` (lines 106-121) is unchanged and still used for the waypoint reversal decision.

## Acceptance Criteria

- [ ] Backward edges with waypoints are routed through `route_edge_with_waypoints()` with reversed waypoint order
- [ ] Short backward edges (no waypoints) fall through to `route_edge_direct()`
- [ ] Forward edges are unaffected
- [ ] Code compiles (corridor routing functions still exist but unused — removed in Task 2.2)

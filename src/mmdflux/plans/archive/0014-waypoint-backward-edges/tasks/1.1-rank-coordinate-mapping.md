# Task 1.1: Build Per-Rank Dagre-to-Draw Coordinate Mapping

## Objective

Build a data structure that maps dagre cross-axis coordinates to draw coordinates for each rank, using real node positions as anchor points. This enables accurate waypoint placement — especially critical for backward edges where dagre places dummy nodes to the side of other nodes.

## Location

Modify: `src/render/layout.rs` — inside `compute_layout_dagre()`, after `grid_to_draw_vertical/horizontal()` returns but before the waypoint conversion loop.

## Implementation

Add this code block between line 411 (after corridor expansion, which will be removed in Phase 3) and line 412 (the waypoint conversion comment):

```rust
// Build per-rank anchor mapping from dagre coordinate space to draw coordinate space.
// For each rank, collect (dagre_cross_pos, draw_cross_center) pairs from real nodes.
// These anchors allow us to map waypoint cross-axis positions accurately instead of
// linearly interpolating between source and target.
let rank_cross_anchors: Vec<Vec<(f64, f64)>> = layers
    .iter()
    .map(|layer| {
        let mut anchors: Vec<(f64, f64)> = layer
            .iter()
            .filter_map(|node_id| {
                let dagre_node = result.nodes.get(&dagre::NodeId(node_id.clone()))?;
                let &(draw_x, draw_y) = draw_positions.get(node_id)?;
                let &(w, h) = node_dims.get(node_id)?;

                if is_vertical {
                    // TD/BT: cross-axis is X
                    let dagre_center_x = dagre_node.x + dagre_node.width / 2.0;
                    let draw_center_x = (draw_x + w / 2) as f64;
                    Some((dagre_center_x, draw_center_x))
                } else {
                    // LR/RL: cross-axis is Y
                    let dagre_center_y = dagre_node.y + dagre_node.height / 2.0;
                    let draw_center_y = (draw_y + h / 2) as f64;
                    Some((dagre_center_y, draw_center_y))
                }
            })
            .collect();

        anchors.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap_or(std::cmp::Ordering::Equal));
        anchors
    })
    .collect();
```

Also add this helper function (outside `compute_layout_dagre`, at module level):

```rust
/// Map a dagre cross-axis coordinate to draw coordinate using anchor points at a given rank.
///
/// Uses piecewise linear interpolation between known node positions.
/// If the target coordinate is outside the anchor range, extrapolates from the nearest pair.
/// Falls back to returning the coordinate clamped to canvas bounds if no anchors exist.
fn map_cross_axis(dagre_pos: f64, anchors: &[(f64, f64)], canvas_extent: usize) -> usize {
    match anchors.len() {
        0 => {
            // No anchors at this rank — clamp to canvas center
            canvas_extent / 2
        }
        1 => {
            // Single anchor: offset from it
            let (dagre_anchor, draw_anchor) = anchors[0];
            let offset = dagre_pos - dagre_anchor;
            // Scale: dagre uses node_sep=50, draw uses h_spacing≈4-6
            // Use ratio of ~0.1 as rough scaling factor
            let scaled_offset = offset * 0.1;
            let result = draw_anchor + scaled_offset;
            result.round().max(0.0).min(canvas_extent as f64) as usize
        }
        _ => {
            // Multiple anchors: piecewise linear interpolation
            // Find the two anchors bracketing dagre_pos
            if dagre_pos <= anchors[0].0 {
                // Before first anchor — extrapolate from first two
                let (d0, w0) = anchors[0];
                let (d1, w1) = anchors[1];
                let ratio = if (d1 - d0).abs() > f64::EPSILON {
                    (dagre_pos - d0) / (d1 - d0)
                } else {
                    0.0
                };
                let result = w0 + ratio * (w1 - w0);
                result.round().max(0.0).min(canvas_extent as f64) as usize
            } else if dagre_pos >= anchors[anchors.len() - 1].0 {
                // After last anchor — extrapolate from last two
                let n = anchors.len();
                let (d0, w0) = anchors[n - 2];
                let (d1, w1) = anchors[n - 1];
                let ratio = if (d1 - d0).abs() > f64::EPSILON {
                    (dagre_pos - d0) / (d1 - d0)
                } else {
                    1.0
                };
                let result = w0 + ratio * (w1 - w0);
                result.round().max(0.0).min(canvas_extent as f64) as usize
            } else {
                // Between two anchors — interpolate
                for i in 0..anchors.len() - 1 {
                    let (d0, w0) = anchors[i];
                    let (d1, w1) = anchors[i + 1];
                    if dagre_pos >= d0 && dagre_pos <= d1 {
                        let ratio = if (d1 - d0).abs() > f64::EPSILON {
                            (dagre_pos - d0) / (d1 - d0)
                        } else {
                            0.5
                        };
                        let result = w0 + ratio * (w1 - w0);
                        return result.round().max(0.0).min(canvas_extent as f64) as usize;
                    }
                }
                // Shouldn't reach here but fallback
                canvas_extent / 2
            }
        }
    }
}
```

## Context

- `result.nodes` is a `HashMap<dagre::NodeId, dagre::Rect>` from dagre layout output
- `draw_positions` is `HashMap<String, (usize, usize)>` — ASCII grid positions
- `node_dims` is `HashMap<String, (usize, usize)>` — node (width, height) in characters
- `layers` is `Vec<Vec<String>>` — nodes grouped by rank
- `is_vertical` is true for TD/BT layouts

The dagre coordinate space uses `node_sep=50, rank_sep=50` defaults. The draw coordinate space uses `h_spacing=4, v_spacing=3` defaults. The ratio between them is roughly 0.08-0.1 for the cross-axis.

## Acceptance Criteria

- [ ] `rank_cross_anchors` is correctly built with sorted (dagre, draw) pairs per rank
- [ ] `map_cross_axis()` handles: no anchors, single anchor, multiple anchors, extrapolation
- [ ] Existing `test_waypoint_transformation_vertical` and `test_waypoint_transformation_horizontal` still pass
- [ ] `cargo test` passes

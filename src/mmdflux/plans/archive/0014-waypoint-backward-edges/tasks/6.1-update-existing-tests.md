# Task 6.1: Update Existing Backward Edge Tests

## Objective

Update the existing backward edge tests in `router.rs` and `layout.rs` that assert corridor-based behavior, since corridor routing no longer exists.

## Location

Modify: `src/render/router.rs` (tests module) and `src/render/layout.rs` (tests module)

## Implementation

### Test 1: `test_route_backward_edge_td` (router.rs:1304)

The test creates a simple A→B→A cycle in TD direction. Previously asserted corridor routing (3 segments H-V-H, entry from Right). Now backward edges route via waypoints or direct routing.

For a 1-rank-span backward edge (B→A), there are no dummy nodes, so it uses `route_edge_direct()`. Update assertions:

```rust
#[test]
fn test_route_backward_edge_td() {
    let mut diagram = Diagram::new(Direction::TopDown);
    diagram.add_node(Node::new("A").with_label("Start"));
    diagram.add_node(Node::new("B").with_label("End"));
    diagram.add_edge(Edge::new("A", "B")); // Forward
    diagram.add_edge(Edge::new("B", "A")); // Backward

    let config = LayoutConfig::default();
    let layout = compute_layout_dagre(&diagram, &config);

    // Route the backward edge
    let backward_edge = &diagram.edges[1];
    let routed = route_edge(backward_edge, &layout, Direction::TopDown).unwrap();

    // Backward edge should have segments (routed through layout area, not corridor)
    assert!(!routed.segments.is_empty(), "Should have routing segments");

    // Entry direction should be computed from segment geometry
    // (no longer hardcoded to Right)
    // The exact direction depends on the path geometry
}
```

### Test 2: `test_route_backward_edge_lr` (router.rs:1343)

Same pattern — remove corridor assertions:

```rust
#[test]
fn test_route_backward_edge_lr() {
    let mut diagram = Diagram::new(Direction::LeftRight);
    diagram.add_node(Node::new("A").with_label("Start"));
    diagram.add_node(Node::new("B").with_label("End"));
    diagram.add_edge(Edge::new("A", "B"));
    diagram.add_edge(Edge::new("B", "A"));

    let config = LayoutConfig::default();
    let layout = compute_layout_dagre(&diagram, &config);

    let backward_edge = &diagram.edges[1];
    let routed = route_edge(backward_edge, &layout, Direction::LeftRight).unwrap();

    assert!(!routed.segments.is_empty(), "Should have routing segments");
}
```

### Test 3: `test_multiple_backward_edges_use_separate_lanes` (router.rs:1410)

This test verified that two backward edges used different corridor lanes. With waypoint routing, we instead verify that both edges are routed successfully. If they have waypoints, verify distinct paths:

```rust
#[test]
fn test_multiple_backward_edges_route_successfully() {
    let mut diagram = Diagram::new(Direction::TopDown);
    diagram.add_node(Node::new("A").with_label("Top"));
    diagram.add_node(Node::new("B").with_label("Middle"));
    diagram.add_node(Node::new("C").with_label("Bottom"));
    diagram.add_edge(Edge::new("A", "B")); // Forward
    diagram.add_edge(Edge::new("B", "C")); // Forward
    diagram.add_edge(Edge::new("C", "A")); // Backward to A (spans 2 ranks)
    diagram.add_edge(Edge::new("C", "B")); // Backward to B (spans 1 rank)

    let config = LayoutConfig::default();
    let layout = compute_layout_dagre(&diagram, &config);

    // Both backward edges should route successfully
    let edge_c_to_a = &diagram.edges[2];
    let edge_c_to_b = &diagram.edges[3];
    let routed_c_a = route_edge(edge_c_to_a, &layout, Direction::TopDown);
    let routed_c_b = route_edge(edge_c_to_b, &layout, Direction::TopDown);

    assert!(routed_c_a.is_some(), "C→A backward edge should route");
    assert!(routed_c_b.is_some(), "C→B backward edge should route");

    // C→A spans 2 ranks, should have waypoints
    let key_c_a = ("C".to_string(), "A".to_string());
    // (Waypoints may or may not exist depending on dagre's handling —
    // the key thing is that routing succeeds)
}
```

### Test 4: `test_compute_layout_dagre_handles_cycle` (layout.rs:1109)

Remove the `backward_corridors` assertion:

```rust
#[test]
fn test_compute_layout_dagre_handles_cycle() {
    let mut diagram = Diagram::new(Direction::TopDown);
    diagram.add_node(Node::new("A"));
    diagram.add_node(Node::new("B"));
    diagram.add_edge(Edge::new("A", "B"));
    diagram.add_edge(Edge::new("B", "A")); // Cycle!

    let config = LayoutConfig::default();
    let layout = compute_layout_dagre(&diagram, &config);

    // Should still produce a layout (cycle is handled)
    assert!(layout.draw_positions.contains_key("A"));
    assert!(layout.draw_positions.contains_key("B"));

    // REMOVED: assert_eq!(layout.backward_corridors, 1);
    // Canvas should NOT have corridor expansion
    // (width should be just enough for the nodes + spacing)
}
```

## Acceptance Criteria

- [ ] All four tests updated to remove corridor-specific assertions
- [ ] Tests verify routing succeeds without asserting corridor-specific segment patterns
- [ ] `cargo test` passes with updated tests

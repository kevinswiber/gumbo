# Task 2.1: Implement `compute_attachment_plan()`

## Objective

Add a pre-pass function that analyzes all edges, groups them by (node, face), and computes spread attachment points for multi-edge faces.

## Location

Modify: `src/render/router.rs`

## Implementation

Add imports:

```rust
use super::intersect::{NodeFace, classify_face, spread_points_on_face};
```

Add the override struct:

```rust
/// Pre-computed attachment override for one edge.
#[derive(Debug, Clone)]
pub struct AttachmentOverride {
    pub source: Option<(usize, usize)>,
    pub target: Option<(usize, usize)>,
}
```

Add the main function:

```rust
/// Compute pre-assigned attachment points for edges that share a node face.
///
/// Only produces overrides for faces with >1 edge. Single-edge faces
/// use the default intersect_rect() calculation (no override).
pub fn compute_attachment_plan(
    edges: &[Edge],
    layout: &Layout,
) -> HashMap<usize, AttachmentOverride> {
    // Step 1: Classify faces and build groups
    // Key: (node_id, face) -> Vec<(edge_index, is_source_side)>
    let mut face_groups: HashMap<(String, NodeFace), Vec<(usize, bool)>> = HashMap::new();

    for (i, edge) in edges.iter().enumerate() {
        let src_bounds = match layout.get_bounds(&edge.from) {
            Some(b) => b,
            None => continue,
        };
        let tgt_bounds = match layout.get_bounds(&edge.to) {
            Some(b) => b,
            None => continue,
        };

        let src_shape = layout.node_shapes.get(&edge.from).copied()
            .unwrap_or(Shape::Rectangle);
        let tgt_shape = layout.node_shapes.get(&edge.to).copied()
            .unwrap_or(Shape::Rectangle);

        // Determine approach points using waypoints if available
        let edge_key = (edge.from.clone(), edge.to.clone());
        let waypoints = layout.edge_waypoints.get(&edge_key);

        // For source: approach point is first waypoint or target center
        let src_approach = waypoints
            .and_then(|wps| wps.first().copied())
            .unwrap_or((tgt_bounds.center_x(), tgt_bounds.center_y()));

        // For target: approach point is last waypoint or source center
        let tgt_approach = waypoints
            .and_then(|wps| wps.last().copied())
            .unwrap_or((src_bounds.center_x(), src_bounds.center_y()));

        let src_face = classify_face(src_bounds, src_approach, src_shape);
        let tgt_face = classify_face(tgt_bounds, tgt_approach, tgt_shape);

        face_groups.entry((edge.from.clone(), src_face))
            .or_default()
            .push((i, true));
        face_groups.entry((edge.to.clone(), tgt_face))
            .or_default()
            .push((i, false));
    }

    // Step 2: For faces with >1 edge, compute spread positions
    let mut overrides: HashMap<usize, AttachmentOverride> = HashMap::new();

    for ((node_id, face), group) in &face_groups {
        if group.len() <= 1 {
            continue;
        }

        let bounds = match layout.get_bounds(node_id) {
            Some(b) => b,
            None => continue,
        };

        // Sort edges by cross-axis position of opposite endpoint (Task 2.2)
        let mut sorted = group.clone();
        sort_face_group(&mut sorted, edges, layout, *face);

        let extent = bounds.face_extent(&face);
        let fixed = bounds.face_fixed_coord(&face);
        let points = spread_points_on_face(*face, fixed, extent, sorted.len());

        for (idx, &(edge_i, is_source)) in sorted.iter().enumerate() {
            let point = points[idx];
            let entry = overrides.entry(edge_i).or_insert(AttachmentOverride {
                source: None,
                target: None,
            });
            if is_source {
                entry.source = Some(point);
            } else {
                entry.target = Some(point);
            }
        }
    }

    overrides
}
```

## Context

- **`edge_waypoints` key:** The layout stores waypoints keyed by `(String, String)` tuple of `(edge.from, edge.to)`, NOT by edge index. This was an error in the old plan 0015.
- **`layout.get_bounds()`:** Check what method name is used — it may be `layout.node_bounds.get()` directly. Adapt the lookup accordingly.
- **Approach point logic:** For the source side, the "approach point" is where the edge heads toward after leaving the source — the first waypoint or the target center. For the target side, the approach point is where the edge comes from — the last waypoint or the source center.
- **Single-edge faces are skipped** (the `group.len() <= 1` guard). These use the existing `calculate_attachment_points()` path, preserving current behavior exactly.
- Imports needed: `HashMap` (likely already imported), `Edge`, `Layout`, `Shape`, `Direction`.

## Acceptance Criteria

- [ ] Groups edges correctly by (node_id, face)
- [ ] Only produces overrides for faces with >1 edge
- [ ] Uses waypoints when available, falls back to opposite node center
- [ ] Produces distinct attachment points for each edge on a shared face
- [ ] Handles edges that have both source and target overrides (edge between two multi-edge faces)

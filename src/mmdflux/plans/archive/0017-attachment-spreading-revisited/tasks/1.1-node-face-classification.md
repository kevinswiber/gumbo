# Task 1.1: Add `NodeFace` Enum and `classify_face()`

## Objective

Add infrastructure to classify which face of a node (top, bottom, left, right) an edge attaches to, based on the approach direction.

## Location

Modify: `src/render/intersect.rs`

## Implementation

Add at the top of the file (after existing imports):

```rust
/// Which face of a node an edge attaches to.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum NodeFace {
    Top,
    Bottom,
    Left,
    Right,
}
```

Add the classification function:

```rust
/// Classify which face of a node a line from `approach_point` to the node center
/// would intersect. Uses the same slope-vs-diagonal comparison as `intersect_rect`.
///
/// Since rendered diamonds have rectangular boundaries (angle brackets on middle row),
/// the same slope logic works for all shapes.
pub fn classify_face(
    bounds: &NodeBounds,
    approach_point: (usize, usize),
    _shape: Shape,
) -> NodeFace {
    let cx = bounds.center_x() as f64;
    let cy = bounds.center_y() as f64;
    let dx = approach_point.0 as f64 - cx;
    let dy = approach_point.1 as f64 - cy;

    if dx.abs() < 0.5 && dy.abs() < 0.5 {
        return NodeFace::Bottom; // default when approach == center
    }

    let half_w = bounds.width as f64 / 2.0;
    let half_h = bounds.height as f64 / 2.0;

    // Same comparison as intersect_rect: steep => top/bottom, shallow => left/right
    if dy.abs() * half_w > dx.abs() * half_h {
        if dy < 0.0 { NodeFace::Top } else { NodeFace::Bottom }
    } else {
        if dx < 0.0 { NodeFace::Left } else { NodeFace::Right }
    }
}
```

## Context

- The `_shape` parameter is accepted for API consistency but the logic is shape-independent. Rendered diamonds have rectangular boundaries (see `src/render/shape.rs` lines 158–187), so top/bottom faces are flat horizontal edges just like rectangles.
- The slope comparison mirrors `intersect_rect()` logic: `|dy| * half_w > |dx| * half_h` means the approach is steeper than the diagonal, hitting top or bottom.
- The degenerate case (approach == center) defaults to `Bottom`, matching the convention for downward-flowing (TD) diagrams.
- Requires `use super::shape::NodeBounds;` and `use crate::graph::node::Shape;` (likely already imported).

## Acceptance Criteria

- [ ] `NodeFace` enum with `Top`, `Bottom`, `Left`, `Right` variants, deriving `Debug, Clone, Copy, PartialEq, Eq, Hash`
- [ ] `classify_face()` correctly classifies approach points in all four quadrants
- [ ] Degenerate case (approach == center) returns `Bottom`
- [ ] Unit tests: point above node → `Top`, below → `Bottom`, left → `Left`, right → `Right`

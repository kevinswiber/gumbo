# Task 2.2: Sort Edges Within Face Groups

## Objective

Sort edges within a face group by cross-axis position of the opposite endpoint, to minimize visual crossings when attachment points are spread across the face.

## Location

Modify: `src/render/router.rs` (called from `compute_attachment_plan()` in task 2.1)

## Implementation

```rust
/// Sort edges within a face group by cross-axis position of the opposite endpoint.
/// This minimizes visual crossings by matching left-to-right edge order to
/// left-to-right source/target order.
fn sort_face_group(
    group: &mut Vec<(usize, bool)>,
    edges: &[Edge],
    layout: &Layout,
    face: NodeFace,
) {
    group.sort_by_key(|&(edge_i, is_source)| {
        let edge = &edges[edge_i];
        let other_id = if is_source { &edge.to } else { &edge.from };
        let other_bounds = layout.get_bounds(other_id);

        match face {
            // For top/bottom faces, sort by x-position of opposite endpoint
            NodeFace::Top | NodeFace::Bottom => {
                other_bounds.map(|b| b.center_x()).unwrap_or(0)
            }
            // For left/right faces, sort by y-position of opposite endpoint
            NodeFace::Left | NodeFace::Right => {
                other_bounds.map(|b| b.center_y()).unwrap_or(0)
            }
        }
    });
}
```

## Context

- For `fan_in.mmd` (3 sources A, B, C converging on Target's top face): sorting by `center_x` of the sources assigns the leftmost source to the leftmost attachment point, naturally avoiding crossings.
- For `fan_out.mmd` (Source departing to 3 targets): sorting by `center_x` of the targets assigns the leftmost target to the leftmost departure point.
- For `double_skip.mmd` (direct C→D and skip A→D on D's top face): sorting by source `center_x` puts A's edge left of C's edge (since A is laid out left of C by dagre), matching the visual arrangement.
- The `is_source` flag determines which end is the "opposite" — if this edge entry is for the source side of the node, the opposite endpoint is the target (and vice versa).
- `unwrap_or(0)` handles the unlikely case of a missing node in the layout.

## Acceptance Criteria

- [ ] Sorts by x-coordinate of opposite endpoint for Top/Bottom faces
- [ ] Sorts by y-coordinate of opposite endpoint for Left/Right faces
- [ ] Correctly identifies "opposite" endpoint based on `is_source` flag
- [ ] Handles missing bounds gracefully (sorts to position 0)

# Task 3.1-3.3: Implement horizontal compaction

## Objective

Implement the horizontal compaction phase that assigns x-coordinates to blocks while respecting separation constraints.

## Background

After vertical alignment, we have blocks of nodes. Compaction assigns x-coordinates such that:
1. Nodes in the same block have the same x-coordinate
2. Adjacent nodes in the same layer have at least `node_sep` separation
3. The layout is as compact as possible

## Implementation

```rust
/// Compute x-coordinates for a single alignment using horizontal compaction
pub fn horizontal_compaction(
    graph: &LayoutGraph,
    alignment: &BlockAlignment,
    config: &BKConfig,
) -> CompactionResult {
    let mut result = CompactionResult::new();

    // Initialize sink and shift for each node
    for node in 0..graph.positions.len() {
        result.sink.insert(node, node);
        result.shift.insert(node, f64::INFINITY);
    }

    // First pass: Calculate relative positions within blocks
    // and between adjacent blocks
    let roots = alignment.get_all_roots();

    // Process blocks in topological order (by layer of root)
    let mut sorted_roots = roots.clone();
    sorted_roots.sort_by_key(|&r| get_layer(graph, r));

    // Place each block
    for &root in &sorted_roots {
        if result.x.get(&root).is_none() {
            place_block(graph, alignment, &mut result, root, config);
        }
    }

    // Second pass: Absolute coordinates
    // Compute minimum coordinates and shift
    let mut min_x = f64::INFINITY;
    for &root in &roots {
        if let Some(&x) = result.x.get(&root) {
            min_x = min_x.min(x);
        }
    }

    // Normalize: shift so minimum x is at margin
    let shift_amount = config.node_sep - min_x;
    for node in 0..graph.positions.len() {
        let root = alignment.get_root(node);
        if let Some(&root_x) = result.x.get(&root) {
            result.x.insert(node, root_x + shift_amount);
        }
    }

    result
}

/// Place a single block (recursive)
fn place_block(
    graph: &LayoutGraph,
    alignment: &BlockAlignment,
    result: &mut CompactionResult,
    root: NodeId,
    config: &BKConfig,
) {
    if result.x.contains_key(&root) {
        return;  // Already placed
    }

    // Initialize x at 0
    result.x.insert(root, 0.0);

    // Process all nodes in this block
    let block_nodes: Vec<NodeId> = alignment.block_iter(root).collect();

    for &node in &block_nodes {
        let layer = get_layer(graph, node);
        let layer_nodes = get_layer_nodes(graph, layer);
        let pos = get_position(graph, node);

        // Find left neighbor in same layer
        if pos > 0 {
            let left_neighbor = layer_nodes[pos - 1];
            let left_root = alignment.get_root(left_neighbor);

            // Place left neighbor's block first (if not already placed)
            if left_root != root {
                place_block(graph, alignment, result, left_root, config);

                // Compute required separation
                let node_width = get_width(graph, node);
                let left_width = get_width(graph, left_neighbor);
                let separation = (left_width + node_width) / 2.0 + config.node_sep;

                // Update our position if needed
                if let Some(&left_x) = result.x.get(&left_root) {
                    let min_x = left_x + separation;
                    let current_x = result.x.get(&root).copied().unwrap_or(0.0);

                    if min_x > current_x {
                        result.x.insert(root, min_x);
                    }
                }
            }
        }
    }
}

/// Calculate the total width of a compaction result
fn calculate_width(graph: &LayoutGraph, result: &CompactionResult) -> f64 {
    let mut min_x = f64::INFINITY;
    let mut max_x = f64::NEG_INFINITY;

    for node in 0..graph.positions.len() {
        if let Some(&x) = result.x.get(&node) {
            let width = get_width(graph, node);
            min_x = min_x.min(x - width / 2.0);
            max_x = max_x.max(x + width / 2.0);
        }
    }

    if max_x > min_x {
        max_x - min_x
    } else {
        0.0
    }
}

#[cfg(test)]
mod compaction_tests {
    use super::*;

    #[test]
    fn test_single_block_compaction() {
        // Single block of 3 nodes in a chain
        let graph = make_chain_graph(3);
        let mut alignment = BlockAlignment::new(&[0, 1, 2]);
        alignment.align_below(1, 0);
        alignment.align_below(2, 1);

        let config = BKConfig::default();
        let result = horizontal_compaction(&graph, &alignment, &config);

        // All nodes should have the same x
        let x0 = result.x.get(&0).unwrap();
        let x1 = result.x.get(&1).unwrap();
        let x2 = result.x.get(&2).unwrap();

        assert_eq!(x0, x1);
        assert_eq!(x1, x2);
    }

    #[test]
    fn test_adjacent_blocks_separation() {
        // Two blocks side by side in same layer
        // Layer 0: [A] [B]
        // A and B should have at least node_sep between them
        let graph = make_two_node_layer_graph();
        let alignment = BlockAlignment::new(&[0, 1]);  // Separate blocks

        let config = BKConfig { node_sep: 50.0, ..Default::default() };
        let result = horizontal_compaction(&graph, &alignment, &config);

        let x0 = result.x.get(&0).unwrap();
        let x1 = result.x.get(&1).unwrap();

        // Should be separated by at least node_sep
        let separation = (x1 - x0).abs();
        assert!(separation >= config.node_sep, "Separation {} < {}", separation, config.node_sep);
    }

    #[test]
    fn test_width_calculation() {
        let graph = make_test_graph();
        let alignment = BlockAlignment::new(&(0..5).collect::<Vec<_>>());

        let config = BKConfig::default();
        let result = horizontal_compaction(&graph, &alignment, &config);

        let width = calculate_width(&graph, &result);
        assert!(width > 0.0);
    }
}
```

## Algorithm Notes

The compaction algorithm from Brandes-KÃ¶pf:

1. **Sink and shift**: Track class representatives and shifts for coordinate merging
2. **Place blocks left-to-right**: Each block is placed as far left as possible given constraints
3. **Separation constraints**: Adjacent nodes in same layer must be separated

## Acceptance Criteria

- [ ] `horizontal_compaction()` assigns x-coordinates to all nodes
- [ ] Nodes in same block have same x-coordinate
- [ ] Adjacent nodes in same layer have required separation
- [ ] `place_block()` handles recursive block placement
- [ ] `calculate_width()` computes total layout width
- [ ] Layout is compact (no unnecessary space)
- [ ] Unit tests pass

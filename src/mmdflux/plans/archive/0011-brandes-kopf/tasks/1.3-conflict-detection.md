# Task 1.3: Implement conflict detection (Type-1 and Type-2)

## Objective

Implement the conflict detection phase of Brandes-Köpf. Conflicts prevent certain node alignments and must be detected before computing alignments.

## Background

### Type-1 Conflicts

Occur when a non-inner segment crosses an inner segment between layers.

**Inner segment:** An edge between two dummy nodes (part of a long edge chain)
**Non-inner segment:** Any edge that isn't between two dummy nodes

```
Layer k:     [A]---[dummy1]---[B]
              |                 \
Layer k+1:   [C]---[dummy2]---[D]
```

If edge A→D crosses the inner segment dummy1→dummy2, it's a Type-1 conflict.

### Type-2 Conflicts

Occur between inner segments of different long edges when they would cross if aligned.

```
Layer k:     [d1]......[d2]
               \      /
Layer k+1:     [d3]  [d4]
```

If the inner segments d1→d3 and d2→d4 cross, it's a Type-2 conflict.

## Implementation

```rust
/// Find all Type-1 conflicts in the graph
///
/// A Type-1 conflict occurs when a non-inner segment crosses an inner segment.
/// Inner segments are edges between dummy nodes (part of long edge normalization).
pub fn find_type1_conflicts(graph: &LayoutGraph) -> ConflictSet {
    let mut conflicts = ConflictSet::new();
    let max_layer = graph.ranks.iter().copied().max().unwrap_or(0) as usize;

    // For each pair of adjacent layers
    for layer in 0..max_layer {
        let upper = get_layer_nodes(graph, layer);
        let lower = get_layer_nodes(graph, layer + 1);

        // Find inner segments in this layer pair
        let inner_segments = find_inner_segments(graph, &upper, &lower);

        // For each non-inner segment, check if it crosses any inner segment
        for edge in &graph.edges {
            let from_layer = get_layer(graph, edge.from);
            let to_layer = get_layer(graph, edge.to);

            // Skip if not in this layer pair
            if from_layer != layer || to_layer != layer + 1 {
                continue;
            }

            // Skip if this is an inner segment
            if is_inner_segment(graph, edge.from, edge.to) {
                continue;
            }

            // Check for crossings with inner segments
            let from_pos = get_position(graph, edge.from);
            let to_pos = get_position(graph, edge.to);

            for inner in &inner_segments {
                if segments_cross(from_pos, to_pos, inner.0, inner.1) {
                    conflicts.entry(layer).or_default().push(Conflict {
                        layer,
                        pos1: from_pos.min(inner.0),
                        pos2: from_pos.max(inner.0),
                    });
                }
            }
        }
    }

    conflicts
}

/// Find all Type-2 conflicts in the graph
///
/// A Type-2 conflict occurs between inner segments of different long edges.
pub fn find_type2_conflicts(graph: &LayoutGraph) -> ConflictSet {
    let mut conflicts = ConflictSet::new();
    let max_layer = graph.ranks.iter().copied().max().unwrap_or(0) as usize;

    // For each pair of adjacent layers
    for layer in 0..max_layer {
        let upper = get_layer_nodes(graph, layer);
        let lower = get_layer_nodes(graph, layer + 1);

        // Find all inner segments
        let inner_segments = find_inner_segments(graph, &upper, &lower);

        // Check each pair of inner segments for crossing
        for i in 0..inner_segments.len() {
            for j in (i + 1)..inner_segments.len() {
                let (u1, l1) = inner_segments[i];
                let (u2, l2) = inner_segments[j];

                if segments_cross(u1, l1, u2, l2) {
                    conflicts.entry(layer).or_default().push(Conflict {
                        layer,
                        pos1: u1.min(u2),
                        pos2: u1.max(u2),
                    });
                }
            }
        }
    }

    conflicts
}

/// Merge Type-1 and Type-2 conflicts
pub fn find_all_conflicts(graph: &LayoutGraph) -> ConflictSet {
    let mut conflicts = find_type1_conflicts(graph);

    for (layer, type2_conflicts) in find_type2_conflicts(graph) {
        conflicts.entry(layer).or_default().extend(type2_conflicts);
    }

    conflicts
}

/// Find inner segments (edges between dummy nodes) in a layer pair
fn find_inner_segments(
    graph: &LayoutGraph,
    upper: &[NodeId],
    lower: &[NodeId],
) -> Vec<(usize, usize)> {
    let mut segments = Vec::new();

    for edge in &graph.edges {
        let from_layer = get_layer(graph, edge.from);
        let to_layer = get_layer(graph, edge.to);

        // Check if edge is in this layer pair
        if !((from_layer == get_layer(graph, upper[0]) && to_layer == get_layer(graph, lower[0]))) {
            continue;
        }

        // Check if both endpoints are dummy nodes
        if is_dummy(graph, edge.from) && is_dummy(graph, edge.to) {
            let from_pos = get_position(graph, edge.from);
            let to_pos = get_position(graph, edge.to);
            segments.push((from_pos, to_pos));
        }
    }

    segments
}

/// Check if an edge is an inner segment (both endpoints are dummy nodes)
fn is_inner_segment(graph: &LayoutGraph, from: NodeId, to: NodeId) -> bool {
    is_dummy(graph, from) && is_dummy(graph, to)
}

/// Check if two segments cross
/// Segments are defined by (upper_pos, lower_pos)
fn segments_cross(u1: usize, l1: usize, u2: usize, l2: usize) -> bool {
    // Segments cross if:
    // - One starts left and ends right of the other, or vice versa
    (u1 < u2 && l1 > l2) || (u1 > u2 && l1 < l2)
}

/// Check if aligning nodes would violate a conflict
pub fn has_conflict(
    conflicts: &ConflictSet,
    layer: usize,
    pos1: usize,
    pos2: usize,
) -> bool {
    if let Some(layer_conflicts) = conflicts.get(&layer) {
        for conflict in layer_conflicts {
            // Check if positions fall within the conflict range
            let min_pos = pos1.min(pos2);
            let max_pos = pos1.max(pos2);

            if min_pos <= conflict.pos1 && conflict.pos2 <= max_pos {
                return true;
            }
        }
    }
    false
}

#[cfg(test)]
mod conflict_tests {
    use super::*;

    #[test]
    fn test_segments_cross_yes() {
        // Segment 1: upper=0, lower=2
        // Segment 2: upper=1, lower=0
        // These cross
        assert!(segments_cross(0, 2, 1, 0));
    }

    #[test]
    fn test_segments_cross_no() {
        // Segment 1: upper=0, lower=0
        // Segment 2: upper=1, lower=1
        // These don't cross (parallel)
        assert!(!segments_cross(0, 0, 1, 1));
    }

    #[test]
    fn test_segments_cross_same_start() {
        // Segment 1: upper=0, lower=1
        // Segment 2: upper=0, lower=2
        // Same start, don't cross
        assert!(!segments_cross(0, 1, 0, 2));
    }

    #[test]
    fn test_find_type1_conflicts() {
        // Create graph with known Type-1 conflict
        // ... test implementation ...
    }

    #[test]
    fn test_find_type2_conflicts() {
        // Create graph with known Type-2 conflict
        // ... test implementation ...
    }
}
```

## Algorithm Reference

From Brandes & Köpf paper:
- Type-1: "A type 1 conflict occurs when a non-inner segment crosses an inner segment"
- Type-2: "Type 2 conflicts involve two inner segments"

The paper's preprocessing marks these conflicts to prevent invalid alignments.

## Acceptance Criteria

- [ ] `segments_cross()` correctly detects crossing segments
- [ ] `find_inner_segments()` identifies edges between dummy nodes
- [ ] `find_type1_conflicts()` detects non-inner crossing inner
- [ ] `find_type2_conflicts()` detects inner crossing inner
- [ ] `has_conflict()` can check if alignment violates conflict
- [ ] Unit tests cover crossing and non-crossing cases
- [ ] Works with actual LayoutGraph from normalize phase

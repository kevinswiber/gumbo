# Task 1.2: Add helper functions for layer/neighbor traversal

## Objective

Add utility functions for traversing the layered graph structure, finding neighbors, and accessing layer information.

## Location

`src/dagre/bk.rs` - add after data structures

## Implementation

```rust
/// Helper functions for accessing the layered graph structure
impl LayoutGraph {
    // Note: These may already exist in graph.rs. If so, use those.
    // Otherwise, add these helpers.
}

/// Get the layer (rank) of a node
fn get_layer(graph: &LayoutGraph, node: NodeId) -> usize {
    graph.ranks[node] as usize
}

/// Get the position (order) of a node within its layer
fn get_position(graph: &LayoutGraph, node: NodeId) -> usize {
    graph.order[node]
}

/// Get all nodes in a specific layer, sorted by position
fn get_layer_nodes(graph: &LayoutGraph, layer: usize) -> Vec<NodeId> {
    let mut nodes: Vec<NodeId> = graph.node_index.values()
        .copied()
        .filter(|&node| graph.ranks[node] as usize == layer)
        .collect();

    nodes.sort_by_key(|&node| graph.order[node]);
    nodes
}

/// Get the layers in sweep order (top-to-bottom or bottom-to-top)
fn get_layers_in_order(graph: &LayoutGraph, downward: bool) -> Vec<usize> {
    let max_rank = graph.ranks.iter().copied().max().unwrap_or(0) as usize;

    if downward {
        (0..=max_rank).collect()
    } else {
        (0..=max_rank).rev().collect()
    }
}

/// Get predecessors of a node (nodes in the layer above that connect to this node)
fn get_predecessors(graph: &LayoutGraph, node: NodeId) -> Vec<NodeId> {
    graph.edges.iter()
        .filter(|e| e.to == node)
        .map(|e| e.from)
        .collect()
}

/// Get successors of a node (nodes in the layer below that this node connects to)
fn get_successors(graph: &LayoutGraph, node: NodeId) -> Vec<NodeId> {
    graph.edges.iter()
        .filter(|e| e.from == node)
        .map(|e| e.to)
        .collect()
}

/// Get neighbors based on sweep direction
/// - Downward sweep: use predecessors (upper neighbors)
/// - Upward sweep: use successors (lower neighbors)
fn get_neighbors(graph: &LayoutGraph, node: NodeId, downward: bool) -> Vec<NodeId> {
    let neighbors = if downward {
        get_predecessors(graph, node)
    } else {
        get_successors(graph, node)
    };

    // Sort by position in their layer
    let mut neighbors = neighbors;
    neighbors.sort_by_key(|&n| graph.order[n]);
    neighbors
}

/// Get the median neighbor of a node
/// Returns the middle neighbor (or left-middle if even count and prefer_left)
fn get_median_neighbor(
    graph: &LayoutGraph,
    node: NodeId,
    downward: bool,
    prefer_left: bool,
) -> Option<NodeId> {
    let neighbors = get_neighbors(graph, node, downward);

    if neighbors.is_empty() {
        return None;
    }

    let len = neighbors.len();
    if len == 1 {
        return Some(neighbors[0]);
    }

    // For even length, choose based on preference
    let median_idx = if len % 2 == 0 {
        if prefer_left {
            len / 2 - 1  // Left-middle
        } else {
            len / 2      // Right-middle
        }
    } else {
        len / 2  // True middle for odd length
    };

    Some(neighbors[median_idx])
}

/// Check if a node is a dummy node (from edge normalization)
fn is_dummy(graph: &LayoutGraph, node: NodeId) -> bool {
    if let Some(node_id) = graph.node_index.iter()
        .find(|(_, &idx)| idx == node)
        .map(|(id, _)| id)
    {
        graph.dummy_nodes.contains_key(node_id)
    } else {
        false
    }
}

/// Get the width of a node
fn get_width(graph: &LayoutGraph, node: NodeId) -> f64 {
    graph.dimensions[node].0
}

/// Get node center x coordinate (before BK adjustment)
fn get_initial_x(graph: &LayoutGraph, node: NodeId) -> f64 {
    graph.positions[node].x + graph.dimensions[node].0 / 2.0
}

#[cfg(test)]
mod helper_tests {
    use super::*;

    fn make_test_graph() -> LayoutGraph {
        // Create a simple 3-layer graph:
        // Layer 0: [A]
        // Layer 1: [B, C]
        // Layer 2: [D]
        // Edges: A->B, A->C, B->D, C->D

        // ... construct test graph ...
        todo!("Create test graph fixture")
    }

    #[test]
    fn test_get_layer_nodes() {
        let graph = make_test_graph();
        let layer1 = get_layer_nodes(&graph, 1);
        assert_eq!(layer1.len(), 2);
    }

    #[test]
    fn test_get_median_neighbor_single() {
        let graph = make_test_graph();
        // Node with single predecessor
        let median = get_median_neighbor(&graph, /* node D */, true, true);
        assert!(median.is_some());
    }

    #[test]
    fn test_get_median_neighbor_even_prefer_left() {
        let graph = make_test_graph();
        // D has two predecessors [B, C]
        // prefer_left=true should return B
        let median = get_median_neighbor(&graph, /* node D */, true, true);
        // assert_eq!(median, Some(node_b));
    }

    #[test]
    fn test_get_median_neighbor_even_prefer_right() {
        let graph = make_test_graph();
        // D has two predecessors [B, C]
        // prefer_left=false should return C
        let median = get_median_neighbor(&graph, /* node D */, true, false);
        // assert_eq!(median, Some(node_c));
    }
}
```

## Integration with LayoutGraph

Check `src/dagre/graph.rs` for existing methods. If these methods exist, use them instead of reimplementing:

- `get_rank(node)` or access via `graph.ranks[node]`
- `get_order(node)` or access via `graph.order[node]`
- `predecessors(node)` / `successors(node)`
- `is_dummy(node)`
- `get_dimensions(node)`

## Acceptance Criteria

- [ ] `get_layer_nodes()` returns nodes sorted by position
- [ ] `get_layers_in_order()` handles both directions
- [ ] `get_neighbors()` returns correct predecessors/successors
- [ ] `get_median_neighbor()` handles odd/even counts correctly
- [ ] `get_median_neighbor()` respects `prefer_left` for even counts
- [ ] `is_dummy()` correctly identifies dummy nodes
- [ ] Helper functions have unit tests
- [ ] Functions integrate with existing LayoutGraph structure

# Task 1.1: Create src/dagre/bk.rs module with data structures

## Objective

Create the new Brandes-Kopf module with all necessary data structures for the algorithm.

## Location

New file: `src/dagre/bk.rs`

## Implementation

```rust
//! Brandes-Köpf algorithm for horizontal coordinate assignment.
//!
//! This module implements the algorithm described in:
//! Brandes, U. and Köpf, B. (2001). Fast and Simple Horizontal Coordinate Assignment.
//!
//! The algorithm produces x-coordinates that minimize total edge length while
//! respecting node separation constraints.

use std::collections::{HashMap, HashSet};
use super::graph::LayoutGraph;
use super::types::Direction;

/// Index type for nodes in the layout graph
pub type NodeId = usize;

/// A conflict between edges that prevents alignment
#[derive(Debug, Clone)]
pub struct Conflict {
    /// The layer where the conflict occurs
    pub layer: usize,
    /// Position of first conflicting node in layer
    pub pos1: usize,
    /// Position of second conflicting node in layer
    pub pos2: usize,
}

/// Set of conflicts indexed by layer
pub type ConflictSet = HashMap<usize, Vec<Conflict>>;

/// Represents a vertical alignment of nodes into blocks
#[derive(Debug, Clone)]
pub struct BlockAlignment {
    /// Maps each node to its block root (representative node)
    pub root: HashMap<NodeId, NodeId>,

    /// Maps each node to the next node in its alignment chain
    /// Forms a linked list within each block
    pub align: HashMap<NodeId, NodeId>,
}

impl BlockAlignment {
    pub fn new(nodes: &[NodeId]) -> Self {
        let mut root = HashMap::new();
        let mut align = HashMap::new();

        // Initially, each node is its own root and aligns to itself
        for &node in nodes {
            root.insert(node, node);
            align.insert(node, node);
        }

        Self { root, align }
    }

    /// Get the root of the block containing `node`
    pub fn get_root(&self, node: NodeId) -> NodeId {
        self.root.get(&node).copied().unwrap_or(node)
    }

    /// Align node `v` with node `w` (v aligns down to w, or up depending on direction)
    pub fn align_nodes(&mut self, v: NodeId, w: NodeId) {
        // Set alignment: v points to w
        self.align.insert(v, w);
        // Set root: v's root becomes w's root
        let w_root = self.get_root(w);
        self.root.insert(v, w_root);
    }
}

/// Result of horizontal compaction for one alignment
#[derive(Debug, Clone)]
pub struct CompactionResult {
    /// X coordinate for each node
    pub x: HashMap<NodeId, f64>,

    /// Sink (class representative) for each node
    pub sink: HashMap<NodeId, NodeId>,

    /// Shift amount for each class
    pub shift: HashMap<NodeId, f64>,
}

impl CompactionResult {
    pub fn new() -> Self {
        Self {
            x: HashMap::new(),
            sink: HashMap::new(),
            shift: HashMap::new(),
        }
    }
}

/// The four alignment directions
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum AlignmentDirection {
    /// Up-Left: sweep top-to-bottom, prefer left neighbors
    UL,
    /// Up-Right: sweep top-to-bottom, prefer right neighbors
    UR,
    /// Down-Left: sweep bottom-to-top, prefer left neighbors
    DL,
    /// Down-Right: sweep bottom-to-top, prefer right neighbors
    DR,
}

impl AlignmentDirection {
    /// Returns all four alignment directions
    pub fn all() -> [Self; 4] {
        [Self::UL, Self::UR, Self::DL, Self::DR]
    }

    /// Whether this direction sweeps from top to bottom
    pub fn is_downward(&self) -> bool {
        matches!(self, Self::UL | Self::UR)
    }

    /// Whether this direction prefers left neighbors
    pub fn prefers_left(&self) -> bool {
        matches!(self, Self::UL | Self::DL)
    }
}

/// Configuration for the Brandes-Köpf algorithm
#[derive(Debug, Clone)]
pub struct BKConfig {
    /// Minimum separation between adjacent nodes
    pub node_sep: f64,

    /// Layout direction (affects which axis is "horizontal")
    pub direction: Direction,
}

impl Default for BKConfig {
    fn default() -> Self {
        Self {
            node_sep: 50.0,
            direction: Direction::TopBottom,
        }
    }
}

/// Main entry point for Brandes-Köpf coordinate assignment
pub fn position_x(graph: &LayoutGraph, config: &BKConfig) -> HashMap<NodeId, f64> {
    // TODO: Implement in subsequent tasks
    // 1. Find conflicts
    // 2. Compute 4 alignments
    // 3. Compact each alignment
    // 4. Balance and return

    HashMap::new()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_block_alignment_new() {
        let nodes = vec![0, 1, 2, 3];
        let alignment = BlockAlignment::new(&nodes);

        // Each node should be its own root
        for &node in &nodes {
            assert_eq!(alignment.get_root(node), node);
        }
    }

    #[test]
    fn test_block_alignment_align_nodes() {
        let nodes = vec![0, 1, 2];
        let mut alignment = BlockAlignment::new(&nodes);

        // Align 0 with 1
        alignment.align_nodes(0, 1);
        assert_eq!(alignment.get_root(0), 1);
        assert_eq!(alignment.align.get(&0), Some(&1));

        // Align 2 with 1 (same block)
        alignment.align_nodes(2, 1);
        assert_eq!(alignment.get_root(2), 1);
    }

    #[test]
    fn test_alignment_direction_properties() {
        assert!(AlignmentDirection::UL.is_downward());
        assert!(AlignmentDirection::UR.is_downward());
        assert!(!AlignmentDirection::DL.is_downward());
        assert!(!AlignmentDirection::DR.is_downward());

        assert!(AlignmentDirection::UL.prefers_left());
        assert!(!AlignmentDirection::UR.prefers_left());
        assert!(AlignmentDirection::DL.prefers_left());
        assert!(!AlignmentDirection::DR.prefers_left());
    }
}
```

## Module Export

In `src/dagre/mod.rs`, add:

```rust
mod bk;
pub use bk::{position_x as bk_position_x, BKConfig};
```

## Acceptance Criteria

- [ ] `src/dagre/bk.rs` created with all data structures
- [ ] `Conflict` struct defined
- [ ] `BlockAlignment` struct with `new()`, `get_root()`, `align_nodes()`
- [ ] `CompactionResult` struct defined
- [ ] `AlignmentDirection` enum with all 4 directions
- [ ] `BKConfig` struct with defaults
- [ ] `position_x()` stub function
- [ ] Unit tests for data structures pass
- [ ] Module exported from `mod.rs`

# Task 2.2: Add block chain management (root, align pointers)

## Objective

Ensure the block chain data structures correctly track alignments and can be traversed for compaction.

## Background

A **block** is a set of vertically aligned nodes. Blocks are represented by:
- `root[v]`: The representative node of v's block
- `align[v]`: The next node in v's alignment chain

```
Block structure example:
  root[A] = A, align[A] = B
  root[B] = A, align[B] = C
  root[C] = A, align[C] = A  (cycles back to root)
```

This forms a circular linked list: A → B → C → A

## Implementation

```rust
impl BlockAlignment {
    /// Create a new alignment where each node is its own block
    pub fn new(nodes: &[NodeId]) -> Self {
        let mut root = HashMap::new();
        let mut align = HashMap::new();

        for &node in nodes {
            root.insert(node, node);
            align.insert(node, node);  // Points to self (single-node block)
        }

        Self { root, align }
    }

    /// Get the root of the block containing `node`
    pub fn get_root(&self, node: NodeId) -> NodeId {
        self.root.get(&node).copied().unwrap_or(node)
    }

    /// Align node `v` below node `w` in w's block
    /// After this: v is in the same block as w, with w's root
    pub fn align_below(&mut self, v: NodeId, w: NodeId) {
        // Get w's root
        let w_root = self.get_root(w);

        // v points to what w was pointing to
        let w_next = self.align.get(&w).copied().unwrap_or(w);
        self.align.insert(v, w_next);

        // w now points to v
        self.align.insert(w, v);

        // v's root is w's root
        self.root.insert(v, w_root);
    }

    /// Iterate through all nodes in a block starting from root
    pub fn block_iter(&self, root: NodeId) -> BlockIterator {
        BlockIterator {
            alignment: self,
            current: Some(root),
            start: root,
            first: true,
        }
    }

    /// Get all nodes in the block containing `node`
    pub fn get_block_nodes(&self, node: NodeId) -> Vec<NodeId> {
        let root = self.get_root(node);
        self.block_iter(root).collect()
    }

    /// Get all unique block roots
    pub fn get_all_roots(&self) -> Vec<NodeId> {
        let mut roots: Vec<NodeId> = self.root.values().copied().collect();
        roots.sort();
        roots.dedup();
        roots
    }

    /// Check if two nodes are in the same block
    pub fn same_block(&self, v: NodeId, w: NodeId) -> bool {
        self.get_root(v) == self.get_root(w)
    }

    /// Verify the alignment is well-formed (no broken chains)
    #[cfg(debug_assertions)]
    pub fn verify(&self) -> bool {
        for &root in &self.get_all_roots() {
            let mut visited = HashSet::new();
            let mut current = root;

            loop {
                if visited.contains(&current) {
                    // Should only cycle back to root
                    if current != root {
                        return false;  // Broken cycle
                    }
                    break;
                }

                visited.insert(current);

                // Check root consistency
                if self.get_root(current) != root {
                    return false;
                }

                current = self.align.get(&current).copied().unwrap_or(current);
                if current == root && visited.len() > 1 {
                    break;  // Completed cycle
                }
            }
        }
        true
    }
}

/// Iterator over nodes in a block
pub struct BlockIterator<'a> {
    alignment: &'a BlockAlignment,
    current: Option<NodeId>,
    start: NodeId,
    first: bool,
}

impl<'a> Iterator for BlockIterator<'a> {
    type Item = NodeId;

    fn next(&mut self) -> Option<Self::Item> {
        let current = self.current?;

        if !self.first && current == self.start {
            // Completed the cycle
            return None;
        }

        self.first = false;
        let next = self.alignment.align.get(&current).copied().unwrap_or(current);

        self.current = if next == self.start {
            None  // Will stop on next call
        } else {
            Some(next)
        };

        Some(current)
    }
}

#[cfg(test)]
mod block_tests {
    use super::*;

    #[test]
    fn test_single_node_block() {
        let alignment = BlockAlignment::new(&[0, 1, 2]);

        assert_eq!(alignment.get_root(0), 0);
        assert_eq!(alignment.get_root(1), 1);
        assert!(!alignment.same_block(0, 1));
    }

    #[test]
    fn test_align_two_nodes() {
        let mut alignment = BlockAlignment::new(&[0, 1, 2]);

        alignment.align_below(1, 0);  // 1 below 0

        assert_eq!(alignment.get_root(0), 0);
        assert_eq!(alignment.get_root(1), 0);
        assert!(alignment.same_block(0, 1));
        assert!(!alignment.same_block(0, 2));
    }

    #[test]
    fn test_align_chain() {
        let mut alignment = BlockAlignment::new(&[0, 1, 2]);

        alignment.align_below(1, 0);  // 0 -> 1
        alignment.align_below(2, 1);  // 0 -> 1 -> 2

        assert_eq!(alignment.get_root(0), 0);
        assert_eq!(alignment.get_root(1), 0);
        assert_eq!(alignment.get_root(2), 0);

        let block_nodes = alignment.get_block_nodes(0);
        assert_eq!(block_nodes.len(), 3);
    }

    #[test]
    fn test_block_iterator() {
        let mut alignment = BlockAlignment::new(&[0, 1, 2]);
        alignment.align_below(1, 0);
        alignment.align_below(2, 1);

        let nodes: Vec<NodeId> = alignment.block_iter(0).collect();
        assert_eq!(nodes.len(), 3);
        assert!(nodes.contains(&0));
        assert!(nodes.contains(&1));
        assert!(nodes.contains(&2));
    }

    #[test]
    fn test_get_all_roots() {
        let mut alignment = BlockAlignment::new(&[0, 1, 2, 3, 4]);

        // Create two blocks: {0, 1, 2} and {3, 4}
        alignment.align_below(1, 0);
        alignment.align_below(2, 1);
        alignment.align_below(4, 3);

        let roots = alignment.get_all_roots();
        assert_eq!(roots.len(), 2);
    }

    #[test]
    fn test_verify_valid() {
        let mut alignment = BlockAlignment::new(&[0, 1, 2]);
        alignment.align_below(1, 0);
        alignment.align_below(2, 1);

        assert!(alignment.verify());
    }
}
```

## Key Points

1. **Circular linked list**: align pointers form a cycle through the block
2. **Root consistency**: All nodes in a block have the same root
3. **Verification**: Debug builds can verify structural integrity

## Acceptance Criteria

- [ ] `BlockAlignment::new()` creates valid single-node blocks
- [ ] `align_below()` correctly updates root and align pointers
- [ ] `get_block_nodes()` returns all nodes in a block
- [ ] `block_iter()` correctly traverses circular chain
- [ ] `same_block()` correctly identifies block membership
- [ ] `verify()` catches broken chain structures
- [ ] All unit tests pass

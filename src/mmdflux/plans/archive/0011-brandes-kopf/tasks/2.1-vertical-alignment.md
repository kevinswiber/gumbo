# Task 2.1: Implement vertical_alignment() for single direction/bias

## Objective

Implement the vertical alignment phase that groups nodes into blocks based on their connectivity, respecting conflicts.

## Background

Vertical alignment creates "blocks" of nodes that will share the same x-coordinate. Nodes are aligned with their median neighbor if no conflict prevents it.

```
Before alignment:          After alignment:
Layer 0:  [A]    [B]       Layer 0:  [A]    [B]
           \    /                     |      |
Layer 1:    [C]            Layer 1:  [C]    |   <- C aligned with A
             |                        |      |
Layer 2:    [D]            Layer 2:  [D]    |   <- D aligned with C (and A)
```

Nodes A, C, D form a block with A as root.

## Implementation

```rust
/// Compute vertical alignment for one direction/bias combination
///
/// # Arguments
/// * `graph` - The layered graph
/// * `conflicts` - Detected conflicts to respect
/// * `direction` - Which of the 4 alignment directions to use
///
/// # Returns
/// A BlockAlignment with root and align mappings
pub fn vertical_alignment(
    graph: &LayoutGraph,
    conflicts: &ConflictSet,
    direction: AlignmentDirection,
) -> BlockAlignment {
    // Get all node indices
    let all_nodes: Vec<NodeId> = (0..graph.positions.len()).collect();
    let mut alignment = BlockAlignment::new(&all_nodes);

    // Get layers in appropriate order
    let downward = direction.is_downward();
    let prefer_left = direction.prefers_left();
    let layers = get_layers_in_order(graph, downward);

    // Skip first layer (no neighbors in sweep direction)
    for layer_idx in 1..layers.len() {
        let layer = layers[layer_idx];
        let prev_layer = layers[layer_idx - 1];

        // Get nodes in this layer, in appropriate order
        let mut nodes = get_layer_nodes(graph, layer);
        if !prefer_left {
            nodes.reverse(); // Process right-to-left
        }

        // Track the rightmost position we've aligned to in prev layer
        // This prevents crossing alignments within same block
        let mut last_aligned_pos: Option<usize> = None;

        for node in nodes {
            // Get median neighbor in previous layer
            if let Some(median) = get_median_neighbor(graph, node, downward, prefer_left) {
                let median_pos = get_position(graph, median);
                let node_pos = get_position(graph, node);

                // Check if alignment is valid:
                // 1. No conflict between positions
                // 2. Doesn't cross a previous alignment

                let conflict_free = !has_conflict(conflicts, prev_layer, node_pos, median_pos);
                let order_ok = match last_aligned_pos {
                    None => true,
                    Some(last) => {
                        if prefer_left {
                            median_pos > last  // Must be to the right of last
                        } else {
                            median_pos < last  // Must be to the left of last
                        }
                    }
                };

                if conflict_free && order_ok {
                    // Align this node with median neighbor
                    alignment.align_nodes(node, median);
                    last_aligned_pos = Some(median_pos);
                }
            }
        }
    }

    alignment
}

/// Alternative implementation closer to paper pseudocode
pub fn vertical_alignment_v2(
    graph: &LayoutGraph,
    conflicts: &ConflictSet,
    direction: AlignmentDirection,
) -> BlockAlignment {
    let all_nodes: Vec<NodeId> = (0..graph.positions.len()).collect();
    let mut root: HashMap<NodeId, NodeId> = HashMap::new();
    let mut align: HashMap<NodeId, NodeId> = HashMap::new();

    // Initialize: each node is its own root and aligns to itself
    for &v in &all_nodes {
        root.insert(v, v);
        align.insert(v, v);
    }

    let downward = direction.is_downward();
    let prefer_left = direction.prefers_left();
    let layers = get_layers_in_order(graph, downward);

    for layer_idx in 1..layers.len() {
        let layer = layers[layer_idx];

        // r: position of last aligned node in the previous layer
        // Initialize based on sweep direction
        let mut r: i32 = if prefer_left { -1 } else { i32::MAX };

        // Get nodes in order
        let nodes = get_layer_nodes(graph, layer);
        let node_iter: Vec<NodeId> = if prefer_left {
            nodes
        } else {
            nodes.into_iter().rev().collect()
        };

        for v in node_iter {
            let neighbors = get_neighbors(graph, v, downward);
            if neighbors.is_empty() {
                continue;
            }

            // Get median neighbors
            let medians = get_median_neighbors(graph, v, downward, prefer_left);

            for m in medians {
                if align[&v] == v {  // v not yet aligned
                    let m_pos = get_position(graph, m) as i32;
                    let v_pos = get_position(graph, v);

                    // Check ordering constraint
                    let order_ok = if prefer_left {
                        r < m_pos
                    } else {
                        r > m_pos
                    };

                    // Check conflict
                    let conflict_free = !has_conflict(
                        conflicts,
                        layers[layer_idx - 1],
                        v_pos,
                        m_pos as usize,
                    );

                    if conflict_free && order_ok {
                        // Align v with m
                        align.insert(m, v);
                        let m_root = root[&m];
                        root.insert(v, m_root);
                        align.insert(v, m_root);
                        r = m_pos;
                    }
                }
            }
        }
    }

    BlockAlignment { root, align }
}

/// Get median neighbors (may return two for even neighbor count)
fn get_median_neighbors(
    graph: &LayoutGraph,
    node: NodeId,
    downward: bool,
    prefer_left: bool,
) -> Vec<NodeId> {
    let neighbors = get_neighbors(graph, node, downward);
    let len = neighbors.len();

    if len == 0 {
        return vec![];
    }

    if len == 1 {
        return vec![neighbors[0]];
    }

    // For even length, return the two middle elements
    // The order depends on prefer_left
    let mid = len / 2;
    if len % 2 == 0 {
        if prefer_left {
            vec![neighbors[mid - 1], neighbors[mid]]
        } else {
            vec![neighbors[mid], neighbors[mid - 1]]
        }
    } else {
        vec![neighbors[mid]]
    }
}

#[cfg(test)]
mod alignment_tests {
    use super::*;

    #[test]
    fn test_vertical_alignment_simple_chain() {
        // A -> B -> C (linear chain)
        // All should align into one block
        let graph = make_chain_graph(3);
        let conflicts = ConflictSet::new();

        let alignment = vertical_alignment(&graph, &conflicts, AlignmentDirection::UL);

        // All nodes should have the same root
        let root_a = alignment.get_root(0);
        let root_b = alignment.get_root(1);
        let root_c = alignment.get_root(2);

        assert_eq!(root_a, root_b);
        assert_eq!(root_b, root_c);
    }

    #[test]
    fn test_vertical_alignment_with_conflict() {
        // Create graph where alignment would violate conflict
        // Alignment should skip the conflicting node
        // ... test implementation ...
    }

    #[test]
    fn test_vertical_alignment_different_directions() {
        // Same graph should produce different alignments for UL vs DR
        // ... test implementation ...
    }
}
```

## Key Points

1. **Sweep direction**: UL/UR sweep top-to-bottom, DL/DR sweep bottom-to-top
2. **Bias**: UL/DL prefer left neighbors, UR/DR prefer right neighbors
3. **Ordering constraint**: Prevents crossing alignments within same sweep
4. **Conflict respect**: Skips alignments that would violate detected conflicts

## Acceptance Criteria

- [ ] `vertical_alignment()` produces valid BlockAlignment
- [ ] All 4 directions (UL, UR, DL, DR) work correctly
- [ ] Conflicts are respected (no alignment through conflict)
- [ ] Ordering constraint prevents crossing alignments
- [ ] Linear chains produce single blocks
- [ ] Forking structures produce appropriate blocks
- [ ] Unit tests pass

# Task 4.1-4.3: Implement balance and integration

## Objective

Compute all 4 alignments, select the best one, and integrate with the existing position.rs.

## Implementation

### 4.1: Compute 4 alignments

```rust
/// Compute all four alignment/compaction results
fn compute_all_alignments(
    graph: &LayoutGraph,
    conflicts: &ConflictSet,
    config: &BKConfig,
) -> HashMap<AlignmentDirection, CompactionResult> {
    let mut results = HashMap::new();

    for direction in AlignmentDirection::all() {
        let alignment = vertical_alignment(graph, conflicts, direction);
        let compaction = horizontal_compaction(graph, &alignment, config);
        results.insert(direction, compaction);
    }

    results
}
```

### 4.2: Select smallest width

```rust
/// Find the alignment with smallest total width
fn find_smallest_width(
    graph: &LayoutGraph,
    results: &HashMap<AlignmentDirection, CompactionResult>,
) -> AlignmentDirection {
    let mut best_dir = AlignmentDirection::UL;
    let mut best_width = f64::INFINITY;

    for (dir, result) in results {
        let width = calculate_width(graph, result);
        if width < best_width {
            best_width = width;
            best_dir = *dir;
        }
    }

    best_dir
}

/// Align all results to the smallest width result's bounds
fn align_to_smallest(
    graph: &LayoutGraph,
    results: &mut HashMap<AlignmentDirection, CompactionResult>,
    smallest: AlignmentDirection,
) {
    let smallest_result = results.get(&smallest).unwrap();

    // Find bounds of smallest
    let (min_x, max_x) = find_bounds(graph, smallest_result);

    // Align other results to these bounds
    for (dir, result) in results.iter_mut() {
        if *dir == smallest {
            continue;
        }

        let (result_min, result_max) = find_bounds(graph, result);

        // Determine shift based on alignment direction
        let shift = if dir.prefers_left() {
            min_x - result_min  // Align left edges
        } else {
            max_x - result_max  // Align right edges
        };

        // Apply shift to all coordinates
        for x in result.x.values_mut() {
            *x += shift;
        }
    }
}

fn find_bounds(graph: &LayoutGraph, result: &CompactionResult) -> (f64, f64) {
    let mut min_x = f64::INFINITY;
    let mut max_x = f64::NEG_INFINITY;

    for node in 0..graph.positions.len() {
        if let Some(&x) = result.x.get(&node) {
            let width = get_width(graph, node);
            min_x = min_x.min(x - width / 2.0);
            max_x = max_x.max(x + width / 2.0);
        }
    }

    (min_x, max_x)
}
```

### 4.3: Balance (median of all 4)

```rust
/// Compute final x-coordinates as median of all 4 alignments
fn balance(
    graph: &LayoutGraph,
    results: &HashMap<AlignmentDirection, CompactionResult>,
) -> HashMap<NodeId, f64> {
    let mut final_x = HashMap::new();

    for node in 0..graph.positions.len() {
        let mut xs: Vec<f64> = results.values()
            .filter_map(|r| r.x.get(&node).copied())
            .collect();

        if xs.is_empty() {
            continue;
        }

        xs.sort_by(|a, b| a.partial_cmp(b).unwrap());

        // Median of 4 values = average of middle 2
        let median = if xs.len() == 4 {
            (xs[1] + xs[2]) / 2.0
        } else if xs.len() >= 2 {
            let mid = xs.len() / 2;
            (xs[mid - 1] + xs[mid]) / 2.0
        } else {
            xs[0]
        };

        final_x.insert(node, median);
    }

    final_x
}
```

### Main entry point

```rust
/// Main entry point for Brandes-Köpf coordinate assignment
pub fn position_x(graph: &LayoutGraph, config: &BKConfig) -> HashMap<NodeId, f64> {
    // Step 1: Find conflicts
    let conflicts = find_all_conflicts(graph);

    // Step 2: Compute all 4 alignments
    let mut results = compute_all_alignments(graph, &conflicts, config);

    // Step 3: Find smallest width and align others to it
    let smallest = find_smallest_width(graph, &results);
    align_to_smallest(graph, &mut results, smallest);

    // Step 4: Balance (median of all 4)
    balance(graph, &results)
}
```

### Integration with position.rs

```rust
// In src/dagre/position.rs

use super::bk::{position_x as bk_position_x, BKConfig};

pub fn assign_positions(graph: &mut LayoutGraph, config: &LayoutConfig) {
    // Use Brandes-Köpf for x-coordinates
    let bk_config = BKConfig {
        node_sep: config.node_sep,
        direction: config.direction,
    };

    let x_coords = bk_position_x(graph, &bk_config);

    // Apply x-coordinates
    for (node, x) in x_coords {
        graph.positions[node].x = x - graph.dimensions[node].0 / 2.0;
    }

    // Y-coordinates assigned by layer (existing logic)
    assign_y_coordinates(graph, config);
}

fn assign_y_coordinates(graph: &mut LayoutGraph, config: &LayoutConfig) {
    // Existing layer-based y assignment
    // ... keep existing implementation ...
}
```

## Tests

```rust
#[test]
fn test_position_x_simple() {
    let graph = make_chain_graph(3);
    let config = BKConfig::default();

    let x = position_x(&graph, &config);

    // All nodes should have x-coordinates
    assert_eq!(x.len(), 3);
}

#[test]
fn test_position_x_minimizes_width() {
    let graph = make_wide_graph();
    let config = BKConfig::default();

    let x = position_x(&graph, &config);

    // Width should be reasonable (not infinite)
    let min_x = x.values().copied().fold(f64::INFINITY, f64::min);
    let max_x = x.values().copied().fold(f64::NEG_INFINITY, f64::max);
    let width = max_x - min_x;

    assert!(width < 1000.0, "Width should be compact");
}

#[test]
fn test_balance_produces_median() {
    // Create mock results with known values
    let mut results = HashMap::new();

    let mut ul = CompactionResult::new();
    ul.x.insert(0, 10.0);
    results.insert(AlignmentDirection::UL, ul);

    let mut ur = CompactionResult::new();
    ur.x.insert(0, 20.0);
    results.insert(AlignmentDirection::UR, ur);

    let mut dl = CompactionResult::new();
    dl.x.insert(0, 30.0);
    results.insert(AlignmentDirection::DL, dl);

    let mut dr = CompactionResult::new();
    dr.x.insert(0, 40.0);
    results.insert(AlignmentDirection::DR, dr);

    let graph = make_single_node_graph();
    let final_x = balance(&graph, &results);

    // Median of [10, 20, 30, 40] = (20 + 30) / 2 = 25
    assert_eq!(final_x.get(&0), Some(&25.0));
}
```

## Acceptance Criteria

- [ ] `compute_all_alignments()` produces 4 valid results
- [ ] `find_smallest_width()` identifies narrowest layout
- [ ] `align_to_smallest()` aligns results to common bounds
- [ ] `balance()` returns median x for each node
- [ ] `position_x()` orchestrates the full algorithm
- [ ] Integration with `position.rs` works
- [ ] Y-coordinates still assigned by layer
- [ ] All existing tests pass

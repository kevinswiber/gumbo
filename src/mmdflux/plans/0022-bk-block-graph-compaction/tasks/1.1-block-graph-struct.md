# Task 1.1: Implement BlockGraph Struct

## Objective

Create the `BlockGraph` data structure that represents separation constraints between block roots. This is the foundation for two-pass compaction.

## Location

Modify: `src/dagre/bk.rs`

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[test]
fn test_block_graph_empty() {
    let bg = BlockGraph::new();
    assert!(bg.nodes.is_empty());
    assert_eq!(bg.topological_order().len(), 0);
}

#[test]
fn test_block_graph_single_node() {
    let mut bg = BlockGraph::new();
    bg.add_node(0);
    assert_eq!(bg.nodes.len(), 1);
    assert_eq!(bg.predecessors(0).len(), 0);
    assert_eq!(bg.successors(0).len(), 0);
    assert_eq!(bg.topological_order(), vec![0]);
}

#[test]
fn test_block_graph_chain() {
    let mut bg = BlockGraph::new();
    bg.add_node(0);
    bg.add_node(1);
    bg.add_node(2);
    bg.add_edge(0, 1, 50.0);
    bg.add_edge(1, 2, 50.0);

    assert_eq!(bg.predecessors(1).len(), 1);
    assert_eq!(bg.predecessors(1)[0], (0, 50.0));
    assert_eq!(bg.successors(1).len(), 1);
    assert_eq!(bg.successors(1)[0], (2, 50.0));

    let topo = bg.topological_order();
    // 0 must come before 1, 1 before 2
    let pos_0 = topo.iter().position(|&n| n == 0).unwrap();
    let pos_1 = topo.iter().position(|&n| n == 1).unwrap();
    let pos_2 = topo.iter().position(|&n| n == 2).unwrap();
    assert!(pos_0 < pos_1);
    assert!(pos_1 < pos_2);
}

#[test]
fn test_block_graph_max_weight_edge() {
    // When adding duplicate edge, keep the maximum weight
    let mut bg = BlockGraph::new();
    bg.add_node(0);
    bg.add_node(1);
    bg.add_edge(0, 1, 30.0);
    bg.add_edge(0, 1, 50.0); // Should update to max

    assert_eq!(bg.successors(0).len(), 1);
    assert_eq!(bg.successors(0)[0], (1, 50.0));
    assert_eq!(bg.predecessors(1)[0], (0, 50.0));
}

#[test]
fn test_block_graph_diamond() {
    let mut bg = BlockGraph::new();
    bg.add_node(0);
    bg.add_node(1);
    bg.add_node(2);
    bg.add_edge(0, 1, 40.0);
    bg.add_edge(0, 2, 40.0);

    assert_eq!(bg.successors(0).len(), 2);
    assert_eq!(bg.predecessors(1).len(), 1);
    assert_eq!(bg.predecessors(2).len(), 1);

    let topo = bg.topological_order();
    let pos_0 = topo.iter().position(|&n| n == 0).unwrap();
    let pos_1 = topo.iter().position(|&n| n == 1).unwrap();
    let pos_2 = topo.iter().position(|&n| n == 2).unwrap();
    assert!(pos_0 < pos_1);
    assert!(pos_0 < pos_2);
}
```

**What the failing test asserts:** BlockGraph can store nodes, directed edges with weights, look up predecessors/successors, merge duplicate edges by max weight, and produce a valid topological ordering.

**Expected failure reason:** `BlockGraph` struct does not exist yet.

### ðŸŸ¢ Green: Minimal Implementation

```rust
/// A directed graph of block separation constraints for two-pass compaction.
/// Nodes are block roots. Edges carry minimum separation weights.
#[derive(Debug)]
struct BlockGraph {
    /// All block root node indices
    nodes: Vec<NodeIndex>,
    /// Adjacency: node -> [(successor, weight)]
    out_edges: HashMap<NodeIndex, Vec<(NodeIndex, f64)>>,
    /// Reverse adjacency: node -> [(predecessor, weight)]
    in_edges: HashMap<NodeIndex, Vec<(NodeIndex, f64)>>,
}

impl BlockGraph {
    fn new() -> Self {
        Self {
            nodes: Vec::new(),
            out_edges: HashMap::new(),
            in_edges: HashMap::new(),
        }
    }

    fn add_node(&mut self, root: NodeIndex) {
        if !self.nodes.contains(&root) {
            self.nodes.push(root);
        }
    }

    /// Add an edge or update to max weight if edge already exists.
    fn add_edge(&mut self, from: NodeIndex, to: NodeIndex, weight: f64) {
        // Update or insert in out_edges
        let out = self.out_edges.entry(from).or_default();
        if let Some(entry) = out.iter_mut().find(|(n, _)| *n == to) {
            entry.1 = entry.1.max(weight);
        } else {
            out.push((to, weight));
        }

        // Update or insert in in_edges
        let inp = self.in_edges.entry(to).or_default();
        if let Some(entry) = inp.iter_mut().find(|(n, _)| *n == from) {
            entry.1 = entry.1.max(weight);
        } else {
            inp.push((from, weight));
        }
    }

    fn predecessors(&self, node: NodeIndex) -> &[(NodeIndex, f64)] {
        self.in_edges.get(&node).map(|v| v.as_slice()).unwrap_or(&[])
    }

    fn successors(&self, node: NodeIndex) -> &[(NodeIndex, f64)] {
        self.out_edges.get(&node).map(|v| v.as_slice()).unwrap_or(&[])
    }

    /// Kahn's algorithm for topological sort.
    fn topological_order(&self) -> Vec<NodeIndex> {
        let mut in_degree: HashMap<NodeIndex, usize> = HashMap::new();
        for &n in &self.nodes {
            in_degree.insert(n, self.predecessors(n).len());
        }

        let mut queue: Vec<NodeIndex> = self.nodes.iter()
            .filter(|&&n| in_degree[&n] == 0)
            .copied()
            .collect();
        queue.sort(); // deterministic ordering for sources

        let mut result = Vec::with_capacity(self.nodes.len());
        while let Some(node) = queue.pop() {
            // pop from front for BFS-style (use as deque), but Vec::pop is from back
            // Actually use remove(0) or reverse sort order
        }
        // Better: use VecDeque
        let mut queue: std::collections::VecDeque<NodeIndex> = in_degree.iter()
            .filter(|(_, &deg)| deg == 0)
            .map(|(&n, _)| n)
            .collect();
        let mut sorted_queue: Vec<NodeIndex> = queue.drain(..).collect();
        sorted_queue.sort();
        queue.extend(sorted_queue);

        let mut result = Vec::with_capacity(self.nodes.len());
        while let Some(node) = queue.pop_front() {
            result.push(node);
            for &(succ, _) in self.successors(node) {
                let deg = in_degree.get_mut(&succ).unwrap();
                *deg -= 1;
                if *deg == 0 {
                    queue.push_back(succ);
                }
            }
        }
        result
    }
}
```

### ðŸ”µ Refactor: Clean Up

- Use `VecDeque` properly from the start (the green phase sketch above has a false start)
- Consider whether `nodes` should be a `HashSet` for O(1) contains-check in `add_node`
- Ensure deterministic topological order by sorting nodes with equal in-degree

## Context

This struct mirrors dagre.js's `buildBlockGraph()` return value (lines 267-287 of dagre `bk.js`). The block graph is consumed by the two-pass compaction in Task 2.1.

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] BlockGraph struct implemented with add_node, add_edge, predecessors, successors, topological_order
- [ ] Duplicate edges merged by max weight
- [ ] Topological order is deterministic
- [ ] All tests green
- [ ] Code refactored and clean

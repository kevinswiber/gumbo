# Task 1.2: Implement compute_sep Function

## Objective

Create the `compute_sep()` function that computes the minimum separation weight between two adjacent nodes for use as block graph edge weights. This mirrors dagre.js's `sep()` function (bk.js lines 389-425).

## Location

Modify: `src/dagre/bk.rs`

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[test]
fn test_compute_sep_real_nodes() {
    let lg = make_diamond_graph();
    let config = BKConfig::default(); // node_sep=50, edge_sep=20
    let b = lg.node_index[&"B".into()];
    let c = lg.node_index[&"C".into()];

    // Both real nodes: sep = b_width/2 + (node_sep + node_sep)/2 + c_width/2
    let sep = compute_sep(&lg, b, c, &config);
    let b_width = get_width(&lg, b, config.direction);
    let c_width = get_width(&lg, c, config.direction);
    let expected = b_width / 2.0 + config.node_sep + c_width / 2.0;
    assert_eq!(sep, expected);
}

#[test]
fn test_compute_sep_dummy_nodes() {
    // Need a graph with dummy nodes to test edge_sep
    // Build a graph with a skip edge, normalize to create dummies
    let mut graph = DiGraph::new();
    graph.set_node("A", 40.0, 20.0);
    graph.set_node("B", 40.0, 20.0);
    graph.set_node("C", 40.0, 20.0);
    graph.add_edge("A", "B");
    graph.add_edge("A", "C"); // skip edge if C is rank 2

    let mut lg = LayoutGraph::from_digraph(&graph, |_, dims| *dims);
    rank::run(&mut lg);
    rank::normalize(&mut lg);

    let config = BKConfig { edge_sep: 20.0, ..Default::default() };

    // Find dummy nodes and test that sep uses edge_sep for them
    // (Details depend on graph structure after normalization)
}
```

**What the failing test asserts:** `compute_sep` returns the correct center-to-center minimum distance accounting for half-widths and the appropriate sep (node_sep for real nodes, edge_sep for dummies).

**Expected failure reason:** `compute_sep` function does not exist.

### ðŸŸ¢ Green: Minimal Implementation

```rust
/// Compute the minimum separation between two adjacent nodes.
/// Uses `node_sep` for real nodes and `edge_sep` for dummy nodes,
/// averaged between the two nodes. Returns center-to-center distance.
fn compute_sep(
    graph: &LayoutGraph,
    left: NodeIndex,
    right: NodeIndex,
    config: &BKConfig,
) -> f64 {
    let left_width = get_width(graph, left, config.direction);
    let right_width = get_width(graph, right, config.direction);
    let left_sep = separation_for(graph, left, config);
    let right_sep = separation_for(graph, right, config);
    left_width / 2.0 + (left_sep + right_sep) / 2.0 + right_width / 2.0
}
```

Note: This reuses the existing `separation_for()` helper (bk.rs:694-702) and `get_width()` (bk.rs:300).

### ðŸ”µ Refactor: Clean Up

- Verify this matches the dagre.js `sep()` function semantics
- Ensure the function handles edge cases (zero-width dummy nodes)

## Context

The existing `place_block()` already computes this inline at lines 751-756:
```rust
let left_width = get_width(graph, left, config.direction);
let node_width = get_width(graph, node, config.direction);
let left_sep = separation_for(graph, left, config);
let node_sep = separation_for(graph, node, config);
let sep = (left_sep + node_sep) / 2.0;
let min_separation = (left_width + node_width) / 2.0 + sep;
```

`compute_sep` extracts this into a named function for use by `build_block_graph()`.

## Acceptance Criteria

- [ ] Failing test written and confirmed red
- [ ] compute_sep implemented matching dagre.js sep() semantics
- [ ] Tests pass for real-real, dummy-dummy, and mixed node pairs
- [ ] Code refactored and clean

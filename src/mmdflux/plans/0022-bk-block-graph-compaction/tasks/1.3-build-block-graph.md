# Task 1.3: Implement build_block_graph Function

## Objective

Create the `build_block_graph()` function that constructs a BlockGraph from a vertical alignment and layer structure. This mirrors dagre.js `buildBlockGraph()` (bk.js lines 267-287).

## Location

Modify: `src/dagre/bk.rs`

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[test]
fn test_build_block_graph_single_block() {
    // All nodes in the same block â†’ block graph has one node, no edges
    let lg = make_diamond_graph();
    let layers = get_layers(&lg);
    let config = BKConfig::default();

    // Create alignment where all nodes share root 0
    let a = lg.node_index[&"A".into()];
    let b = lg.node_index[&"B".into()];
    let c = lg.node_index[&"C".into()];
    let d = lg.node_index[&"D".into()];

    let mut alignment = BlockAlignment::new(&[a, b, c, d]);
    alignment.root.insert(b, a);
    alignment.root.insert(c, a);
    alignment.root.insert(d, a);

    let bg = build_block_graph(&lg, &alignment, &layers, &config);
    assert_eq!(bg.nodes.len(), 1);
}

#[test]
fn test_build_block_graph_diamond_separate_blocks() {
    // Each node is its own block â†’ edges between adjacent nodes' roots
    let lg = make_diamond_graph();
    let layers = get_layers(&lg);
    let config = BKConfig::default();

    let a = lg.node_index[&"A".into()];
    let b = lg.node_index[&"B".into()];
    let c = lg.node_index[&"C".into()];
    let d = lg.node_index[&"D".into()];

    let alignment = BlockAlignment::new(&[a, b, c, d]);

    let bg = build_block_graph(&lg, &alignment, &layers, &config);

    // Layer 1 has B (order 0) and C (order 1), different roots
    // â†’ edge from B's root to C's root
    assert_eq!(bg.successors(b).len(), 1);
    assert_eq!(bg.successors(b)[0].0, c);

    // Layer 0 has only A, layer 2 has only D â†’ no edges from those layers
    assert_eq!(bg.successors(a).len(), 0);
    assert_eq!(bg.successors(d).len(), 0);
}

#[test]
fn test_build_block_graph_adjacent_same_root_no_edge() {
    // Two adjacent nodes in same block â†’ no edge between them
    let lg = make_diamond_graph();
    let layers = get_layers(&lg);
    let config = BKConfig::default();

    let a = lg.node_index[&"A".into()];
    let b = lg.node_index[&"B".into()];
    let c = lg.node_index[&"C".into()];
    let d = lg.node_index[&"D".into()];

    // B and C share root B
    let mut alignment = BlockAlignment::new(&[a, b, c, d]);
    alignment.root.insert(c, b);

    let bg = build_block_graph(&lg, &alignment, &layers, &config);

    // B and C are adjacent in layer 1 but same root â†’ no edge
    assert_eq!(bg.successors(b).len(), 0);
}
```

**What the failing test asserts:** `build_block_graph` correctly identifies block roots, creates edges between adjacent blocks in each layer, and skips same-root pairs.

**Expected failure reason:** `build_block_graph` function does not exist.

### ðŸŸ¢ Green: Minimal Implementation

```rust
/// Build a block graph from a vertical alignment.
/// Each unique block root becomes a node. For each pair of adjacent nodes
/// in a layer with different block roots, add an edge with the separation weight.
fn build_block_graph(
    graph: &LayoutGraph,
    alignment: &BlockAlignment,
    layers: &[Vec<NodeIndex>],
    config: &BKConfig,
) -> BlockGraph {
    let mut bg = BlockGraph::new();

    // Add all unique roots as nodes
    for &root in &alignment.get_all_roots() {
        bg.add_node(root);
    }

    // For each layer, add edges between adjacent nodes with different roots
    for layer in layers {
        for i in 1..layer.len() {
            let left = layer[i - 1];
            let right = layer[i];
            let left_root = alignment.get_root(left);
            let right_root = alignment.get_root(right);

            if left_root != right_root {
                let weight = compute_sep(graph, left, right, config);
                bg.add_edge(left_root, right_root, weight);
            }
        }
    }

    bg
}
```

### ðŸ”µ Refactor: Clean Up

- Verify edge weight merging works correctly (max weight across layers)
- Add doc comment explaining the dagre.js correspondence

## Context

dagre.js `buildBlockGraph()` (bk.js:267-287) iterates layers left-to-right, checks adjacent pairs, and adds edges between their block roots with `sep()` weights. Multiple layer pairs with the same root pair get max weight.

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] build_block_graph implemented
- [ ] Single-block, multi-block, and same-root-skip cases tested
- [ ] Edge weights correctly use compute_sep
- [ ] Max weight merging works for same root pairs across layers
- [ ] Code refactored and clean

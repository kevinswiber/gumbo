# Task 2.1: Replace horizontal_compaction with Two-Pass Block Graph Algorithm

## Objective

Replace the `place_block()` recursive single-pass placement inside `horizontal_compaction()` with the two-pass block graph compaction algorithm from dagre.js. This is the core change that produces diagonal stagger for skip edges.

## Location

Modify: `src/dagre/bk.rs` â€” `horizontal_compaction()` function (lines 640-692)

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

Write a test that demonstrates the stagger difference. The key behavior: when dummy chain nodes exist between real node blocks, the two-pass compaction creates wider gaps around real nodes vs the current single-pass.

```rust
#[test]
fn test_compaction_two_pass_distributes_slack() {
    // Build a graph where single-pass produces tight layout but two-pass
    // should distribute slack.
    //
    // Layout: 3 nodes in one layer (A, B, C) where A and C are in the same
    // block but B is a different block. The block graph has edge A_root -> B_root
    // and B_root -> C_root.
    //
    // Single-pass: B is placed at min_sep from A, C at min_sep from B.
    // Two-pass: B gets pulled rightward in Pass 2 if there's slack.
    //
    // More concretely: use the double_skip topology where real nodes should
    // be staggered wider than minimal placement.

    let mut graph = DiGraph::new();
    graph.set_node("Start", 50.0, 20.0);
    graph.set_node("Step1", 50.0, 20.0);
    graph.set_node("Step2", 50.0, 20.0);
    graph.set_node("End", 50.0, 20.0);
    graph.add_edge("Start", "Step1");
    graph.add_edge("Start", "Step2"); // skip edge
    graph.add_edge("Start", "End");   // double skip edge
    graph.add_edge("Step1", "Step2");
    graph.add_edge("Step2", "End");

    let mut lg = LayoutGraph::from_digraph(&graph, |_, dims| *dims);
    rank::run(&mut lg);
    rank::normalize(&mut lg);
    order::run(&mut lg);

    let config = BKConfig::default();
    let alignment = vertical_alignment(&lg, &HashMap::new(), AlignmentDirection::UL, &config);
    let result = horizontal_compaction(&lg, &alignment, &config);

    // Verify all separation constraints are met
    let layers = get_layers(&lg);
    for layer in &layers {
        for i in 1..layer.len() {
            let left = layer[i - 1];
            let right = layer[i];
            let left_x = result.x[&left];
            let right_x = result.x[&right];
            let min_sep = compute_sep(&lg, left, right, &config);
            assert!(
                right_x - left_x >= min_sep - 0.001,
                "Separation constraint violated between nodes {} and {}: {} < {}",
                left, right, right_x - left_x, min_sep
            );
        }
    }
}

#[test]
fn test_compaction_chain_no_regression() {
    // Simple A -> B -> C chain: all in one block, same x
    let mut graph = DiGraph::new();
    graph.set_node("A", 40.0, 20.0);
    graph.set_node("B", 40.0, 20.0);
    graph.set_node("C", 40.0, 20.0);
    graph.add_edge("A", "B");
    graph.add_edge("B", "C");

    let mut lg = LayoutGraph::from_digraph(&graph, |_, dims| *dims);
    rank::run(&mut lg);
    rank::normalize(&mut lg);
    order::run(&mut lg);

    let config = BKConfig::default();
    let alignment = vertical_alignment(&lg, &HashMap::new(), AlignmentDirection::UL, &config);
    let result = horizontal_compaction(&lg, &alignment, &config);

    let a = lg.node_index[&"A".into()];
    let b = lg.node_index[&"B".into()];
    let c = lg.node_index[&"C".into()];

    // All in same block â†’ same x coordinate
    assert_eq!(result.x[&a], result.x[&b]);
    assert_eq!(result.x[&b], result.x[&c]);
}

#[test]
fn test_compaction_diamond_separation() {
    let lg = make_diamond_graph();
    let config = BKConfig::default();
    let alignment = vertical_alignment(&lg, &HashMap::new(), AlignmentDirection::UL, &config);
    let result = horizontal_compaction(&lg, &alignment, &config);

    let b = lg.node_index[&"B".into()];
    let c = lg.node_index[&"C".into()];

    // B and C must be separated by at least compute_sep
    let sep = compute_sep(&lg, b, c, &config);
    assert!(result.x[&c] - result.x[&b] >= sep - 0.001);
}
```

**What the failing test asserts:** The new compaction maintains separation constraints, handles chains correctly (no regression), and separates diamond nodes properly.

**Expected failure reason:** Tests will initially pass with old algorithm; the key behavioral test is `test_compaction_two_pass_distributes_slack` which verifies constraints are met with the new algorithm. The actual stagger improvement will be verified visually in Phase 3.

### ðŸŸ¢ Green: Minimal Implementation

Replace the body of `horizontal_compaction()`:

```rust
pub fn horizontal_compaction(
    graph: &LayoutGraph,
    alignment: &BlockAlignment,
    config: &BKConfig,
) -> CompactionResult {
    let mut result = CompactionResult::new();
    let layers = get_layers(graph);
    let num_nodes = graph.node_ids.len();

    // Build block graph with separation constraints
    let block_graph = build_block_graph(graph, alignment, &layers, config);

    // Two-pass compaction
    let mut xs: HashMap<NodeIndex, f64> = HashMap::new();

    // Pass 1: Assign smallest valid coordinates (topological order from sources)
    let topo = block_graph.topological_order();
    for &root in &topo {
        let x = block_graph.predecessors(root)
            .iter()
            .map(|&(pred, weight)| xs.get(&pred).copied().unwrap_or(0.0) + weight)
            .fold(0.0_f64, f64::max);
        xs.insert(root, x);
    }

    // Pass 2: Assign greatest valid coordinates (reverse topological order from sinks)
    for &root in topo.iter().rev() {
        let successors = block_graph.successors(root);
        if !successors.is_empty() {
            let pull_right = successors
                .iter()
                .map(|&(succ, weight)| xs[&succ] - weight)
                .fold(f64::INFINITY, f64::min);
            if pull_right.is_finite() {
                let current = xs[&root];
                if pull_right > current {
                    xs.insert(root, pull_right);
                }
            }
        }
    }

    // Propagate: all nodes in block get root's coordinate
    for node in 0..num_nodes {
        let root = alignment.get_root(node);
        if let Some(&root_x) = xs.get(&root) {
            result.x.insert(node, root_x);
        }
    }

    // Normalize: shift so minimum x is 0
    let min_x = result.x.values().copied().fold(f64::INFINITY, f64::min);
    if min_x.is_finite() {
        for x in result.x.values_mut() {
            *x -= min_x;
        }
    }

    result
}
```

### ðŸ”µ Refactor: Clean Up

- Remove the `sink` and `shift` initialization code (no longer needed)
- Remove the `sorted_roots` ordering code (block graph handles this via topological sort)
- Verify all existing BK tests pass â€” update coordinate assertions if needed (separation invariants are what matter, not exact values)
- Run `cargo test` to check for regressions

## Context

This is the core algorithmic change. dagre.js `horizontalCompaction()` (bk.js:206-264):
- Pass 1 (lines 238-247): DFS from sources, `xs[v] = max(xs[u] + blockGraph.edge(e).weight)`
- Pass 2 (lines 249-258): DFS from sinks, `xs[v] = max(xs[v], min(xs[w] - blockGraph.edge(e).weight))`

The current `place_block()` recursive approach is equivalent to Pass 1 only. Adding Pass 2 redistributes slack, creating the stagger.

The `sink` and `shift` fields on `CompactionResult` were for the original BK class-based compaction. The block graph approach doesn't use them. They're only written to (never read externally), so they can be removed.

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] horizontal_compaction rewritten with two-pass block graph algorithm
- [ ] Chain graphs produce same x for all block members (no regression)
- [ ] Diamond graphs maintain separation constraints
- [ ] Skip-edge graphs produce wider stagger than before
- [ ] All existing BK unit tests pass (with updated coordinate expectations if needed)
- [ ] Code refactored and clean

# Task 6.1–6.3: Assemble `compute_layout_direct()` (TDD)

## Objective
Assemble the four tested components (scale factors, collision repair, waypoint transform, label transform) into a complete `compute_layout_direct()` function that produces a valid `Layout` from a `Diagram`.

## Location
Modify: `src/render/layout.rs` (new public function)
Modify: `tests/integration.rs` (integration tests)

---

## RED — Write failing integration tests (6.1)

### Stub in layout.rs:

```rust
pub fn compute_layout_direct(diagram: &Diagram, config: &LayoutConfig) -> Layout {
    unimplemented!("compute_layout_direct not yet implemented")
}
```

### Tests in `tests/integration.rs`:

```rust
mod direct_layout {
    use super::*;
    use mmdflux::render::layout::{compute_layout_direct, LayoutConfig};

    fn layout_fixture(name: &str) -> Layout {
        let diagram = parse_and_build(name);
        let config = LayoutConfig::default();
        compute_layout_direct(&diagram, &config)
    }

    #[test]
    fn direct_simple_produces_valid_layout() {
        let layout = layout_fixture("simple.mmd");

        // Canvas dimensions are positive
        assert!(layout.width > 0, "canvas width must be positive");
        assert!(layout.height > 0, "canvas height must be positive");

        // All nodes have draw positions
        assert!(layout.draw_positions.contains_key("A"));
        assert!(layout.draw_positions.contains_key("B"));

        // All nodes have bounds
        assert!(layout.node_bounds.contains_key("A"));
        assert!(layout.node_bounds.contains_key("B"));
    }

    #[test]
    fn direct_no_node_overlaps() {
        // chain.mmd: A→B→C→D — all in a single column for TD
        let layout = layout_fixture("chain.mmd");

        // Collect all bounds
        let bounds: Vec<_> = layout.node_bounds.values().collect();

        // No two nodes overlap
        for i in 0..bounds.len() {
            for j in (i + 1)..bounds.len() {
                let a = bounds[i];
                let b = bounds[j];
                let x_overlap = a.x < b.x + b.width && b.x < a.x + a.width;
                let y_overlap = a.y < b.y + b.height && b.y < a.y + a.height;
                assert!(
                    !(x_overlap && y_overlap),
                    "nodes overlap: {:?} vs {:?}", a, b
                );
            }
        }
    }

    #[test]
    fn direct_nodes_within_canvas() {
        let layout = layout_fixture("fan_out.mmd");

        for (id, bounds) in &layout.node_bounds {
            assert!(
                bounds.x + bounds.width <= layout.width,
                "node {} exceeds canvas width: {} + {} > {}",
                id, bounds.x, bounds.width, layout.width
            );
            assert!(
                bounds.y + bounds.height <= layout.height,
                "node {} exceeds canvas height: {} + {} > {}",
                id, bounds.y, bounds.height, layout.height
            );
        }
    }

    #[test]
    fn direct_td_vertical_ordering() {
        // simple.mmd: A→B, TD layout. A should be above B.
        let layout = layout_fixture("simple.mmd");

        let a_y = layout.draw_positions["A"].1;
        let b_y = layout.draw_positions["B"].1;
        assert!(a_y < b_y, "in TD layout, A (rank 0) should be above B (rank 1)");
    }

    #[test]
    fn direct_lr_horizontal_ordering() {
        // left_right.mmd: LR layout. Earlier-rank nodes should have smaller x.
        let diagram = parse_and_build("left_right.mmd");
        let config = LayoutConfig::default();
        let layout = compute_layout_direct(&diagram, &config);

        // First node should have smaller x than last node
        // (exact IDs depend on fixture; verify at least width > height for LR)
        assert!(layout.width > layout.height || layout.node_bounds.len() <= 2,
            "LR layout should generally be wider than tall");
    }
}
```

### Run and confirm failure:
```bash
cargo test direct_ -- --nocapture
```

All tests panic with `unimplemented!()`.

---

## GREEN — Assemble the function (6.2)

Implement `compute_layout_direct()` by:

1. **Reuse dagre setup** — copy the dagre graph construction and configuration from `compute_layout_dagre()` (lines ~179–330). This includes building `DiGraph`, configuring direction-aware `node_sep`/`edge_sep`, computing `node_dims`, calling `dagre::layout_with_labels()`, and constructing layers from the result.

2. **Apply the 3-step pipeline** using the already-tested functions:
   - Call `compute_ascii_scale_factors()` with `node_dims`, `rank_sep`, `node_sep`, spacings, `is_vertical`
   - Compute `dagre_min_x` and `dagre_min_y` from `result.nodes` bounding box
   - Scale each node: `center = (dagre_center - dagre_min) * scale`, then top-left = `center - dim/2`, plus padding/margin offsets
   - Call `collision_repair()` on the scaled positions
   - Compute canvas width/height from max node extents + padding
   - Compute `layer_starts` from node draw positions grouped by rank
   - Apply BT/RL coordinate flips if needed
   - Call `transform_waypoints_direct()` and `transform_label_positions_direct()`
   - Port the existing waypoint-node collision nudging (lines 522–551 of current `compute_layout_dagre()`)
   - Assemble `Layout` struct

3. **Make it callable** — add `pub` visibility, export from `src/render/layout.rs`

The minimum implementation does **not** need to:
- Handle every edge case perfectly (regression tests come in Phase 8)
- Be cleanly structured (refactoring comes in 6.3)

---

## REFACTOR — Extract shared code, clean up (6.3)

- Extract the dagre graph construction + configuration into a shared helper function (e.g., `build_dagre_graph()`) to avoid duplication with `compute_layout_dagre()`
- Clean up any copied code
- Ensure the function is well-documented
- Confirm `cargo test` (all tests including existing integration tests) passes
- Confirm `cargo clippy` passes
- Commit: `feat(plan-0019): Phase 6 - Assembled compute_layout_direct with integration tests`

## Context

- The `Layout` struct requires `grid_positions: HashMap<String, GridPos>`. The direct pipeline does not produce grid positions naturally. For now, populate with a synthetic value derived from layer index and within-layer position.
- Waypoint-node collision nudging (lines 522–551 of current code) should be copied verbatim — it's a post-processing step independent of the coordinate translation method.

## Acceptance Criteria
- [ ] All 5 integration tests pass
- [ ] All existing integration tests still pass (old path untouched)
- [ ] No node overlaps on `chain.mmd`
- [ ] All nodes within canvas bounds on `fan_out.mmd`
- [ ] Correct directional ordering (TD: top→bottom, LR: left→right)
- [ ] `cargo clippy` clean

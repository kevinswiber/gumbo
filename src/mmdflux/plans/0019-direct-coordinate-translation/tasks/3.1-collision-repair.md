# Task 3.1–3.3: Collision Repair (TDD)

## Objective
Implement `collision_repair()` — a function that enforces minimum spacing between adjacent nodes within each layer after scaling and rounding.

## Location
Modify: `src/render/layout.rs` (function + tests in `#[cfg(test)] mod tests`)

---

## RED — Write failing tests (3.1)

Add a stub and tests.

### Stub:

```rust
fn collision_repair(
    layers: &[Vec<String>],
    draw_positions: &mut HashMap<String, (usize, usize)>,
    node_dims: &HashMap<String, (usize, usize)>,
    is_vertical: bool,
    min_gap: usize,
) {
    // stub — does nothing, tests will fail
}
```

### Tests:

```rust
#[test]
fn collision_repair_pushes_overlapping_nodes_apart() {
    // TD layout: two nodes at x=0 and x=5, both width 8 → overlap
    // Node A: x=0, w=8, right edge at 8. Min gap = 4 → B must be at x >= 12
    // Node B: x=5 (overlapping) → should be pushed to x=12
    let layers = vec![vec!["A".into(), "B".into()]];
    let mut positions: HashMap<String, (usize, usize)> = HashMap::new();
    positions.insert("A".into(), (0, 0));
    positions.insert("B".into(), (5, 0));
    let mut dims: HashMap<String, (usize, usize)> = HashMap::new();
    dims.insert("A".into(), (8, 3));
    dims.insert("B".into(), (8, 3));

    collision_repair(&layers, &mut positions, &dims, true, 4);

    assert_eq!(positions["A"], (0, 0), "A should not move");
    assert_eq!(positions["B"], (12, 0), "B pushed to right edge of A + gap");
}

#[test]
fn collision_repair_cascading() {
    // Three nodes, first two overlap → pushing B cascades to C
    // A at x=0 w=6, B at x=3 w=6, C at x=8 w=6, gap=2
    // B pushed to 0+6+2=8, C must be >= 8+6+2=16
    let layers = vec![vec!["A".into(), "B".into(), "C".into()]];
    let mut positions: HashMap<String, (usize, usize)> = HashMap::new();
    positions.insert("A".into(), (0, 0));
    positions.insert("B".into(), (3, 0));
    positions.insert("C".into(), (8, 0));
    let mut dims: HashMap<String, (usize, usize)> = HashMap::new();
    dims.insert("A".into(), (6, 3));
    dims.insert("B".into(), (6, 3));
    dims.insert("C".into(), (6, 3));

    collision_repair(&layers, &mut positions, &dims, true, 2);

    assert_eq!(positions["A"], (0, 0));
    assert_eq!(positions["B"], (8, 0));
    assert_eq!(positions["C"], (16, 0));
}

#[test]
fn collision_repair_no_change_when_spaced() {
    // Nodes already have enough space — should not move
    let layers = vec![vec!["A".into(), "B".into()]];
    let mut positions: HashMap<String, (usize, usize)> = HashMap::new();
    positions.insert("A".into(), (0, 0));
    positions.insert("B".into(), (20, 0));
    let mut dims: HashMap<String, (usize, usize)> = HashMap::new();
    dims.insert("A".into(), (8, 3));
    dims.insert("B".into(), (8, 3));

    collision_repair(&layers, &mut positions, &dims, true, 4);

    assert_eq!(positions["A"], (0, 0));
    assert_eq!(positions["B"], (20, 0));
}

#[test]
fn collision_repair_horizontal_layout() {
    // LR layout: cross-axis is Y. Two nodes at y=0 and y=2, both height 3
    // A: y=0, h=3, bottom at 3. Gap=3 → B must be at y >= 6
    let layers = vec![vec!["A".into(), "B".into()]];
    let mut positions: HashMap<String, (usize, usize)> = HashMap::new();
    positions.insert("A".into(), (0, 0));
    positions.insert("B".into(), (0, 2));
    let mut dims: HashMap<String, (usize, usize)> = HashMap::new();
    dims.insert("A".into(), (8, 3));
    dims.insert("B".into(), (8, 3));

    collision_repair(&layers, &mut positions, &dims, false, 3);

    assert_eq!(positions["A"], (0, 0));
    assert_eq!(positions["B"], (0, 6));
}

#[test]
fn collision_repair_single_node_layer_noop() {
    // Single-node layer — nothing to repair
    let layers = vec![vec!["A".into()]];
    let mut positions: HashMap<String, (usize, usize)> = HashMap::new();
    positions.insert("A".into(), (5, 5));
    let mut dims: HashMap<String, (usize, usize)> = HashMap::new();
    dims.insert("A".into(), (8, 3));

    collision_repair(&layers, &mut positions, &dims, true, 4);

    assert_eq!(positions["A"], (5, 5));
}

#[test]
fn collision_repair_sorts_by_cross_axis() {
    // Layer order in vec does not match cross-axis order
    // B is at x=0, A is at x=20 — vec has [A, B] but repair should sort by x
    let layers = vec![vec!["A".into(), "B".into()]];
    let mut positions: HashMap<String, (usize, usize)> = HashMap::new();
    positions.insert("A".into(), (20, 0));
    positions.insert("B".into(), (0, 0));
    let mut dims: HashMap<String, (usize, usize)> = HashMap::new();
    dims.insert("A".into(), (8, 3));
    dims.insert("B".into(), (8, 3));

    collision_repair(&layers, &mut positions, &dims, true, 4);

    // B at 0, A at 20 — no overlap, both unchanged
    assert_eq!(positions["B"], (0, 0));
    assert_eq!(positions["A"], (20, 0));
}
```

### Run and confirm failure:
```bash
cargo test collision_repair_ -- --nocapture
```

The stub does nothing, so `collision_repair_pushes_overlapping_nodes_apart` will fail (B stays at (5,0) instead of (12,0)), etc.

---

## GREEN — Minimum implementation (3.2)

```rust
fn collision_repair(
    layers: &[Vec<String>],
    draw_positions: &mut HashMap<String, (usize, usize)>,
    node_dims: &HashMap<String, (usize, usize)>,
    is_vertical: bool,
    min_gap: usize,
) {
    for layer in layers {
        if layer.len() <= 1 {
            continue;
        }

        let mut sorted: Vec<String> = layer.clone();
        sorted.sort_by_key(|id| {
            let &(x, y) = &draw_positions[id];
            if is_vertical { x } else { y }
        });

        for i in 1..sorted.len() {
            let prev_id = &sorted[i - 1];
            let curr_id = &sorted[i];
            let &(pw, ph) = &node_dims[prev_id];
            let (prev_x, prev_y) = draw_positions[prev_id];
            let (curr_x, curr_y) = draw_positions[curr_id];

            if is_vertical {
                let min_x = prev_x + pw + min_gap;
                if curr_x < min_x {
                    draw_positions.insert(curr_id.clone(), (min_x, curr_y));
                }
            } else {
                let min_y = prev_y + ph + min_gap;
                if curr_y < min_y {
                    draw_positions.insert(curr_id.clone(), (curr_x, min_y));
                }
            }
        }
    }
}
```

Run tests — all 6 should pass.

---

## REFACTOR — Clean up (3.3)

- Add doc comment explaining the algorithm and the cascading property
- Confirm `cargo test` and `cargo clippy` pass
- Commit: `feat(plan-0019): Phase 3 - Collision repair with tests`

## Acceptance Criteria
- [ ] All 6 tests pass
- [ ] Cascading pushes work correctly
- [ ] Both vertical and horizontal directions work
- [ ] Layer-internal sort handles arbitrary input ordering
- [ ] `cargo clippy` clean

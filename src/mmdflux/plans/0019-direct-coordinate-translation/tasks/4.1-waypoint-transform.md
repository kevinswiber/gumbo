# Task 4.1–4.3: Waypoint Transformation (TDD)

## Objective
Implement `transform_waypoints_direct()` — transforms dagre waypoints to ASCII coordinates using uniform scale factors, replacing the per-rank anchor interpolation mechanism.

## Location
Modify: `src/render/layout.rs` (function + tests in `#[cfg(test)] mod tests`)

---

## RED — Write failing tests (4.1)

### Stub:

```rust
use crate::dagre::types::{Point, WaypointWithRank};
use crate::graph::Edge;

fn transform_waypoints_direct(
    edge_waypoints: &HashMap<usize, Vec<WaypointWithRank>>,
    edges: &[Edge],
    dagre_min_x: f64,
    dagre_min_y: f64,
    scale_x: f64,
    scale_y: f64,
    padding: usize,
    left_label_margin: usize,
    layer_starts: &[usize],
    is_vertical: bool,
    canvas_width: usize,
    canvas_height: usize,
) -> HashMap<(String, String), Vec<(usize, usize)>> {
    HashMap::new() // stub — returns empty, tests will fail
}
```

### Tests:

```rust
#[test]
fn waypoint_transform_vertical_basic() {
    // TD layout: one edge A→C spanning 3 ranks with 1 waypoint at rank 1
    // dagre waypoint: (100.0, 75.0), dagre_min = (50.0, 25.0)
    // scale_x = 0.22, scale_y = 0.11 (typical TD values)
    // layer_starts = [1, 5, 9] (y positions for ranks 0, 1, 2)
    //
    // Expected: y = layer_starts[1] = 5
    //           x = round((100.0 - 50.0) * 0.22) + 1 + 0 = round(11.0) + 1 = 12
    use crate::graph::{Edge, Stroke, Arrow};

    let edges = vec![Edge {
        from: "A".into(), to: "C".into(),
        label: None, stroke: Stroke::Solid,
        arrow_start: Arrow::None, arrow_end: Arrow::Normal,
    }];

    let mut waypoints = HashMap::new();
    waypoints.insert(0usize, vec![
        WaypointWithRank { point: Point { x: 100.0, y: 75.0 }, rank: 1 },
    ]);

    let layer_starts = vec![1, 5, 9];
    let result = transform_waypoints_direct(
        &waypoints, &edges, 50.0, 25.0, 0.22, 0.11,
        1, 0, &layer_starts, true, 80, 20,
    );

    let key = ("A".to_string(), "C".to_string());
    assert!(result.contains_key(&key), "should have waypoints for A→C");
    let wps = &result[&key];
    assert_eq!(wps.len(), 1);
    assert_eq!(wps[0].1, 5, "y should be layer_starts[1]");
    assert_eq!(wps[0].0, 12, "x should be scaled dagre x + padding");
}

#[test]
fn waypoint_transform_horizontal_basic() {
    // LR layout: cross-axis is Y, primary is X
    // dagre waypoint: (75.0, 100.0), dagre_min = (25.0, 50.0)
    // scale_x = 0.22, scale_y = 0.67
    // layer_starts = [1, 8, 15] (x positions for ranks 0, 1, 2)
    //
    // Expected: x = layer_starts[1] = 8
    //           y = round((100.0 - 50.0) * 0.67) + 1 = round(33.5) + 1 = 35
    use crate::graph::{Edge, Stroke, Arrow};

    let edges = vec![Edge {
        from: "A".into(), to: "C".into(),
        label: None, stroke: Stroke::Solid,
        arrow_start: Arrow::None, arrow_end: Arrow::Normal,
    }];

    let mut waypoints = HashMap::new();
    waypoints.insert(0usize, vec![
        WaypointWithRank { point: Point { x: 75.0, y: 100.0 }, rank: 1 },
    ]);

    let layer_starts = vec![1, 8, 15];
    let result = transform_waypoints_direct(
        &waypoints, &edges, 25.0, 50.0, 0.22, 0.67,
        1, 0, &layer_starts, false, 40, 80,
    );

    let key = ("A".to_string(), "C".to_string());
    let wps = &result[&key];
    assert_eq!(wps[0].0, 8, "x should be layer_starts[1]");
    assert_eq!(wps[0].1, 35, "y should be scaled dagre y + padding");
}

#[test]
fn waypoint_transform_clamps_to_canvas() {
    // Waypoint that would scale beyond canvas width — should be clamped
    use crate::graph::{Edge, Stroke, Arrow};

    let edges = vec![Edge {
        from: "A".into(), to: "B".into(),
        label: None, stroke: Stroke::Solid,
        arrow_start: Arrow::None, arrow_end: Arrow::Normal,
    }];

    let mut waypoints = HashMap::new();
    waypoints.insert(0usize, vec![
        WaypointWithRank { point: Point { x: 5000.0, y: 50.0 }, rank: 0 },
    ]);

    let layer_starts = vec![1];
    let result = transform_waypoints_direct(
        &waypoints, &edges, 0.0, 0.0, 0.5, 0.5,
        1, 0, &layer_starts, true, 30, 20,
    );

    let key = ("A".to_string(), "B".to_string());
    let wps = &result[&key];
    assert!(wps[0].0 <= 29, "x clamped to canvas_width - 1");
}

#[test]
fn waypoint_transform_empty_input() {
    use crate::graph::Edge;
    let edges: Vec<Edge> = vec![];
    let waypoints: HashMap<usize, Vec<WaypointWithRank>> = HashMap::new();
    let result = transform_waypoints_direct(
        &waypoints, &edges, 0.0, 0.0, 0.2, 0.1,
        1, 0, &[], true, 80, 20,
    );
    assert!(result.is_empty());
}
```

### Run and confirm failure:
```bash
cargo test waypoint_transform_ -- --nocapture
```

The stub returns an empty map, so the first 3 tests fail at assertion (missing key or wrong length).

---

## GREEN — Minimum implementation (4.2)

```rust
fn transform_waypoints_direct(
    edge_waypoints: &HashMap<usize, Vec<WaypointWithRank>>,
    edges: &[Edge],
    dagre_min_x: f64,
    dagre_min_y: f64,
    scale_x: f64,
    scale_y: f64,
    padding: usize,
    left_label_margin: usize,
    layer_starts: &[usize],
    is_vertical: bool,
    canvas_width: usize,
    canvas_height: usize,
) -> HashMap<(String, String), Vec<(usize, usize)>> {
    let mut converted = HashMap::new();

    for (edge_idx, waypoints) in edge_waypoints {
        if let Some(edge) = edges.get(*edge_idx) {
            let key = (edge.from.clone(), edge.to.clone());

            let wps: Vec<(usize, usize)> = waypoints.iter().map(|wp| {
                let rank_idx = wp.rank as usize;

                if is_vertical {
                    let y = layer_starts.get(rank_idx).copied().unwrap_or(0);
                    let x = ((wp.point.x - dagre_min_x) * scale_x).round() as usize
                        + padding + left_label_margin;
                    let x = x.min(canvas_width.saturating_sub(1));
                    (x, y)
                } else {
                    let x = layer_starts.get(rank_idx).copied().unwrap_or(0);
                    let y = ((wp.point.y - dagre_min_y) * scale_y).round() as usize
                        + padding;
                    let y = y.min(canvas_height.saturating_sub(1));
                    (x, y)
                }
            }).collect();

            converted.insert(key, wps);
        }
    }

    converted
}
```

---

## REFACTOR — Clean up (4.3)

- Add doc comment explaining why primary axis uses `layer_starts` while cross axis uses uniform scaling
- Confirm `cargo test` and `cargo clippy` pass
- Commit: `feat(plan-0019): Phase 4 - Waypoint transformation with tests`

## Context

This replaces `map_cross_axis()` (~79 lines) and `rank_cross_anchors` construction (~28 lines). The old pipeline needed anchor interpolation because stagger transformation was applied only to nodes, creating a coordinate mismatch with waypoints. With direct translation, both nodes and waypoints use the same scaling, so they are automatically consistent.

## Acceptance Criteria
- [ ] All 4 tests pass
- [ ] Vertical and horizontal directions produce correct coordinates
- [ ] Out-of-bounds waypoints are clamped to canvas
- [ ] `cargo clippy` clean

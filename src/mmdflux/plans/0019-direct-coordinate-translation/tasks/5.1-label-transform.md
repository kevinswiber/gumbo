# Task 5.1–5.3: Label Position Transformation (TDD)

## Objective
Implement `transform_label_positions_direct()` — transforms dagre label positions to ASCII coordinates using the same scale factors applied to nodes and waypoints.

## Location
Modify: `src/render/layout.rs` (function + tests in `#[cfg(test)] mod tests`)

---

## RED — Write failing tests (5.1)

### Stub:

```rust
fn transform_label_positions_direct(
    label_positions: &HashMap<usize, Point>,
    edges: &[Edge],
    dagre_min_x: f64,
    dagre_min_y: f64,
    scale_x: f64,
    scale_y: f64,
    padding: usize,
    left_label_margin: usize,
) -> HashMap<(String, String), (usize, usize)> {
    HashMap::new() // stub — returns empty, tests will fail
}
```

### Tests:

```rust
#[test]
fn label_transform_basic_scaling() {
    // Label at dagre (150.0, 100.0), min = (50.0, 50.0)
    // scale_x = 0.22, scale_y = 0.11, padding = 1, left_label_margin = 0
    // x = round((150 - 50) * 0.22) + 1 + 0 = round(22.0) + 1 = 23
    // y = round((100 - 50) * 0.11) + 1 = round(5.5) + 1 = 7
    use crate::graph::{Edge, Stroke, Arrow};

    let edges = vec![Edge {
        from: "A".into(), to: "B".into(),
        label: Some("yes".into()), stroke: Stroke::Solid,
        arrow_start: Arrow::None, arrow_end: Arrow::Normal,
    }];

    let mut labels = HashMap::new();
    labels.insert(0usize, Point { x: 150.0, y: 100.0 });

    let result = transform_label_positions_direct(
        &labels, &edges, 50.0, 50.0, 0.22, 0.11, 1, 0,
    );

    let key = ("A".to_string(), "B".to_string());
    assert!(result.contains_key(&key));
    assert_eq!(result[&key], (23, 7));
}

#[test]
fn label_transform_with_left_margin() {
    // Same as above but with left_label_margin = 3
    // x = round((150 - 50) * 0.22) + 1 + 3 = 26
    use crate::graph::{Edge, Stroke, Arrow};

    let edges = vec![Edge {
        from: "A".into(), to: "B".into(),
        label: Some("yes".into()), stroke: Stroke::Solid,
        arrow_start: Arrow::None, arrow_end: Arrow::Normal,
    }];

    let mut labels = HashMap::new();
    labels.insert(0usize, Point { x: 150.0, y: 100.0 });

    let result = transform_label_positions_direct(
        &labels, &edges, 50.0, 50.0, 0.22, 0.11, 1, 3,
    );

    let key = ("A".to_string(), "B".to_string());
    assert_eq!(result[&key].0, 26);
}

#[test]
fn label_transform_empty_input() {
    use crate::graph::Edge;
    let edges: Vec<Edge> = vec![];
    let labels: HashMap<usize, Point> = HashMap::new();
    let result = transform_label_positions_direct(
        &labels, &edges, 0.0, 0.0, 0.2, 0.1, 1, 0,
    );
    assert!(result.is_empty());
}

#[test]
fn label_transform_skips_missing_edge() {
    // Label at edge index 5, but only 1 edge exists → label skipped
    use crate::graph::{Edge, Stroke, Arrow};

    let edges = vec![Edge {
        from: "A".into(), to: "B".into(),
        label: Some("x".into()), stroke: Stroke::Solid,
        arrow_start: Arrow::None, arrow_end: Arrow::Normal,
    }];

    let mut labels = HashMap::new();
    labels.insert(5usize, Point { x: 100.0, y: 100.0 });

    let result = transform_label_positions_direct(
        &labels, &edges, 0.0, 0.0, 0.2, 0.1, 1, 0,
    );

    assert!(result.is_empty(), "out-of-bounds edge index should be skipped");
}
```

### Run and confirm failure:
```bash
cargo test label_transform_ -- --nocapture
```

---

## GREEN — Minimum implementation (5.2)

```rust
fn transform_label_positions_direct(
    label_positions: &HashMap<usize, Point>,
    edges: &[Edge],
    dagre_min_x: f64,
    dagre_min_y: f64,
    scale_x: f64,
    scale_y: f64,
    padding: usize,
    left_label_margin: usize,
) -> HashMap<(String, String), (usize, usize)> {
    let mut converted = HashMap::new();

    for (edge_idx, pos) in label_positions {
        if let Some(edge) = edges.get(*edge_idx) {
            let key = (edge.from.clone(), edge.to.clone());
            let x = ((pos.x - dagre_min_x) * scale_x).round() as usize
                + padding + left_label_margin;
            let y = ((pos.y - dagre_min_y) * scale_y).round() as usize + padding;
            converted.insert(key, (x, y));
        }
    }

    converted
}
```

---

## REFACTOR — Clean up (5.3)

- Add doc comment
- Confirm `cargo test` and `cargo clippy` pass
- Commit: `feat(plan-0019): Phase 5 - Label position transformation with tests`

## Acceptance Criteria
- [ ] All 4 tests pass
- [ ] Left margin offset applied correctly
- [ ] Out-of-bounds edge indices handled gracefully
- [ ] `cargo clippy` clean

# Task 2.1–2.3: Scale Factor Computation (TDD)

## Objective
Implement `compute_ascii_scale_factors()` — a pure function that computes per-axis scale factors to translate dagre float coordinates to ASCII character cells.

## Location
Modify: `src/render/layout.rs` (function + tests in `#[cfg(test)] mod tests`)

---

## RED — Write failing tests (2.1)

Add the following tests to `src/render/layout.rs` in the `#[cfg(test)]` module. Also add a function stub that compiles but returns wrong values.

### Stub (compiles, returns dummy values):

```rust
fn compute_ascii_scale_factors(
    node_dims: &HashMap<String, (usize, usize)>,
    rank_sep: f64,
    node_sep: f64,
    v_spacing: usize,
    h_spacing: usize,
    is_vertical: bool,
) -> (f64, f64) {
    (0.0, 0.0) // stub — will fail all tests
}
```

### Tests:

```rust
#[test]
fn scale_factors_td_typical() {
    // Typical TD: 3 nodes with widths 9,7,11 and heights all 3
    // avg_w = 9.0, max_h = 3
    // rank_sep = 50.0, node_sep = 50.0, v_spacing = 3, h_spacing = 4
    // scale_y (primary) = (3 + 3) / (3 + 50) = 6/53 ≈ 0.1132
    // scale_x (cross)   = (9 + 4) / (9 + 50) = 13/59 ≈ 0.2203
    let mut dims = HashMap::new();
    dims.insert("A".into(), (9, 3));
    dims.insert("B".into(), (7, 3));
    dims.insert("C".into(), (11, 3));

    let (sx, sy) = compute_ascii_scale_factors(&dims, 50.0, 50.0, 3, 4, true);

    let expected_sy = 6.0 / 53.0;
    let expected_sx = 13.0 / 59.0;
    assert!((sx - expected_sx).abs() < 1e-6, "sx: got {sx}, expected {expected_sx}");
    assert!((sy - expected_sy).abs() < 1e-6, "sy: got {sy}, expected {expected_sy}");
}

#[test]
fn scale_factors_lr_direction_aware() {
    // LR with direction-aware node_sep = avg_h * 2 = 6.0
    // Nodes: widths 9,9, heights 3,3 → avg_h = 3, max_w = 9
    // scale_x (primary) = (9 + 4) / (9 + 50) = 13/59 ≈ 0.2203
    // scale_y (cross)   = (3 + 3) / (3 + 6) = 6/9 ≈ 0.6667
    let mut dims = HashMap::new();
    dims.insert("A".into(), (9, 3));
    dims.insert("B".into(), (9, 3));

    let (sx, sy) = compute_ascii_scale_factors(&dims, 50.0, 6.0, 3, 4, false);

    let expected_sx = 13.0 / 59.0;
    let expected_sy = 6.0 / 9.0;
    assert!((sx - expected_sx).abs() < 1e-6, "sx: got {sx}, expected {expected_sx}");
    assert!((sy - expected_sy).abs() < 1e-6, "sy: got {sy}, expected {expected_sy}");
}

#[test]
fn scale_factors_single_node() {
    // Single node: avg = max, no division by zero
    let mut dims = HashMap::new();
    dims.insert("X".into(), (5, 3));

    let (sx, sy) = compute_ascii_scale_factors(&dims, 50.0, 50.0, 3, 4, true);
    assert!(sx > 0.0);
    assert!(sy > 0.0);
    assert!(sx.is_finite());
    assert!(sy.is_finite());
}

#[test]
fn scale_factors_empty_nodes() {
    // Edge case: no nodes — should not panic, return finite positive values
    let dims: HashMap<String, (usize, usize)> = HashMap::new();
    let (sx, sy) = compute_ascii_scale_factors(&dims, 50.0, 50.0, 3, 4, true);
    assert!(sx.is_finite());
    assert!(sy.is_finite());
}
```

### Run and confirm failure:
```bash
cargo test scale_factors_ -- --nocapture
```

All 4 tests should fail: the stub returns `(0.0, 0.0)` which won't match expected values (and `0.0 > 0.0` is false).

---

## GREEN — Minimum implementation (2.2)

Replace the stub with:

```rust
fn compute_ascii_scale_factors(
    node_dims: &HashMap<String, (usize, usize)>,
    rank_sep: f64,
    node_sep: f64,
    v_spacing: usize,
    h_spacing: usize,
    is_vertical: bool,
) -> (f64, f64) {
    let (total_w, total_h, max_w, max_h, count) = node_dims.values().fold(
        (0usize, 0usize, 0usize, 0usize, 0usize),
        |(tw, th, mw, mh, c), &(w, h)| (tw + w, th + h, mw.max(w), mh.max(h), c + 1),
    );
    let count_f = count.max(1) as f64;
    let avg_w = total_w as f64 / count_f;
    let avg_h = total_h as f64 / count_f;

    if is_vertical {
        let scale_primary = (max_h as f64 + v_spacing as f64) / (max_h as f64 + rank_sep);
        let scale_cross = (avg_w + h_spacing as f64) / (avg_w + node_sep);
        (scale_cross, scale_primary)
    } else {
        let scale_primary = (max_w as f64 + h_spacing as f64) / (max_w as f64 + rank_sep);
        let scale_cross = (avg_h + v_spacing as f64) / (avg_h + node_sep);
        (scale_primary, scale_cross)
    }
}
```

Run tests — all 4 should pass. The empty-nodes case returns `(h_spacing / node_sep, v_spacing / rank_sep)` which is finite and positive (assuming non-zero config).

---

## REFACTOR — Clean up (2.3)

- Add a doc comment to the function explaining the formula and axis conventions
- Confirm `cargo test` and `cargo clippy` pass
- Commit: `feat(plan-0019): Phase 2 - Scale factor computation with tests`

## Acceptance Criteria
- [ ] All 4 tests pass
- [ ] Function handles edge cases (single node, empty map)
- [ ] `cargo clippy` clean

# Task 2.1: Add Collision Avoidance Safety Net for Precomputed Labels

## Objective

Route precomputed label positions through `find_safe_label_position()` before drawing, so that any residual overlaps (from rounding errors, unusual node sizes, or future layout changes) are caught and resolved. This is a defensive safety net â€” it should be a no-op when Phase 1's fix produces correct positions.

## Location

Modify: `src/render/edge.rs` â€” `render_all_edges_with_labels()`, around lines 740-741 (precomputed label path)

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

This is harder to test in isolation since Phase 1 should fix the known overlaps. Write a test that verifies the precomputed path handles an edge case where the label position is marginally inside a node boundary:

```rust
#[test]
fn precomputed_label_avoids_node_overlap() {
    // This test verifies that even if a precomputed label position
    // falls on a node boundary, collision avoidance shifts it.
    // The concrete test uses git_workflow.mmd and checks no label
    // characters overlap with node box-drawing characters.
    let output = render_fixture("git_workflow.mmd");

    // The label "git commit" should not have any characters
    // appearing inside the Staging Area node's box
    // (i.e., no partial label fragments like "mmit" adjacent to node border)
    assert!(
        output.contains("git commit"),
        "Label should be fully visible, not clipped:\n{output}"
    );
}
```

**What the failing test asserts:** Precomputed labels don't get clipped by node boundaries.
**Expected failure reason:** If Phase 1 is already applied, this test should pass. The real value is as a safety net for future changes. Consider also adding a unit test for `find_safe_label_position` with a position that collides.

### ðŸŸ¢ Green: Minimal Implementation

In `render_all_edges_with_labels()`, change the precomputed label drawing from:

```rust
} else if let Some(&(pre_x, pre_y)) = precomputed {
    draw_label_at_position(canvas, label, pre_x, pre_y);
}
```

to:

```rust
} else if let Some(&(pre_x, pre_y)) = precomputed {
    let label_len = label.len();
    let base_x = pre_x.saturating_sub(label_len / 2);
    let (safe_x, safe_y) = find_safe_label_position(
        canvas,
        base_x,
        pre_y,
        label_len,
        diagram_direction,
        &placed_labels,
        false, // don't check edge collision â€” label sits on its edge
    );
    // Draw at the safe position
    for (i, ch) in label.chars().enumerate() {
        let cx = safe_x + i;
        if cx < canvas.width() && safe_y < canvas.height() {
            let cell = canvas.get(cx, safe_y);
            if !cell.is_node {
                canvas.set_char(cx, safe_y, ch);
            }
        }
    }
}
```

Note: Check whether `draw_label_at_position()` can be reused here or if inline drawing is cleaner to avoid double-centering. The key change is calling `find_safe_label_position()` before writing.

### ðŸ”µ Refactor: Clean Up

- If `draw_label_at_position()` is no longer called, consider removing it or keeping it as a utility
- Ensure the precomputed label is added to `placed_labels` after drawing (this should already happen downstream)
- Add a comment explaining this is a defensive measure, not the primary fix
- Run full test suite

## Context

The precomputed label path was intentionally designed without collision avoidance (see [Research 0022 Q3](../../../research/0022-lr-forward-label-overlap/q3-collision-avoidance-analysis.md)). The design assumes dagre positions are correct by construction. Adding `find_safe_label_position()` preserves this design â€” when positions are correct, the function returns the base position unchanged (no-op). It only intervenes when a position actually collides.

`find_safe_label_position()` tries up to 12 alternative positions (3 cells in each cardinal direction) and falls back to the base position if no safe alternative exists.

## Acceptance Criteria

- [ ] Precomputed label positions pass through `find_safe_label_position()` before drawing
- [ ] No double-centering issue (centering applied once, not twice)
- [ ] Precomputed labels still added to `placed_labels` for label-label deconfliction
- [ ] Full `cargo test` passes
- [ ] git_workflow.mmd labels still fully visible (no regression from Phase 1)

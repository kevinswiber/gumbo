# Task 3.1: DiagramType Enum and Detection Function

## Objective

Add a `DiagramType` enum and `detect_diagram_type()` function that scans the input's first keyword to determine which parser to invoke. This is the infrastructure needed to support multiple diagram types.

## Location

Modify: `src/parser/mod.rs`

## TDD Phases

### Red: Write Failing Tests

```rust
#[test]
fn test_detect_flowchart_graph() {
    assert_eq!(detect_diagram_type("graph TD\nA-->B\n"), Some(DiagramType::Flowchart));
}

#[test]
fn test_detect_flowchart_keyword() {
    assert_eq!(detect_diagram_type("flowchart LR\nA-->B\n"), Some(DiagramType::Flowchart));
}

#[test]
fn test_detect_pie() {
    assert_eq!(detect_diagram_type("pie\n\"ash\": 100\n"), Some(DiagramType::Pie));
}

#[test]
fn test_detect_info() {
    assert_eq!(detect_diagram_type("info\nshowInfo\n"), Some(DiagramType::Info));
}

#[test]
fn test_detect_packet() {
    assert_eq!(detect_diagram_type("packet-beta\n0-7: \"Header\"\n"), Some(DiagramType::Packet));
}

#[test]
fn test_detect_packet_short() {
    assert_eq!(detect_diagram_type("packet\n0-7: \"Header\"\n"), Some(DiagramType::Packet));
}

#[test]
fn test_detect_skips_whitespace() {
    assert_eq!(detect_diagram_type("  \n  graph TD\nA-->B\n"), Some(DiagramType::Flowchart));
}

#[test]
fn test_detect_skips_comments() {
    assert_eq!(detect_diagram_type("%% comment\ngraph TD\nA-->B\n"), Some(DiagramType::Flowchart));
}

#[test]
fn test_detect_unknown() {
    assert_eq!(detect_diagram_type("sequence\nA->>B: hello\n"), None);
}
```

**What the failing tests assert:** The detection function correctly identifies diagram types from the first significant keyword.
**Expected failure reason:** `DiagramType` and `detect_diagram_type()` don't exist yet.

### Green: Minimal Implementation

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DiagramType {
    Flowchart,
    Pie,
    Info,
    Packet,
}

pub fn detect_diagram_type(input: &str) -> Option<DiagramType> {
    // Skip leading whitespace, blank lines, and %% comment lines
    let first_word = input.lines()
        .map(|l| l.trim())
        .find(|l| !l.is_empty() && !l.starts_with("%%"))
        .and_then(|l| l.split_whitespace().next())?;

    match first_word {
        "graph" | "flowchart" => Some(DiagramType::Flowchart),
        "pie" => Some(DiagramType::Pie),
        "info" => Some(DiagramType::Info),
        "packet" | "packet-beta" => Some(DiagramType::Packet),
        _ => None,
    }
}
```

### Refactor: Clean Up

- Extract keyword mapping to a const array if it grows
- Consider case-insensitive matching for robustness

## Context

Mermaid identifies diagram types by the first keyword. The upstream detection logic is in `packages/mermaid/src/diagram-api/detectType.ts`. We only need to support the types we have parsers for; unknown types return `None` and the CLI can report "unsupported diagram type."

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] DiagramType enum and detect function implemented
- [ ] Handles leading whitespace and comments
- [ ] Returns None for unsupported types
- [ ] All existing tests unaffected

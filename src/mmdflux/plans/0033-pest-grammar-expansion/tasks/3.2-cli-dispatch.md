# Task 3.2: Update CLI to Dispatch by Diagram Type

## Objective

Update the CLI entry point to use `detect_diagram_type()` and dispatch to the correct parser. Non-flowchart types return a clear "unsupported" message until their parsers are wired in (Tasks 4.1-4.3).

## Location

Modify: `src/main.rs` (or `src/lib.rs` if render_input lives there)

## TDD Phases

### Red: Write Failing Tests

```rust
#[test]
fn test_cli_dispatches_flowchart() {
    // Existing behavior should still work
    let output = render("graph TD\nA-->B\n");
    assert!(output.contains("A"));
}

#[test]
fn test_cli_reports_unsupported_diagram() {
    let result = try_render("sequence\nA->>B: hello\n");
    assert!(result.is_err());
    // Error message should mention unsupported
}

#[test]
fn test_cli_dispatches_pie_placeholder() {
    let result = try_render("pie\n\"ash\": 100\n");
    // Initially this should error with "unsupported" until pie parser is wired
    assert!(result.is_err());
}
```

**What the failing test asserts:** The CLI detects diagram type before parsing and gives appropriate errors for unsupported types.
**Expected failure reason:** Currently the CLI always tries flowchart parsing, so non-flowchart inputs produce confusing parse errors instead of "unsupported diagram type."

### Green: Minimal Implementation

```rust
fn render_input(input: &str, config: &Config) -> Result<String, Error> {
    match detect_diagram_type(input) {
        Some(DiagramType::Flowchart) => render_flowchart(input, config),
        Some(dtype) => Err(Error::UnsupportedDiagram(dtype)),
        None => Err(Error::UnknownDiagram),
    }
}
```

### Refactor: Clean Up

- Ensure error messages are user-friendly
- Update help text if needed to list supported diagram types

## Acceptance Criteria

- [ ] Failing test written and confirmed red
- [ ] CLI dispatches by diagram type
- [ ] Unknown/unsupported types produce clear errors
- [ ] Existing flowchart functionality unaffected

# Task 4.2: Pie Pest Grammar and Parser

## Objective

Implement the pie chart diagram parser. This introduces shared concepts: STRING terminal, NUMBER terminal, and sections with labels and values.

## Location

Create: `src/parser/pie_grammar.pest`
Create: `src/parser/pie.rs`
Modify: `src/parser/mod.rs` (add `pub mod pie;`)
Modify: CLI dispatch (wire pie parser)

## TDD Phases

### Red: Write Failing Tests

```rust
#[test]
fn test_parse_pie_single_section() {
    let result = parse_pie("pie\n\"ash\": 100\n").unwrap();
    assert_eq!(result.sections.len(), 1);
    assert_eq!(result.sections[0].label, "ash");
    assert_eq!(result.sections[0].value, 100.0);
}

#[test]
fn test_parse_pie_multiple_sections() {
    let result = parse_pie("pie\n\"ash\" : 60\n\"bat\" : 40\n").unwrap();
    assert_eq!(result.sections.len(), 2);
}

#[test]
fn test_parse_pie_show_data() {
    let result = parse_pie("pie showData\n\"ash\" : 60\n\"bat\" : 40\n").unwrap();
    assert!(result.show_data);
}

#[test]
fn test_parse_pie_title() {
    let result = parse_pie("pie title A 60/40 pie\n\"ash\" : 60\n\"bat\" : 40\n").unwrap();
    assert_eq!(result.title.as_deref(), Some("A 60/40 pie"));
}

#[test]
fn test_parse_pie_float_values() {
    let result = parse_pie("pie\n\"a\": 10.5\n\"b\": 20.3\n").unwrap();
    assert!((result.sections[0].value - 10.5).abs() < f64::EPSILON);
}

#[test]
fn test_parse_pie_with_comments() {
    let result = parse_pie("pie\n%% a comment\n\"ash\" : 60\n").unwrap();
    assert_eq!(result.sections.len(), 1);
}

#[test]
fn test_parse_pie_single_quoted_labels() {
    let result = parse_pie("pie\n'ash': 100\n").unwrap();
    assert_eq!(result.sections[0].label, "ash");
}
```

**What the failing tests assert:** Pie diagrams with sections, titles, showData, float values, and comments all parse correctly.
**Expected failure reason:** `parse_pie` doesn't exist yet.

### Green: Minimal Implementation

**`pie_grammar.pest`:**
```pest
WHITESPACE = _{ " " | "\t" }
NEWLINE_CHAR = _{ "\r"? ~ "\n" }
comment = _{ "%%" ~ (!NEWLINE_CHAR ~ ANY)* }

pie_keyword = { ^"pie" }
show_data = { ^"showData" }

// String terminals (shared pattern)
string_double = @{ "\"" ~ (!"\"" ~ !"\n" ~ ANY | "\\\"")* ~ "\"" }
string_single = @{ "'" ~ (!"'" ~ !"\n" ~ ANY | "\\'")* ~ "'" }
string = { string_double | string_single }

// Number terminal (int or float, optional negative)
float = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
integer = @{ "-"? ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) }
number = @{ float | integer }

// Title
title_keyword = _{ "title" }
title_text = @{ (!NEWLINE_CHAR ~ ANY)+ }
title_stmt = { title_keyword ~ title_text }

// Sections
pie_section = { string ~ ":" ~ number }

pie = {
    SOI ~ NEWLINE_CHAR* ~
    pie_keyword ~ show_data? ~ NEWLINE_CHAR ~
    (title_stmt ~ NEWLINE_CHAR | pie_section ~ NEWLINE_CHAR | comment ~ NEWLINE_CHAR | NEWLINE_CHAR)* ~
    EOI
}
```

**`pie.rs`:**
```rust
#[derive(Debug, Clone)]
pub struct Pie {
    pub show_data: bool,
    pub title: Option<String>,
    pub sections: Vec<PieSection>,
}

#[derive(Debug, Clone)]
pub struct PieSection {
    pub label: String,
    pub value: f64,
}

pub fn parse_pie(input: &str) -> Result<Pie, ParseError> { ... }
```

### Refactor: Clean Up

- Ensure string unquoting (stripping surrounding quotes) is consistent
- Wire into CLI dispatch
- Consider: should the Pie struct implement Display for simple text output?

## Context

Upstream Langium grammar: `~/src/mermaid/packages/parser/src/language/pie/pie.langium` (20 lines).
Upstream tests: `~/src/mermaid/packages/mermaid/src/diagrams/pie/pie.spec.ts`.

The Langium grammar rejects leading zeros and `+`-prefixed numbers (see [Q3: Syntax Differences](../../../research/0026-mermaid-grammar-reference/q3-syntax-differences.md)). The Pest grammar should match this strictness.

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] Grammar file created and compiles
- [ ] Parser handles sections, title, showData, comments, float values
- [ ] Both single and double quoted strings work
- [ ] Wired into CLI dispatch
- [ ] Number parsing matches Langium strictness (no leading zeros, no `+` prefix)

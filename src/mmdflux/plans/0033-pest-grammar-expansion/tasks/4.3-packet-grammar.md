# Task 4.3: Packet Pest Grammar and Parser

## Objective

Implement the packet diagram parser. This introduces bit-range syntax and relative-bits blocks.

## Location

Create: `src/parser/packet_grammar.pest`
Create: `src/parser/packet.rs`
Modify: `src/parser/mod.rs` (add `pub mod packet;`)
Modify: CLI dispatch (wire packet parser)

## TDD Phases

### Red: Write Failing Tests

```rust
#[test]
fn test_parse_packet_range_block() {
    let result = parse_packet("packet-beta\n0-7: \"Header\"\n").unwrap();
    assert_eq!(result.blocks.len(), 1);
    assert!(matches!(&result.blocks[0], PacketBlock::Range { start: 0, end: Some(7), label } if label == "Header"));
}

#[test]
fn test_parse_packet_single_bit() {
    let result = parse_packet("packet-beta\n0: \"Flag\"\n").unwrap();
    assert!(matches!(&result.blocks[0], PacketBlock::Range { start: 0, end: None, .. }));
}

#[test]
fn test_parse_packet_relative_bits() {
    let result = parse_packet("packet-beta\n+8: \"Data\"\n").unwrap();
    assert!(matches!(&result.blocks[0], PacketBlock::Relative { bits: 8, .. }));
}

#[test]
fn test_parse_packet_multiple_blocks() {
    let input = "packet-beta\n0-7: \"Header\"\n8-15: \"Payload\"\n+16: \"Padding\"\n";
    let result = parse_packet(input).unwrap();
    assert_eq!(result.blocks.len(), 3);
}

#[test]
fn test_parse_packet_with_title() {
    let result = parse_packet("packet-beta\ntitle My Packet\n0-7: \"Header\"\n").unwrap();
    assert_eq!(result.title.as_deref(), Some("My Packet"));
}

#[test]
fn test_parse_packet_short_keyword() {
    let result = parse_packet("packet\n0-7: \"Header\"\n").unwrap();
    assert_eq!(result.blocks.len(), 1);
}
```

**What the failing tests assert:** Packet diagrams with range blocks, single-bit blocks, relative blocks, titles, and both keyword variants parse correctly.
**Expected failure reason:** `parse_packet` doesn't exist yet.

### Green: Minimal Implementation

**`packet_grammar.pest`:**
```pest
WHITESPACE = _{ " " | "\t" }
NEWLINE_CHAR = _{ "\r"? ~ "\n" }
comment = _{ "%%" ~ (!NEWLINE_CHAR ~ ANY)* }

packet_keyword = { ^"packet" ~ ("-beta")? }

int = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
string_double = @{ "\"" ~ (!"\"" ~ !"\n" ~ ANY | "\\\"")* ~ "\"" }
string_single = @{ "'" ~ (!"'" ~ !"\n" ~ ANY | "\\'")* ~ "'" }
string = { string_double | string_single }

title_keyword = _{ "title" }
title_text = @{ (!NEWLINE_CHAR ~ ANY)+ }
title_stmt = { title_keyword ~ title_text }

bit_range = { int ~ "-" ~ int }
bit_single = { int }
bit_relative = { "+" ~ int }
bit_spec = { bit_range | bit_relative | bit_single }

packet_block = { bit_spec ~ ":" ~ string }

packet = {
    SOI ~ NEWLINE_CHAR* ~
    packet_keyword ~ NEWLINE_CHAR ~
    (title_stmt ~ NEWLINE_CHAR | packet_block ~ NEWLINE_CHAR | comment ~ NEWLINE_CHAR | NEWLINE_CHAR)* ~
    EOI
}
```

**`packet.rs`:**
```rust
#[derive(Debug, Clone)]
pub struct Packet {
    pub title: Option<String>,
    pub blocks: Vec<PacketBlock>,
}

#[derive(Debug, Clone)]
pub enum PacketBlock {
    Range { start: u32, end: Option<u32>, label: String },
    Relative { bits: u32, label: String },
}

pub fn parse_packet(input: &str) -> Result<Packet, ParseError> { ... }
```

### Refactor: Clean Up

- Wire into CLI dispatch
- Ensure `bit_range` vs `bit_single` disambiguation works correctly (range has `-`, single doesn't)

## Context

Upstream Langium grammar: `~/src/mermaid/packages/parser/src/language/packet/packet.langium` (21 lines).

The `packet-beta` keyword is the canonical form; `packet` is also accepted. The Langium grammar requires integer values for bit positions (no floats).

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] Grammar file created and compiles
- [ ] Parser handles range, single-bit, and relative blocks
- [ ] Both `packet` and `packet-beta` keywords work
- [ ] Title support works
- [ ] Wired into CLI dispatch

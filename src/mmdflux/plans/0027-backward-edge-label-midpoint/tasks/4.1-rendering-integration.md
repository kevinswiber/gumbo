# Task 4.1: Wire Up Path-Midpoint for Backward Edge Labels

## Objective

Modify `render_all_edges_with_labels()` to use `calc_label_position()` for backward edges instead of dagre's precomputed label positions. Add label offset logic so labels sit beside the edge line, not on it.

## Location

Modify: `~/src/mmdflux-label-dummy/src/render/edge.rs` (primary)
Modify: `~/src/mmdflux-label-dummy/src/render/layout.rs` (strip precomputed positions for backward edges)

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

Add a test that renders a backward edge with a label and verifies the label appears near the routed path (not at the dagre-computed position):

```rust
#[test]
fn backward_edge_label_near_routed_path_td() {
    let output = render_input("graph TD\n    A --> B\n    B -->|retry| A");
    assert!(output.contains("retry"), "Label should appear in output:\n{output}");

    // In TD layout, backward edges route to the right of nodes.
    // The label should appear at a column position to the right of both nodes,
    // not between or inside the nodes.
    let lines: Vec<&str> = output.lines().collect();
    let node_a_line = lines.iter().find(|l| l.contains("A")).unwrap();
    let node_a_right = node_a_line.rfind('A').unwrap_or(0);

    let retry_line = lines.iter().find(|l| l.contains("retry")).unwrap();
    let retry_col = retry_line.find("retry").unwrap();

    // "retry" should be to the right of the node content
    assert!(
        retry_col > node_a_right,
        "Label 'retry' at col {retry_col} should be right of node A ending at col {node_a_right}\n{output}"
    );
}
```

**What the test asserts:** The backward edge label "retry" appears to the right of the nodes (where the backward edge routes in TD layout).
**Expected failure reason:** Currently the label is placed at the dagre-computed cross-axis position, which is between the nodes.

### ðŸŸ¢ Green: Minimal Implementation

**In `render_all_edges_with_labels()` (edge.rs ~line 679-701):**

Change the label placement logic to check `is_backward` first:

```rust
let placed = if routed.is_backward {
    // For backward edges, compute label position from actual routed path
    if let Some(midpoint) = calc_label_position(&routed.segments) {
        let (label_x, label_y) = offset_label_from_path(
            &midpoint, &routed.segments, label_len,
        );
        draw_label_at_position(canvas, label, label_x, label_y)
    } else {
        // Fallback: use heuristic placement
        draw_edge_label_with_tracking(
            canvas, routed, label, diagram_direction, &placed_labels,
        )
    }
} else if let Some(&(pre_x, pre_y)) = precomputed {
    draw_label_at_position(canvas, label, pre_x, pre_y)
} else {
    draw_edge_label_with_tracking(
        canvas, routed, label, diagram_direction, &placed_labels,
    )
};
```

**Add `offset_label_from_path()` helper:**

```rust
/// Offset a label position from the path midpoint so it sits beside the edge.
///
/// Determines which segment type the midpoint falls on and offsets accordingly:
/// - Vertical segment: label to the right (+2 cells for gap)
/// - Horizontal segment: label above (-1 cell)
fn offset_label_from_path(
    midpoint: &Point,
    segments: &[Segment],
    label_len: usize,
) -> (usize, usize) {
    // Find which segment contains the midpoint
    let total_length: usize = segments.iter().map(|s| s.length()).sum();
    let target = total_length / 2;
    let mut accumulated = 0;
    let mut midpoint_on_vertical = true;

    for seg in segments {
        let seg_len = seg.length();
        if accumulated + seg_len >= target {
            midpoint_on_vertical = matches!(seg, Segment::Vertical { .. });
            break;
        }
        accumulated += seg_len;
    }

    if midpoint_on_vertical {
        // Place label to the right of the vertical edge line
        (midpoint.x + 2, midpoint.y)
    } else {
        // Place label above the horizontal edge line, centered
        let label_x = midpoint.x.saturating_sub(label_len / 2);
        (label_x, midpoint.y.saturating_sub(1))
    }
}
```

**In `layout.rs`, strip precomputed label positions for backward edges:**

After the existing backward edge waypoint stripping (~line 474-483), also remove precomputed label positions for backward edges so they don't interfere:

```rust
// Strip precomputed label positions for backward edges.
// The render phase will compute them from the actual routed path.
// (Add this logic in compute_layout() or wherever label_positions are finalized)
```

Alternatively, the check in `render_all_edges_with_labels()` already handles this by checking `is_backward` first, so stripping in layout.rs is optional but cleaner.

### ðŸ”µ Refactor: Clean Up

- Extract the "find segment at offset" logic into a shared helper if duplicated between `calc_label_position()` and `offset_label_from_path()`.
- Consider adding a `SegmentOrientation` enum return from `calc_label_position()` to avoid re-walking segments in `offset_label_from_path()`.
- Add bounds checking: if the offset position would place the label outside canvas bounds, clamp to canvas edges.
- Check if the label collides with a node at the offset position; if so, try the opposite side.

## Context

- `render_all_edges_with_labels()` is at `edge.rs:657-708`.
- `draw_label_at_position()` already exists for precomputed labels.
- `draw_edge_label_with_tracking()` is the fallback heuristic function.
- The `routed.is_backward` field comes from Task 3.1.
- `calc_label_position()` comes from Task 2.1.
- Label offset direction: For TD/BT backward edges, the synthetic route goes to the right of nodes, so +2 cells to the right places the label outside the edge path. For LR/RL backward edges, the route goes below, so -1 cell above.

## Acceptance Criteria

- [ ] Failing test written and confirmed red
- [ ] Backward edge labels use path-midpoint instead of dagre precomputed position
- [ ] Labels are offset from the edge line (not overlapping)
- [ ] Forward edge labels are unchanged (no regression)
- [ ] Code refactored with tests still green

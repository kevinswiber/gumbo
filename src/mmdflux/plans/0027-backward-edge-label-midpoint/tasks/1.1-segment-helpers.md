# Task 1.1: Add Segment Helper Methods

## Objective

Add `length()`, `point_at_offset()`, `start_point()`, and `end_point()` methods to the `Segment` enum in `router.rs`. These are the building blocks for the path-midpoint algorithm.

## Location

Modify: `~/src/mmdflux-label-dummy/src/render/router.rs`

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

Add a test module at the bottom of `router.rs` (or in the existing `#[cfg(test)]` block):

```rust
#[cfg(test)]
mod segment_helper_tests {
    use super::*;

    #[test]
    fn vertical_segment_length() {
        let seg = Segment::Vertical { x: 5, y_start: 10, y_end: 20 };
        assert_eq!(seg.length(), 10);
    }

    #[test]
    fn vertical_segment_length_reversed() {
        let seg = Segment::Vertical { x: 5, y_start: 20, y_end: 10 };
        assert_eq!(seg.length(), 10);
    }

    #[test]
    fn horizontal_segment_length() {
        let seg = Segment::Horizontal { y: 3, x_start: 5, x_end: 15 };
        assert_eq!(seg.length(), 10);
    }

    #[test]
    fn horizontal_segment_length_reversed() {
        let seg = Segment::Horizontal { y: 3, x_start: 15, x_end: 5 };
        assert_eq!(seg.length(), 10);
    }

    #[test]
    fn zero_length_segment() {
        let seg = Segment::Vertical { x: 5, y_start: 10, y_end: 10 };
        assert_eq!(seg.length(), 0);
    }

    #[test]
    fn start_point_vertical() {
        let seg = Segment::Vertical { x: 5, y_start: 10, y_end: 20 };
        assert_eq!(seg.start_point(), Point { x: 5, y: 10 });
    }

    #[test]
    fn end_point_vertical() {
        let seg = Segment::Vertical { x: 5, y_start: 10, y_end: 20 };
        assert_eq!(seg.end_point(), Point { x: 5, y: 20 });
    }

    #[test]
    fn start_point_horizontal() {
        let seg = Segment::Horizontal { y: 3, x_start: 5, x_end: 15 };
        assert_eq!(seg.start_point(), Point { x: 5, y: 3 });
    }

    #[test]
    fn end_point_horizontal() {
        let seg = Segment::Horizontal { y: 3, x_start: 5, x_end: 15 };
        assert_eq!(seg.end_point(), Point { x: 15, y: 3 });
    }

    #[test]
    fn point_at_offset_zero_is_start() {
        let seg = Segment::Vertical { x: 5, y_start: 10, y_end: 20 };
        assert_eq!(seg.point_at_offset(0), seg.start_point());
    }

    #[test]
    fn point_at_offset_length_is_end() {
        let seg = Segment::Vertical { x: 5, y_start: 10, y_end: 20 };
        assert_eq!(seg.point_at_offset(seg.length()), seg.end_point());
    }

    #[test]
    fn point_at_offset_midpoint_vertical() {
        let seg = Segment::Vertical { x: 5, y_start: 10, y_end: 20 };
        assert_eq!(seg.point_at_offset(5), Point { x: 5, y: 15 });
    }

    #[test]
    fn point_at_offset_midpoint_horizontal() {
        let seg = Segment::Horizontal { y: 3, x_start: 0, x_end: 10 };
        assert_eq!(seg.point_at_offset(5), Point { x: 5, y: 3 });
    }

    #[test]
    fn point_at_offset_reversed_vertical() {
        let seg = Segment::Vertical { x: 5, y_start: 20, y_end: 10 };
        assert_eq!(seg.point_at_offset(5), Point { x: 5, y: 15 });
    }

    #[test]
    fn point_at_offset_reversed_horizontal() {
        let seg = Segment::Horizontal { y: 3, x_start: 15, x_end: 5 };
        assert_eq!(seg.point_at_offset(5), Point { x: 10, y: 3 });
    }

    #[test]
    fn point_at_offset_clamped_beyond_length() {
        let seg = Segment::Vertical { x: 5, y_start: 10, y_end: 20 };
        assert_eq!(seg.point_at_offset(100), seg.end_point());
    }

    #[test]
    fn point_at_offset_zero_length_segment() {
        let seg = Segment::Vertical { x: 5, y_start: 10, y_end: 10 };
        assert_eq!(seg.point_at_offset(0), Point { x: 5, y: 10 });
    }
}
```

**What the failing tests assert:** Each test defines the expected behavior of a Segment helper method.
**Expected failure reason:** Methods `length()`, `start_point()`, `end_point()`, and `point_at_offset()` do not exist yet on `Segment`.

### ðŸŸ¢ Green: Minimal Implementation

Add an `impl Segment` block:

```rust
impl Segment {
    /// Manhattan length of this segment.
    pub fn length(&self) -> usize {
        match self {
            Segment::Vertical { y_start, y_end, .. } => y_start.abs_diff(*y_end),
            Segment::Horizontal { x_start, x_end, .. } => x_start.abs_diff(*x_end),
        }
    }

    /// Start point of this segment.
    pub fn start_point(&self) -> Point {
        match self {
            Segment::Vertical { x, y_start, .. } => Point { x: *x, y: *y_start },
            Segment::Horizontal { y, x_start, .. } => Point { x: *x_start, y: *y },
        }
    }

    /// End point of this segment.
    pub fn end_point(&self) -> Point {
        match self {
            Segment::Vertical { x, y_end, .. } => Point { x: *x, y: *y_end },
            Segment::Horizontal { y, x_end, .. } => Point { x: *x_end, y: *y },
        }
    }

    /// Point at a given offset from start along the segment direction.
    /// Clamps to segment bounds if offset exceeds length.
    pub fn point_at_offset(&self, offset: usize) -> Point {
        match self {
            Segment::Vertical { x, y_start, y_end } => {
                let clamped = offset.min(y_start.abs_diff(*y_end));
                let y = if *y_end >= *y_start {
                    y_start + clamped
                } else {
                    y_start - clamped
                };
                Point { x: *x, y }
            }
            Segment::Horizontal { y, x_start, x_end } => {
                let clamped = offset.min(x_start.abs_diff(*x_end));
                let x = if *x_end >= *x_start {
                    x_start + clamped
                } else {
                    x_start - clamped
                };
                Point { x, y: *y }
            }
        }
    }
}
```

### ðŸ”µ Refactor: Clean Up

- Check if `Point` derives `PartialEq` and `Debug` (needed for `assert_eq!` in tests); add if missing.
- Consider whether `start_point()` / `end_point()` should return references or copies (Point is Copy, so copies are fine).

## Context

- `Point` is defined in `src/dagre/types.rs` with `x: usize, y: usize` fields. Ensure it derives `PartialEq, Debug`.
- The `Segment` enum is at `router.rs:40-54`. Place the `impl` block immediately after the enum definition.
- These methods are pure functions with no side effects â€” ideal for unit testing.

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] All Segment helper methods implemented
- [ ] All tests pass
- [ ] Code refactored with tests still green

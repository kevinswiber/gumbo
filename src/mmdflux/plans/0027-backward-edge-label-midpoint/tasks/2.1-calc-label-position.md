# Task 2.1: Implement calc_label_position()

## Objective

Add a `calc_label_position()` function that walks a path of orthogonal segments by Manhattan distance and returns the point at the 50% mark. This mirrors mermaid's `calcLabelPosition()` adapted for the ASCII grid.

## Location

New function in: `~/src/mmdflux-label-dummy/src/render/edge.rs`

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

Add tests in `edge.rs` (or a `#[cfg(test)]` module):

```rust
#[cfg(test)]
mod calc_label_position_tests {
    use super::*;
    use crate::render::router::Segment;
    use crate::dagre::types::Point;

    #[test]
    fn empty_segments_returns_none() {
        assert_eq!(calc_label_position(&[]), None);
    }

    #[test]
    fn single_vertical_segment_returns_midpoint() {
        let segments = vec![
            Segment::Vertical { x: 5, y_start: 10, y_end: 20 },
        ];
        assert_eq!(calc_label_position(&segments), Some(Point { x: 5, y: 15 }));
    }

    #[test]
    fn single_horizontal_segment_returns_midpoint() {
        let segments = vec![
            Segment::Horizontal { y: 3, x_start: 0, x_end: 10 },
        ];
        assert_eq!(calc_label_position(&segments), Some(Point { x: 5, y: 3 }));
    }

    #[test]
    fn l_path_midpoint_at_corner() {
        // V(x=5, y 0->6) + H(y=6, x 5->11) = total 12, midpoint at 6
        // offset 6 in first segment (len 6) -> end of V segment
        let segments = vec![
            Segment::Vertical { x: 5, y_start: 0, y_end: 6 },
            Segment::Horizontal { y: 6, x_start: 5, x_end: 11 },
        ];
        assert_eq!(calc_label_position(&segments), Some(Point { x: 5, y: 6 }));
    }

    #[test]
    fn z_path_midpoint_on_middle_segment() {
        // V(x=5, y 0->4) + H(y=4, x 5->15) + V(x=15, y 4->8)
        // Lengths: 4 + 10 + 4 = 18, midpoint at 9
        // First segment uses 4 -> remaining 5 into H segment -> Point(5+5, 4) = (10, 4)
        let segments = vec![
            Segment::Vertical { x: 5, y_start: 0, y_end: 4 },
            Segment::Horizontal { y: 4, x_start: 5, x_end: 15 },
            Segment::Vertical { x: 15, y_start: 4, y_end: 8 },
        ];
        assert_eq!(calc_label_position(&segments), Some(Point { x: 10, y: 4 }));
    }

    #[test]
    fn zero_length_path_returns_start() {
        let segments = vec![
            Segment::Vertical { x: 5, y_start: 10, y_end: 10 },
        ];
        assert_eq!(calc_label_position(&segments), Some(Point { x: 5, y: 10 }));
    }

    #[test]
    fn odd_total_length_rounds_down() {
        // Single segment length 7, midpoint at offset 3
        let segments = vec![
            Segment::Vertical { x: 5, y_start: 0, y_end: 7 },
        ];
        assert_eq!(calc_label_position(&segments), Some(Point { x: 5, y: 3 }));
    }

    #[test]
    fn backward_edge_typical_shape() {
        // Typical backward edge in TD: H(right) + V(down) + H(left)
        // H(y=3, x 20->25) + V(x=25, y 3->15) + H(y=15, x 25->20)
        // Lengths: 5 + 12 + 5 = 22, midpoint at 11
        // First H uses 5 -> remaining 6 into V -> Point(25, 3+6) = (25, 9)
        let segments = vec![
            Segment::Horizontal { y: 3, x_start: 20, x_end: 25 },
            Segment::Vertical { x: 25, y_start: 3, y_end: 15 },
            Segment::Horizontal { y: 15, x_start: 25, x_end: 20 },
        ];
        assert_eq!(calc_label_position(&segments), Some(Point { x: 25, y: 9 }));
    }
}
```

**What the failing tests assert:** `calc_label_position()` returns the correct midpoint for various segment configurations.
**Expected failure reason:** Function `calc_label_position` does not exist yet.

### ðŸŸ¢ Green: Minimal Implementation

```rust
/// Calculate the label position at the midpoint of a routed path.
///
/// Walks the segments by Manhattan distance and returns the point at 50%
/// of the total path length. Mirrors mermaid's `calcLabelPosition()`.
pub fn calc_label_position(segments: &[Segment]) -> Option<Point> {
    if segments.is_empty() {
        return None;
    }

    let total_length: usize = segments.iter().map(|s| s.length()).sum();
    if total_length == 0 {
        return Some(segments[0].start_point());
    }

    let target = total_length / 2;
    let mut accumulated = 0usize;

    for seg in segments {
        let seg_len = seg.length();
        if accumulated + seg_len >= target {
            let offset_in_seg = target - accumulated;
            return Some(seg.point_at_offset(offset_in_seg));
        }
        accumulated += seg_len;
    }

    segments.last().map(|s| s.end_point())
}
```

### ðŸ”µ Refactor: Clean Up

- Ensure the function is placed near the top of `edge.rs` with other label-related functions, or in a logical grouping.
- Add `use crate::render::router::Segment;` if not already imported.
- Consider visibility: `pub(crate)` is sufficient since it's only used within the render module.

## Context

- Depends on `Segment::length()` and `Segment::point_at_offset()` from Task 1.1.
- `Point` is from `crate::dagre::types::Point`.
- The `>= target` condition (not `> target`) ensures that when the midpoint falls exactly at a segment boundary, we pick the start of that segment rather than the end of the previous one.

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] calc_label_position() implemented and all tests pass
- [ ] Code refactored with tests still green
- [ ] Handles edge cases: empty, zero-length, odd-length paths

# Task 3.1: Add is_backward Field to RoutedEdge

## Objective

Add a `pub is_backward: bool` field to `RoutedEdge` so downstream rendering code can distinguish backward edges without re-deriving from node bounds. The router already computes this â€” we just need to cache it.

## Location

Modify: `~/src/mmdflux-label-dummy/src/render/router.rs`

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

This is primarily a structural change. The "red" phase is the compilation failure from adding the field without updating all construction sites. However, we can also write a test:

```rust
#[test]
fn routed_forward_edge_is_not_backward() {
    // Route a forward edge (A above B in TD) and verify is_backward == false
    // Use a simple two-node TD diagram
    let output = render_input("graph TD\n    A --> B");
    // This test validates the field exists and is set â€” the actual assertion
    // is that the code compiles and runs without panic.
    assert!(!output.is_empty());
}
```

A more direct test would be at the routing level, but that requires constructing `NodeBounds` etc. The key "red" signal is the compilation error when the field is added but not populated at all construction sites.

**Expected failure reason:** `RoutedEdge` does not have an `is_backward` field.

### ðŸŸ¢ Green: Minimal Implementation

1. Add the field to `RoutedEdge`:

```rust
pub struct RoutedEdge {
    pub edge: Edge,
    pub start: Point,
    pub end: Point,
    pub segments: Vec<Segment>,
    pub entry_direction: AttachDirection,
    /// Whether this edge goes backward in the layout direction.
    pub is_backward: bool,
}
```

2. Update all construction sites. Search for `RoutedEdge {` in `router.rs` and set `is_backward` appropriately:

   - In `route_edge_with_waypoints()`: The function already computes `is_backward` via `is_backward_edge()`. Pass the result to the struct.
   - In `route_backward_with_synthetic_waypoints()`: Always `is_backward: true` (this function only handles backward edges).
   - In `route_edge_direct()`: Already computes `is_backward` via `is_backward_edge()`. Pass the result.
   - Any other construction sites (search for `RoutedEdge {`).

### ðŸ”µ Refactor: Clean Up

- Check if any code in `edge.rs` or `layout.rs` re-derives backward status from node bounds â€” it can now use `routed.is_backward` instead.
- Remove any redundant `is_backward_edge()` calls in the rendering layer if they exist.

## Context

- `is_backward_edge()` is at `router.rs:95-110` â€” compares node bounds against layout direction.
- `RoutedEdge` is at `router.rs:57-69`.
- Construction sites are in `route_edge_with_waypoints()`, `route_backward_with_synthetic_waypoints()`, and `route_edge_direct()`.
- This task is independent of Phase 1-2 and can be done in parallel.

## Acceptance Criteria

- [ ] `is_backward` field added to RoutedEdge
- [ ] All construction sites updated with correct values
- [ ] Code compiles and all existing tests pass
- [ ] No redundant backward-edge re-derivation in rendering code

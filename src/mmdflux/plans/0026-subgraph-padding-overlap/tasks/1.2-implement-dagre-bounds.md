# Task 1.2: Implement Dagre Bounds Transformation

## Objective
Modify `convert_subgraph_bounds()` to use dagre's border-node-derived `Rect` bounds instead of recomputing from member-node positions. Transform the dagre Rect through `TransformContext` to get draw coordinates.

## Location
Modify: `/Users/kevin/src/mmdflux-subgraphs/src/render/layout.rs` â€” `convert_subgraph_bounds()` (lines 696-749)

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

Tests from Task 1.1 should already be failing.

### ðŸŸ¢ Green: Minimal Implementation

Modify `convert_subgraph_bounds()`:

1. **Un-prefix the parameters**: Change `_dagre_bounds` to `dagre_bounds` and `_ctx` to `ctx` (or whatever the TransformContext parameter is named).

2. **For each subgraph**, look up its Rect in `dagre_bounds`:
   ```rust
   if let Some(rect) = dagre_bounds.get(&sg_id) {
       // Dagre Rect is center-based: (x, y) is center, (width, height) is full span
       let tl_dagre_x = rect.x - rect.width / 2.0;
       let tl_dagre_y = rect.y - rect.height / 2.0;
       let br_dagre_x = rect.x + rect.width / 2.0;
       let br_dagre_y = rect.y + rect.height / 2.0;

       // Transform through TransformContext to get draw coordinates
       let (tl_x, tl_y) = ctx.to_ascii(tl_dagre_x, tl_dagre_y);
       let (br_x, br_y) = ctx.to_ascii(br_dagre_x, br_dagre_y);

       let draw_x = tl_x as usize;
       let draw_y = tl_y as usize;
       let draw_width = (br_x - tl_x).max(1.0) as usize;
       let draw_height = (br_y - tl_y).max(1.0) as usize;

       // Ensure minimum 1-cell padding around member nodes
       // (dagre border nodes may be at exact member-node edges)
       SubgraphBounds {
           x: draw_x.saturating_sub(1),
           y: draw_y.saturating_sub(1),
           width: draw_width + 2,
           height: draw_height + 2,
           title: sg.title.clone(),
       }
   } else {
       // Fallback: old member-node-based computation
       // (keep existing logic for defensive compatibility)
   }
   ```

3. **Update the call site** (around line 482-489) to pass the actual `dagre_bounds` and `ctx` instead of discarding them.

Key detail: Check the `TransformContext` API â€” it may use `to_draw()` or `dagre_to_draw()` rather than `to_ascii()`. Read the struct definition to find the correct method. The transform must account for scale factors and offsets.

### ðŸ”µ Refactor: Clean Up

- Remove or simplify the fallback path if it's no longer reachable
- Document the center-based Rect semantics in a comment
- Remove the `border_padding` and `title_height` constants if they're only used in the old path
- Ensure `_dagre_bounds` underscore prefix is gone

## Context
- `Rect` from `dagre::border::remove_nodes()` has center-based coordinates (see `src/dagre/border.rs` lines 115-120)
- `TransformContext` handles dagre-float-to-draw-coordinate mapping (read its definition in `layout.rs`)
- The call site passes `result.subgraph_bounds` which is the HashMap from `remove_nodes()`
- See [Q1: Bounds calculation](../../../research/0019-subgraph-padding-overlap/q1-bounds-calculation.md) for the full code path
- See [Q4: dagre.js compound sizing](../../../research/0019-subgraph-padding-overlap/q4-dagre-compound-sizing.md) for how dagre.js derives compound dimensions

## Acceptance Criteria
- [ ] `convert_subgraph_bounds()` uses dagre Rect as primary bounds source
- [ ] TransformContext transforms dagre coordinates to draw coordinates
- [ ] Fallback to member-node computation when dagre bounds unavailable
- [ ] Task 1.1 tests pass (no subgraph overlap)
- [ ] Code refactored, tests still green

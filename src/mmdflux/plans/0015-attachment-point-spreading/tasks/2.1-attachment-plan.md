# Task 2.1: Implement compute_attachment_plan()

## Objective
Create the pre-pass function that analyzes all edges, groups them by (node, face), and computes spread attachment points for each edge.

## Location
Modify: `src/render/router.rs`

## Implementation

```rust
use std::collections::HashMap;
use crate::render::intersect::{NodeFace, classify_face, spread_points_on_face};

/// Pre-computed attachment points for an edge.
/// Contains the (x, y) position where the edge attaches to its source and target nodes.
pub struct AttachmentPlan {
    /// edge_index → (source_attach_point, target_attach_point)
    pub overrides: HashMap<usize, ((usize, usize), (usize, usize))>,
}

/// Computes pre-assigned attachment points for all edges to avoid overlap.
///
/// Groups edges by (node, face) and spreads multiple edges on the same face
/// across the face's available range.
pub fn compute_attachment_plan(
    edges: &[Edge],
    layout: &Layout,
    diagram: &Diagram,
) -> AttachmentPlan {
    // Step 1: For each edge, determine which face it uses on source and target
    // Key: (node_id, face) → Vec<(edge_index, is_source_side)>
    let mut face_groups: HashMap<(String, NodeFace), Vec<(usize, bool)>> = HashMap::new();

    for (i, edge) in edges.iter().enumerate() {
        let src_bounds = match layout.node_bounds.get(&edge.from) {
            Some(b) => b,
            None => continue,
        };
        let tgt_bounds = match layout.node_bounds.get(&edge.to) {
            Some(b) => b,
            None => continue,
        };
        let src_node = diagram.nodes.get(&edge.from);
        let tgt_node = diagram.nodes.get(&edge.to);
        let src_shape = src_node.map(|n| n.shape).unwrap_or(Shape::Rectangle);
        let tgt_shape = tgt_node.map(|n| n.shape).unwrap_or(Shape::Rectangle);

        // Determine approach direction: use first/last waypoint if available, otherwise other node center
        let src_approach = if let Some(waypoints) = layout.edge_waypoints.get(i) {
            if let Some(first) = waypoints.first() {
                *first
            } else {
                (tgt_bounds.center_x(), tgt_bounds.center_y())
            }
        } else {
            (tgt_bounds.center_x(), tgt_bounds.center_y())
        };

        let tgt_approach = if let Some(waypoints) = layout.edge_waypoints.get(i) {
            if let Some(last) = waypoints.last() {
                *last
            } else {
                (src_bounds.center_x(), src_bounds.center_y())
            }
        } else {
            (src_bounds.center_x(), src_bounds.center_y())
        };

        let src_face = classify_face(src_bounds, src_approach, src_shape);
        let tgt_face = classify_face(tgt_bounds, tgt_approach, tgt_shape);

        face_groups
            .entry((edge.from.clone(), src_face))
            .or_default()
            .push((i, true)); // true = source side

        face_groups
            .entry((edge.to.clone(), tgt_face))
            .or_default()
            .push((i, false)); // false = target side
    }

    // Step 2: For each face group, compute spread positions
    let mut overrides: HashMap<usize, ((usize, usize), (usize, usize))> = HashMap::new();

    for ((node_id, face), group) in &face_groups {
        if group.len() <= 1 {
            continue; // Single edge on face — no spreading needed, use default
        }

        let bounds = match layout.node_bounds.get(node_id) {
            Some(b) => b,
            None => continue,
        };

        let extent = bounds.face_extent(face);  // (task 1.2)
        let fixed = bounds.face_fixed_coord(face);

        // Sort edges within group (task 2.2 handles sorting details)
        let mut sorted_group = group.clone();
        sort_face_group(&mut sorted_group, edges, layout, *face);

        let points = spread_points_on_face(*face, fixed, extent, sorted_group.len());

        for (idx, &(edge_i, is_source)) in sorted_group.iter().enumerate() {
            let point = points[idx];
            let entry = overrides.entry(edge_i).or_insert((
                (0, 0), // placeholder source
                (0, 0), // placeholder target
            ));
            if is_source {
                entry.0 = point;
            } else {
                entry.1 = point;
            }
        }
    }

    // Step 3: Fill in missing sides — if an edge only has a source override (because
    // the target face has only 1 edge), we still need the target attachment point.
    // These will be filled by the existing calculate_attachment_points() in routing.

    AttachmentPlan { overrides }
}
```

## Context
- `edge_waypoints` in `Layout` is indexed by edge index — verify this matches the edge slice ordering passed to `route_all_edges()`
- Need to check how backward edges store waypoints — they may be in reversed order. The `classify_face()` call should use the first waypoint from the *source* perspective (closest to source node).
- The `overrides` map may contain partial overrides (only source or only target) when one side has no overlap. The router should use the override when present and fall back to `calculate_attachment_points()` for the other side.

## Acceptance Criteria
- [ ] Groups edges correctly by (node, face)
- [ ] Only computes overrides for faces with >1 edge
- [ ] Uses waypoints when available for face classification
- [ ] Handles edges where only source or only target needs override
- [ ] Returns correct `AttachmentPlan` structure

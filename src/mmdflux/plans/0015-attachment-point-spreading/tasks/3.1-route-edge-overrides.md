# Task 3.1: Modify route_edge() to Accept Attachment Overrides

## Objective
Allow the routing functions to use pre-computed attachment points instead of always computing them from scratch.

## Location
Modify: `src/render/router.rs`

## Implementation

Add an optional override parameter to `route_edge()` and its variants. When an override is provided for a given side (source or target), use it instead of calling `calculate_attachment_points()`.

### Option A: Add parameter to existing functions

```rust
pub fn route_edge(
    edge: &Edge,
    layout: &Layout,
    diagram_direction: Direction,
    attachment_override: Option<&AttachmentPlan>,
    edge_index: usize,
) -> Option<RoutedEdge> {
    // ... existing logic ...
    // When calling route_edge_direct or route_edge_with_waypoints,
    // pass through the override
}
```

In `route_edge_direct()` and `route_edge_with_waypoints()`:

```rust
// Where calculate_attachment_points() is currently called:
let (src_attach, tgt_attach) = if let Some(plan) = attachment_override {
    if let Some(&(src, tgt)) = plan.overrides.get(&edge_index) {
        // Use pre-computed points (but only for sides that have overrides)
        let default = calculate_attachment_points(src_bounds, tgt_bounds, ...);
        let src_point = if src != (0, 0) { src } else { default.0 };
        let tgt_point = if tgt != (0, 0) { tgt } else { default.1 };
        (src_point, tgt_point)
    } else {
        calculate_attachment_points(src_bounds, tgt_bounds, ...)
    }
} else {
    calculate_attachment_points(src_bounds, tgt_bounds, ...)
};
```

### Option B: Pre-populate and pass directly (simpler)

Instead of passing the whole plan, pass just the override for this specific edge:

```rust
pub fn route_edge(
    edge: &Edge,
    layout: &Layout,
    diagram_direction: Direction,
    src_attach_override: Option<(usize, usize)>,
    tgt_attach_override: Option<(usize, usize)>,
) -> Option<RoutedEdge>
```

This is simpler — the caller extracts the relevant override before calling.

## Context
- Read the current signatures of `route_edge()`, `route_edge_direct()`, and `route_edge_with_waypoints()` carefully before choosing the approach
- The `(0, 0)` sentinel for "no override" is fragile — Option B with `Option<(usize, usize)>` is cleaner
- `calculate_attachment_points()` is called in both `route_edge_direct()` and `route_edge_with_waypoints()` — both need the override path
- Backward edges may have their own routing path (`route_backward_edge()`) — check if they also use `calculate_attachment_points()` and need overrides

## Acceptance Criteria
- [ ] `route_edge()` accepts optional attachment overrides
- [ ] When override is provided, it's used instead of `calculate_attachment_points()`
- [ ] When no override, existing behavior is unchanged
- [ ] Both `route_edge_direct()` and `route_edge_with_waypoints()` support overrides
- [ ] Backward edge routing is checked and updated if needed

# Task 3.2: Wire route_all_edges() to Use Attachment Plan

## Objective
Update the `route_all_edges()` entry point to compute the attachment plan first, then pass overrides into each edge's routing.

## Location
Modify: `src/render/router.rs`

## Implementation

```rust
pub fn route_all_edges(
    edges: &[Edge],
    layout: &Layout,
    diagram: &Diagram,
    diagram_direction: Direction,
) -> Vec<RoutedEdge> {
    // Step 1: Compute attachment plan
    let plan = compute_attachment_plan(edges, layout, diagram);

    // Step 2: Route each edge with its override
    edges
        .iter()
        .enumerate()
        .filter_map(|(i, edge)| {
            let (src_override, tgt_override) = if let Some(&(src, tgt)) = plan.overrides.get(&i) {
                (
                    if src != (0, 0) { Some(src) } else { None },
                    if tgt != (0, 0) { Some(tgt) } else { None },
                )
            } else {
                (None, None)
            };
            route_edge(edge, layout, diagram_direction, src_override, tgt_override, i)
        })
        .collect()
}
```

## Context
- `route_all_edges()` is the main entry point called from the render pipeline
- Check the current signature â€” it may need a `&Diagram` parameter added for `compute_attachment_plan()` to access node shapes
- The caller of `route_all_edges()` (likely in `src/render/mod.rs`) will need to pass the `Diagram` reference
- If changing the public API is undesirable, `compute_attachment_plan()` could take the minimum data it needs (node shapes as a separate map) instead of the full `Diagram`

## Acceptance Criteria
- [ ] `route_all_edges()` calls `compute_attachment_plan()` before routing
- [ ] Each edge receives its specific override (or None for non-overlapping edges)
- [ ] The render pipeline compiles and passes the necessary data through
- [ ] Existing single-edge cases produce identical output (no unnecessary overrides)

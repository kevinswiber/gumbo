# Task 1.3: Add spread_points_on_face() Utility

## Objective
Compute evenly-spaced attachment points along a node face for N edges.

## Location
Modify: `src/render/intersect.rs` (or a new `src/render/attachment.rs` if intersect.rs is getting too large)

## Implementation

```rust
/// Computes N evenly-spaced positions along a face.
/// Returns (x, y) coordinates for each position.
///
/// - For Top/Bottom faces: fixed_coord is the y-value, extent is the x-range
/// - For Left/Right faces: fixed_coord is the x-value, extent is the y-range
///
/// When N == 1, returns the center of the range.
/// When N > 1, distributes evenly within the range.
pub fn spread_points_on_face(
    face: NodeFace,
    fixed_coord: usize,
    extent: (usize, usize),
    count: usize,
) -> Vec<(usize, usize)> {
    if count == 0 {
        return vec![];
    }

    let (start, end) = extent;
    let range = end.saturating_sub(start);

    if count == 1 {
        // Single edge: use center of face
        let mid = start + range / 2;
        return match face {
            NodeFace::Top | NodeFace::Bottom => vec![(mid, fixed_coord)],
            NodeFace::Left | NodeFace::Right => vec![(fixed_coord, mid)],
        };
    }

    // Multiple edges: distribute evenly
    // For N edges, divide range into N+1 segments and place at segment boundaries
    // But if range is too small, pack tightly
    let positions: Vec<usize> = if range >= count.saturating_sub(1) {
        (0..count)
            .map(|i| {
                if count == 1 {
                    start + range / 2
                } else {
                    start + (i * range) / (count - 1)
                }
            })
            .collect()
    } else {
        // Face too small â€” pack as tightly as possible from start
        (0..count).map(|i| start + i.min(range)).collect()
    };

    positions
        .into_iter()
        .map(|pos| match face {
            NodeFace::Top | NodeFace::Bottom => (pos, fixed_coord),
            NodeFace::Left | NodeFace::Right => (fixed_coord, pos),
        })
        .collect()
}
```

## Context
- Uses `NodeFace` from task 1.1
- Uses `face_extent()` and `face_fixed_coord()` from task 1.2 (called by the caller, not this function)
- The "N+1 segments" approach for N=2 on a width-10 face gives positions at 0 and 9 (edges of range), which spreads maximally. For N=3: positions at 0, 4, 9.
- When the face is too narrow (e.g., 3-char face with 5 edges), we accept some overlap and pack from start.

## Acceptance Criteria
- [ ] N=1 returns center of face
- [ ] N=2 returns positions at start and end of range (maximal spread)
- [ ] N=3+ distributes evenly
- [ ] Handles degenerate case (range < count) without panicking
- [ ] Returns correct (x, y) orientation for horizontal vs vertical faces
- [ ] Unit tests for various N and range values

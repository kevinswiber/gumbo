# Task 1.1: Add NodeFace Enum and classify_face() Function

## Objective
Add infrastructure to determine which face (top, bottom, left, right) of a node an edge attaches to, given the direction the edge approaches from.

## Location
Modify: `src/render/intersect.rs`

## Implementation

Add the `NodeFace` enum:

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum NodeFace {
    Top,
    Bottom,
    Left,
    Right,
}
```

Add `classify_face()` that reuses the existing ray-intersection logic from `intersect_rect` and `intersect_diamond`:

```rust
/// Determines which face of a node the intersection occurs on,
/// given the node's bounds, shape, and an approach point (first waypoint or other node center).
pub fn classify_face(
    bounds: &NodeBounds,
    approach_point: (usize, usize),
    shape: Shape,
) -> NodeFace {
    let cx = bounds.center_x() as f64;
    let cy = bounds.center_y() as f64;
    let px = approach_point.0 as f64;
    let py = approach_point.1 as f64;

    let dx = px - cx;
    let dy = py - cy;

    // Avoid degenerate case where approach == center
    if dx.abs() < 0.5 && dy.abs() < 0.5 {
        return NodeFace::Bottom; // default for ambiguous
    }

    match shape {
        Shape::Diamond => {
            // Diamond faces: quadrant-based (same logic as intersect_diamond)
            if dy.abs() * bounds.width as f64 > dx.abs() * bounds.height as f64 {
                if dy < 0.0 { NodeFace::Top } else { NodeFace::Bottom }
            } else {
                if dx < 0.0 { NodeFace::Left } else { NodeFace::Right }
            }
        }
        _ => {
            // Rectangle/Round: compare slope against diagonal
            let half_w = bounds.width as f64 / 2.0;
            let half_h = bounds.height as f64 / 2.0;

            if half_w < 0.5 || half_h < 0.5 {
                return NodeFace::Bottom;
            }

            // Use the same slope comparison as intersect_rect
            if dy.abs() / half_h > dx.abs() / half_w {
                if dy < 0.0 { NodeFace::Top } else { NodeFace::Bottom }
            } else {
                if dx < 0.0 { NodeFace::Left } else { NodeFace::Right }
            }
        }
    }
}
```

Add unit tests:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_classify_face_rect() {
        let bounds = NodeBounds { x: 10, y: 5, width: 10, height: 3 };
        // Point above → Top
        assert_eq!(classify_face(&bounds, (15, 0), Shape::Rectangle), NodeFace::Top);
        // Point below → Bottom
        assert_eq!(classify_face(&bounds, (15, 10), Shape::Rectangle), NodeFace::Bottom);
        // Point left → Left
        assert_eq!(classify_face(&bounds, (0, 6), Shape::Rectangle), NodeFace::Left);
        // Point right → Right
        assert_eq!(classify_face(&bounds, (25, 6), Shape::Rectangle), NodeFace::Right);
    }

    #[test]
    fn test_classify_face_diamond() {
        let bounds = NodeBounds { x: 10, y: 5, width: 12, height: 3 };
        assert_eq!(classify_face(&bounds, (16, 0), Shape::Diamond), NodeFace::Top);
        assert_eq!(classify_face(&bounds, (16, 12), Shape::Diamond), NodeFace::Bottom);
        assert_eq!(classify_face(&bounds, (0, 6), Shape::Diamond), NodeFace::Left);
        assert_eq!(classify_face(&bounds, (30, 6), Shape::Diamond), NodeFace::Right);
    }
}
```

## Context
- `Shape` enum is in `src/graph/node.rs` — import it
- The existing `intersect_rect()` and `intersect_diamond()` in `intersect.rs` use similar slope/quadrant logic for computing the actual intersection point; `classify_face()` just needs the face, not the exact point
- `NodeBounds` is in `src/render/shape.rs` with `center_x()`, `center_y()`, `width`, `height`

## Acceptance Criteria
- [ ] `NodeFace` enum with Top, Bottom, Left, Right variants
- [ ] `classify_face()` handles Rectangle, Round, and Diamond shapes
- [ ] Unit tests pass for all four faces with both rect and diamond
- [ ] Degenerate case (approach == center) returns a sensible default

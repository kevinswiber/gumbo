# Task 3.2: Wire into route_edge() and Add Canvas Margin

## Objective

Integrate `generate_backward_waypoints()` into the edge routing pipeline so that single-rank-span backward edges use synthetic waypoints instead of direct routing. Add canvas margin to accommodate the wider paths.

## Location

Modify: `src/render/router.rs` â€” `route_edge()` function
Modify: `src/render/layout.rs` â€” canvas size computation

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[test]
fn test_backward_edge_has_waypoints_in_route() {
    // Render simple_cycle.mmd and check the backward edge
    // has >= 4 path segments (not a straight 2-segment line)
    let input = std::fs::read_to_string("tests/fixtures/simple_cycle.mmd").unwrap();
    let flowchart = parse_flowchart(&input).unwrap();
    let diagram = build_diagram(&flowchart);
    let config = RenderConfig::default();
    let output = render(&diagram, &config);

    // The backward edge should route around the side, not straight through
    // Verify by checking the output contains edge characters to the right
    // of the rightmost node boundary
    // (Specific assertion depends on actual rendering output)
    assert!(
        output.lines().any(|line| {
            // Look for edge characters beyond the right side of nodes
            let trimmed_end = line.trim_end();
            trimmed_end.len() > 20 // rough check: output is wider due to routing
        }),
        "backward edge should route around nodes, making output wider"
    );
}
```

**What the failing test asserts:** The rendered output of a cycle diagram routes backward edges around the nodes, producing wider output.
**Expected failure reason:** Current backward edges route straight through the gap.

### ðŸŸ¢ Green: Minimal Implementation

In `route_edge()`, after checking for dagre waypoints and before falling through to `route_edge_direct()`:

```rust
pub fn route_edge(
    edge: &Edge,
    endpoints: &EdgeEndpoints,
    layout: &Layout,
    diagram_direction: Direction,
    src_attach_override: Option<(usize, usize)>,
    tgt_attach_override: Option<(usize, usize)>,
) -> Vec<(usize, usize)> {
    let from_bounds = /* ... existing code ... */;
    let to_bounds = /* ... existing code ... */;

    // Check for dagre-assigned waypoints
    if let Some(waypoints) = layout.edge_waypoints.get(&edge_key) {
        return route_edge_with_waypoints(/* ... */);
    }

    // For backward edges with no dagre waypoints, generate synthetic ones
    let is_backward = is_backward_edge(&from_bounds, &to_bounds, diagram_direction);
    if is_backward {
        let synthetic_wps = generate_backward_waypoints(
            &from_bounds, &to_bounds, diagram_direction,
        );
        if !synthetic_wps.is_empty() {
            return route_edge_with_waypoints(
                edge, endpoints, &synthetic_wps, diagram_direction,
                src_attach_override, tgt_attach_override,
            );
        }
    }

    // Fall through to direct routing
    route_edge_direct(/* ... */)
}
```

For canvas margin in `compute_layout_direct()` (or equivalent in `layout.rs`):

```rust
// Add margin for backward edge routing
let has_backward_edges = diagram.edges.iter().any(|e| {
    // Check if edge would be backward based on node positions
    // ... detection logic ...
});
let backward_margin = if has_backward_edges { BACKWARD_ROUTE_GAP + 2 } else { 0 };
let canvas_width = base_width + backward_margin;
let canvas_height = base_height + backward_margin;
```

### ðŸ”µ Refactor: Clean Up

- Verify that `route_edge_with_waypoints()` handles the synthetic waypoints correctly â€” they may need to be in dagre coordinate space or draw coordinate space depending on where the conversion happens
- Check if the canvas margin calculation is in the right place (before or after coordinate translation)
- Update `simple_cycle.mmd` and `multiple_cycles.mmd` snapshot baselines
- Visually verify the updated renderings look correct

## Context

Key question: the synthetic waypoints from `generate_backward_waypoints()` are in draw-coordinate space (pixel/cell positions), while dagre waypoints are in dagre-coordinate space. Need to check which space `route_edge_with_waypoints()` expects and ensure consistency.

Check `route_edge_with_waypoints()` signature and how it uses waypoints â€” does it expect dagre Points that get translated, or already-translated draw coordinates?

The `BACKWARD_ROUTE_GAP` constant from Task 3.1 determines how far from the node boundary the synthetic path goes.

## Acceptance Criteria

- [ ] Failing test written and confirmed red
- [ ] `route_edge()` checks for backward edges and generates synthetic waypoints
- [ ] Canvas margin accounts for wider backward-edge paths
- [ ] `simple_cycle.mmd` renders with backward edge routed around nodes
- [ ] `multiple_cycles.mmd` renders correctly
- [ ] All other tests pass (no regressions)
- [ ] Snapshot baselines updated
- [ ] Code refactored with tests still green
- [ ] Commit: "feat(plan-0021): Phase 3 - synthetic waypoints for backward edges"

# Task 1.1: Replace Centering Formula with Endpoint-Maximizing Formula

## Objective

Change `spread_points_on_face()` to always use the endpoint formula `(i * range) / (count - 1)` for `count >= 2`, eliminating the centering formula `((i+1) * range) / (count+1)` that wastes edge space.

## Location

Modify: `src/render/intersect.rs` â€” `spread_points_on_face()` function (lines ~85-97)

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

Write a test that asserts endpoint-maximizing positions, which will fail with the current centering formula:

```rust
#[test]
fn test_spread_points_endpoint_maximizing() {
    // 2 edges on range (10, 13), range=3
    // Current centering: positions at 11, 12 (1-cell gap)
    // Endpoint: positions at 10, 13 (3-cell gap, maximized)
    let points = spread_points_on_face(NodeFace::Top, 5, (10, 13), 2);
    assert_eq!(points, vec![(10, 5), (13, 5)]);
}

#[test]
fn test_spread_points_two_on_wide_range() {
    // 2 edges on range (0, 8), range=8
    // Current centering: positions at 2, 5
    // Endpoint: positions at 0, 8
    let points = spread_points_on_face(NodeFace::Top, 0, (0, 8), 2);
    assert_eq!(points, vec![(0, 0), (8, 0)]);
}
```

**What the failing test asserts:** Two edges should be placed at the extremes of the range (start and end), not centered inward.
**Expected failure reason:** Current centering formula produces (11,5),(12,5) instead of (10,5),(13,5).

### ðŸŸ¢ Green: Minimal Implementation

Replace the two-branch logic in `spread_points_on_face()` with a single endpoint formula for `count >= 2`:

```rust
pub fn spread_points_on_face(
    face: NodeFace,
    fixed_coord: usize,
    extent: (usize, usize),
    count: usize,
) -> Vec<(usize, usize)> {
    let (start, end) = extent;
    let range = end.saturating_sub(start);

    if count == 0 {
        return vec![];
    }
    if count == 1 {
        let mid = start + range / 2;
        return vec![match face {
            NodeFace::Top | NodeFace::Bottom => (mid, fixed_coord),
            NodeFace::Left | NodeFace::Right => (fixed_coord, mid),
        }];
    }

    // Endpoint-maximizing: place at extremes of range
    (0..count)
        .map(|i| {
            let pos = start + (i * range) / (count - 1);
            let pos = pos.min(end);
            match face {
                NodeFace::Top | NodeFace::Bottom => (pos, fixed_coord),
                NodeFace::Left | NodeFace::Right => (fixed_coord, pos),
            }
        })
        .collect()
}
```

### ðŸ”µ Refactor: Clean Up

- Remove the `use_endpoints` boolean and the old centering branch entirely
- Simplify the function structure â€” the old two-branch conditional is no longer needed
- Ensure the `count == 1` case still centers the single point

## Context

The current implementation has two branches:
- `use_endpoints` (when `range < count`): already uses `(i * range) / (count - 1)` â€” the endpoint formula
- Normal: uses `((i + 1) * range) / (count + 1)` â€” centering formula

The centering formula places edges inward from the face edges, wasting space. For 2 edges on a 3-cell range, it produces positions 1,2 (gap=1) instead of 0,3 (gap=3). The endpoint formula maximizes separation.

## Acceptance Criteria

- [ ] Failing test written and confirmed red
- [ ] `spread_points_on_face()` uses endpoint formula for all count >= 2
- [ ] Old centering formula and `use_endpoints` branch removed
- [ ] count=0 returns empty, count=1 returns centered point
- [ ] Code refactored with tests still green

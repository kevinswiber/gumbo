# Task 2.1: Add MIN_ATTACHMENT_GAP Enforcement

## Objective

Add minimum gap enforcement to `spread_points_on_face()` so that attachment points never get closer than `MIN_ATTACHMENT_GAP` cells apart. When the face is too narrow, degrade gracefully by clamping to available space.

## Location

Modify: `src/render/intersect.rs` â€” `spread_points_on_face()` and new constant
Create: `tests/fixtures/very_narrow_fan_in.mmd` â€” new test fixture

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
const MIN_ATTACHMENT_GAP: usize = 2;

#[test]
fn test_spread_points_min_gap_narrow_face() {
    // 4 edges on range (10, 14), range=4
    // Endpoint formula without gap: positions 10, 11, 12, 14
    // With MIN_GAP=2: positions should be at least 2 apart
    // Best fit: 10, 12, 14 â€” but 4 edges don't fit in range 4 with gap 2
    // Graceful degradation: some positions collapse
    let points = spread_points_on_face(NodeFace::Top, 5, (10, 14), 4);
    // Assert minimum gap is enforced where possible
    for window in points.windows(2) {
        let (x1, _) = window[0];
        let (x2, _) = window[1];
        // Either gap >= MIN_GAP or position is clamped to end
        assert!(x2 >= x1, "positions must be non-decreasing");
    }
}

#[test]
fn test_spread_points_min_gap_wide_face() {
    // 3 edges on range (0, 20), range=20
    // Endpoint formula: positions 0, 10, 20 â€” all gaps >= 2
    // MIN_GAP should not alter these positions
    let points = spread_points_on_face(NodeFace::Top, 0, (0, 20), 3);
    assert_eq!(points, vec![(0, 0), (10, 0), (20, 0)]);
}

#[test]
fn test_spread_points_min_gap_exact_fit() {
    // 3 edges on range (0, 4), range=4, MIN_GAP=2
    // Endpoint: 0, 2, 4 â€” exactly fits with gap=2
    let points = spread_points_on_face(NodeFace::Top, 0, (0, 4), 3);
    assert_eq!(points, vec![(0, 0), (2, 0), (4, 0)]);
}
```

**What the failing tests assert:** Adjacent attachment points are at least MIN_ATTACHMENT_GAP apart when the face is wide enough.
**Expected failure reason:** Current implementation has no gap enforcement â€” narrow faces produce tightly packed positions.

### ðŸŸ¢ Green: Minimal Implementation

Add the constant and post-processing gap enforcement:

```rust
/// Minimum gap between adjacent attachment points on a face.
const MIN_ATTACHMENT_GAP: usize = 2;

pub fn spread_points_on_face(
    face: NodeFace,
    fixed_coord: usize,
    extent: (usize, usize),
    count: usize,
) -> Vec<(usize, usize)> {
    let (start, end) = extent;
    let range = end.saturating_sub(start);

    if count == 0 { return vec![]; }
    if count == 1 {
        let mid = start + range / 2;
        return vec![match face {
            NodeFace::Top | NodeFace::Bottom => (mid, fixed_coord),
            NodeFace::Left | NodeFace::Right => (fixed_coord, mid),
        }];
    }

    // Compute ideal positions with endpoint formula
    let mut positions: Vec<usize> = (0..count)
        .map(|i| start + (i * range) / (count - 1))
        .collect();

    // Enforce minimum gap between adjacent positions
    for i in 1..positions.len() {
        let min_pos = positions[i - 1] + MIN_ATTACHMENT_GAP;
        if positions[i] < min_pos {
            positions[i] = min_pos;
        }
    }

    // If gap enforcement pushed positions past end, center the spread
    if let Some(&last) = positions.last() {
        if last > end {
            let total_span = last - positions[0];
            let available = range;
            if total_span > available {
                // Can't fit all with MIN_GAP â€” center what we have
                let center_offset = start;
                for (i, pos) in positions.iter_mut().enumerate() {
                    *pos = center_offset + (i * range) / (count - 1);
                }
            } else {
                // Shift everything back to fit within range
                let overshoot = last - end;
                for pos in &mut positions {
                    *pos = pos.saturating_sub(overshoot);
                }
            }
        }
    }

    // Clamp all to valid range
    for pos in &mut positions {
        *pos = (*pos).max(start).min(end);
    }

    positions
        .into_iter()
        .map(|pos| match face {
            NodeFace::Top | NodeFace::Bottom => (pos, fixed_coord),
            NodeFace::Left | NodeFace::Right => (fixed_coord, pos),
        })
        .collect()
}
```

### ðŸ”µ Refactor: Clean Up

- Consider whether the centering fallback (when positions overflow) should use a different strategy
- Ensure the gap enforcement loop is clear and well-commented
- Verify that the wide-face case (no gap issues) is a no-op pass-through
- Run all integration tests to check no regressions

## Context

The `very_narrow_fan_in.mmd` fixture should be:
```
graph TD
    A[X] --> E[Y]
    B[X] --> E
    C[X] --> E
    D[X] --> E
```

This creates 4 edges converging on node E (label "Y", narrow width). With 4 edges on a small face extent and MIN_GAP=2, the gap enforcement activates.

Arrow characters are 1 cell wide. With a connection line on one side, MIN_GAP=2 ensures at least 1 blank cell between adjacent edge lines, preventing visual merging.

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] MIN_ATTACHMENT_GAP constant added
- [ ] Gap enforcement logic implemented in spread_points_on_face()
- [ ] Wide faces unaffected (positions identical to Phase 1)
- [ ] Narrow faces degrade gracefully (no panic, positions clamped)
- [ ] New test fixture created
- [ ] Code refactored with tests still green
- [ ] Commit: "feat(plan-0021): Phase 2 - minimum attachment gap enforcement"

# Task 3.1: Implement generate_backward_waypoints()

## Objective

Create a function that generates synthetic waypoints for single-rank-span backward edges, routing them around the side of the nodes instead of straight through the inter-rank gap.

## Location

New function in: `src/render/router.rs`

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_backward_waypoints_td() {
        // TD layout: source (B) is below target (A)
        // B at y=6, A at y=0
        // Expect waypoints to the right of both nodes
        let src_bounds = NodeBounds { x: 4, y: 6, width: 8, height: 3 };
        let tgt_bounds = NodeBounds { x: 4, y: 0, width: 8, height: 3 };
        let direction = Direction::TopDown;

        let waypoints = generate_backward_waypoints(
            &src_bounds, &tgt_bounds, direction,
        );

        assert!(!waypoints.is_empty(), "should produce waypoints");
        // Waypoints should extend to the right of both nodes
        let max_right = src_bounds.x + src_bounds.width;
        for wp in &waypoints {
            assert!(wp.x > max_right, "waypoints should be right of nodes");
        }
    }

    #[test]
    fn test_generate_backward_waypoints_lr() {
        // LR layout: source (B) is right of target (A)
        // B at x=12, A at x=0
        // Expect waypoints below both nodes
        let src_bounds = NodeBounds { x: 12, y: 2, width: 8, height: 3 };
        let tgt_bounds = NodeBounds { x: 0, y: 2, width: 8, height: 3 };
        let direction = Direction::LeftRight;

        let waypoints = generate_backward_waypoints(
            &src_bounds, &tgt_bounds, direction,
        );

        assert!(!waypoints.is_empty(), "should produce waypoints");
        // Waypoints should extend below both nodes
        let max_bottom = src_bounds.y + src_bounds.height;
        for wp in &waypoints {
            assert!(wp.y > max_bottom, "waypoints should be below nodes");
        }
    }

    #[test]
    fn test_generate_backward_waypoints_not_backward() {
        // Forward edge: should return empty (no synthetic waypoints)
        let src_bounds = NodeBounds { x: 4, y: 0, width: 8, height: 3 };
        let tgt_bounds = NodeBounds { x: 4, y: 6, width: 8, height: 3 };
        let direction = Direction::TopDown;

        // This is a forward edge (src above target in TD)
        // Function should not be called for forward edges,
        // but if it is, it should return empty
        let waypoints = generate_backward_waypoints(
            &src_bounds, &tgt_bounds, direction,
        );
        assert!(waypoints.is_empty());
    }
}
```

**What the failing tests assert:** `generate_backward_waypoints()` returns waypoints that route around the side of the nodes for backward edges.
**Expected failure reason:** Function does not exist yet.

### ðŸŸ¢ Green: Minimal Implementation

```rust
/// Gap between node boundary and synthetic waypoint path (in cells).
const BACKWARD_ROUTE_GAP: usize = 2;

/// Generate synthetic waypoints for a single-rank-span backward edge
/// that has no dagre-assigned waypoints. Routes around the right side
/// (TD/BT) or bottom side (LR/RL) of the nodes.
pub fn generate_backward_waypoints(
    src_bounds: &NodeBounds,
    tgt_bounds: &NodeBounds,
    direction: Direction,
) -> Vec<Point> {
    match direction {
        Direction::TopDown | Direction::BottomTop => {
            // Check if actually backward
            let is_backward = match direction {
                Direction::TopDown => src_bounds.y > tgt_bounds.y,
                Direction::BottomTop => src_bounds.y < tgt_bounds.y,
                _ => unreachable!(),
            };
            if !is_backward {
                return vec![];
            }

            // Route to the right of both nodes
            let right_edge = (src_bounds.x + src_bounds.width)
                .max(tgt_bounds.x + tgt_bounds.width);
            let route_x = right_edge + BACKWARD_ROUTE_GAP;

            let src_center_y = src_bounds.y + src_bounds.height / 2;
            let tgt_center_y = tgt_bounds.y + tgt_bounds.height / 2;

            vec![
                Point { x: route_x, y: src_center_y },
                Point { x: route_x, y: tgt_center_y },
            ]
        }
        Direction::LeftRight | Direction::RightLeft => {
            let is_backward = match direction {
                Direction::LeftRight => src_bounds.x > tgt_bounds.x,
                Direction::RightLeft => src_bounds.x < tgt_bounds.x,
                _ => unreachable!(),
            };
            if !is_backward {
                return vec![];
            }

            // Route below both nodes
            let bottom_edge = (src_bounds.y + src_bounds.height)
                .max(tgt_bounds.y + tgt_bounds.height);
            let route_y = bottom_edge + BACKWARD_ROUTE_GAP;

            let src_center_x = src_bounds.x + src_bounds.width / 2;
            let tgt_center_x = tgt_bounds.x + tgt_bounds.width / 2;

            vec![
                Point { x: src_center_x, y: route_y },
                Point { x: tgt_center_x, y: route_y },
            ]
        }
    }
}
```

### ðŸ”µ Refactor: Clean Up

- Consider whether BT should route left (instead of right) and RL should route above (instead of below)
- Extract the backward-detection logic if it duplicates `is_backward_edge()`
- Ensure the function handles same-position nodes (self-loop case) gracefully â€” return empty for now, add TODO for self-loop support

## Context

The `Point` type is from `src/dagre/types.rs`. `NodeBounds` is defined in `src/render/layout.rs` (or `shape.rs`). Check the exact types and imports before implementing.

Self-loops (A-->A) are explicitly deferred â€” this task handles only edges between two different nodes.

## Acceptance Criteria

- [ ] Failing tests written and confirmed red
- [ ] `generate_backward_waypoints()` implemented
- [ ] TD/BT routes to the right of nodes
- [ ] LR/RL routes below nodes
- [ ] Forward edges return empty vec
- [ ] Self-loops return empty vec (deferred)
- [ ] Code refactored with tests still green

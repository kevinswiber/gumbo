# Task 2.1: Rewrite label position transform to use rank-based snapping

## Objective

Replace the gap-midpoint heuristic in `transform_label_positions_direct()` with rank-based snapping via `layer_starts[rank]`, matching how `transform_waypoints_direct()` works. This ensures label positions and waypoints use the same coordinate system.

## Location

Modify: `src/render/layout.rs` â€” `transform_label_positions_direct()` (lines 749-799) and its call site in `compute_layout_direct()` (~lines 426-434)

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[test]
fn label_position_uses_layer_starts() {
    use crate::dagre::types::WaypointWithRank;
    use crate::dagre::Point;

    let mut label_positions = HashMap::new();
    label_positions.insert(0, WaypointWithRank {
        point: Point { x: 100.0, y: 75.0 },
        rank: 1,
    });

    let edges = vec![Edge {
        from: "A".to_string(),
        to: "B".to_string(),
        label: Some("test".to_string()),
        stroke: Stroke::Solid,
        arrow: Arrow::Normal,
    }];

    let layer_starts = vec![0, 10, 20]; // rank 0 â†’ y=0, rank 1 â†’ y=10, rank 2 â†’ y=20
    let ctx = TransformContext {
        scale_x: 0.1,
        scale_y: 0.1,
        left_margin: 0,
        top_margin: 0,
    };

    let result = transform_label_positions_direct(
        &label_positions, &edges, &ctx, &layer_starts,
        true, // is_vertical
        80, 40,
    );

    let key = ("A".to_string(), "B".to_string());
    let pos = result.get(&key).unwrap();
    // Primary axis (y) should be layer_starts[1] = 10, not a midpoint heuristic
    assert_eq!(pos.1, 10, "y should be layer_starts[rank=1] = 10, got {}", pos.1);
}
```

**What the failing test asserts:** Primary axis coordinate comes from `layer_starts[rank]`, not gap midpoint.
**Expected failure reason:** Current function signature takes `node_bounds` not `layer_starts`, and computes `(src_bottom + tgt_top) / 2`.

### ðŸŸ¢ Green: Minimal Implementation

```rust
fn transform_label_positions_direct(
    label_positions: &HashMap<usize, WaypointWithRank>,
    edges: &[Edge],
    ctx: &TransformContext,
    layer_starts: &[usize],
    is_vertical: bool,
    canvas_width: usize,
    canvas_height: usize,
) -> HashMap<(String, String), (usize, usize)> {
    let mut converted = HashMap::new();

    for (edge_idx, wp) in label_positions {
        if let Some(edge) = edges.get(*edge_idx) {
            let key = (edge.from.clone(), edge.to.clone());
            let rank_idx = wp.rank as usize;
            let layer_pos = layer_starts.get(rank_idx).copied().unwrap_or(0);
            let (scaled_x, scaled_y) = ctx.to_ascii(wp.point.x, wp.point.y);

            let pos = if is_vertical {
                (
                    scaled_x.min(canvas_width.saturating_sub(1)),
                    layer_pos,
                )
            } else {
                (
                    layer_pos,
                    scaled_y.min(canvas_height.saturating_sub(1)),
                )
            };
            converted.insert(key, pos);
        }
    }

    converted
}
```

Update the call site in `compute_layout_direct()` to pass `&layer_starts` instead of `&node_bounds`:

```rust
let label_positions = transform_label_positions_direct(
    &layout_result.label_positions,
    &diagram.edges,
    &ctx,
    &layer_starts, // was: &node_bounds
    is_vertical,
    canvas_width,
    canvas_height,
);
```

### ðŸ”µ Refactor: Clean Up

- Remove the `node_bounds` parameter from the function signature (it's no longer needed)
- Update existing tests that called the old signature
- Remove the gap-midpoint computation code entirely

## Context

- `transform_waypoints_direct()` (lines 706-741) already does rank-based snapping: `layer_starts.get(rank_idx).copied().unwrap_or(0)` â€” we're matching this pattern
- `WaypointWithRank` carries `.rank` from dagre (integer rank index)
- `layer_starts` is computed from node positions in `compute_layer_starts()` and represents the ASCII y-coordinate of each rank's center

## Acceptance Criteria

- [ ] Failing test written and confirmed red
- [ ] Function rewritten to use `layer_starts[rank]` for primary axis
- [ ] Call site updated to pass `layer_starts` instead of `node_bounds`
- [ ] Old gap-midpoint heuristic code removed
- [ ] Existing label position tests updated
- [ ] `cargo test` passes

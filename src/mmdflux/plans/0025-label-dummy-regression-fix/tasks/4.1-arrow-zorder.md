# Task 4.1: Add node-content protection to `draw_arrow_with_entry()`

## Objective

Prevent `draw_arrow_with_entry()` from overwriting node content. Currently it uses `canvas.set()` unconditionally, corrupting node text when backward edge paths cross node territories.

## Location

Modify: `src/render/edge.rs` â€” `draw_arrow_with_entry()` (lines 568-585)

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[test]
fn draw_arrow_does_not_overwrite_node_content() {
    use super::*;

    let charset = CharSet::unicode();
    let mut canvas = Canvas::new(10, 10);

    // Mark a cell as node content
    canvas.set_node(5, 5, 'X');

    // Try to draw an arrow at the same position
    let point = Point { x: 5, y: 5 };
    draw_arrow_with_entry(&mut canvas, &point, AttachDirection::Top, &charset);

    // The cell should still contain 'X', not an arrow
    let cell = canvas.get(5, 5).unwrap();
    assert_eq!(cell.ch, 'X', "Arrow should not overwrite node content");
    assert!(cell.is_node, "Cell should still be marked as node");
}

#[test]
fn draw_arrow_writes_on_non_node_cell() {
    use super::*;

    let charset = CharSet::unicode();
    let mut canvas = Canvas::new(10, 10);

    // Draw an arrow on an empty cell (no node)
    let point = Point { x: 5, y: 5 };
    draw_arrow_with_entry(&mut canvas, &point, AttachDirection::Top, &charset);

    // Should succeed â€” arrow should be drawn
    let cell = canvas.get(5, 5).unwrap();
    assert_eq!(cell.ch, charset.arrow_down, "Arrow should be drawn on empty cell");
}
```

**What the failing test asserts:** Arrow drawing skips cells marked as node content.
**Expected failure reason:** `canvas.set()` overwrites unconditionally â€” no `is_node` check.

### ðŸŸ¢ Green: Minimal Implementation

```rust
fn draw_arrow_with_entry(
    canvas: &mut Canvas,
    point: &Point,
    entry_direction: AttachDirection,
    charset: &CharSet,
) {
    // Protect node content from being overwritten by arrows
    if let Some(cell) = canvas.get(point.x, point.y) {
        if cell.is_node {
            return;
        }
    }

    let arrow_char = match entry_direction {
        AttachDirection::Top => charset.arrow_down,
        AttachDirection::Bottom => charset.arrow_up,
        AttachDirection::Left => charset.arrow_right,
        AttachDirection::Right => charset.arrow_left,
    };

    canvas.set(point.x, point.y, arrow_char);
}
```

### ðŸ”µ Refactor: Clean Up

- Verify that `canvas.get()` returns `Option<&Cell>` with `is_node` field (check `canvas.rs`)
- Check if `set_node()` exists or if node cells are marked via `set_with_connection()` â€” adapt the test setup accordingly

## Context

- Label drawing at `edge.rs:210-211` already does `!cell.is_node` check before overwriting
- `canvas.set()` at `canvas.rs` overwrites unconditionally
- `canvas.set_with_connection()` at `canvas.rs:155` already has node protection
- The z-order bug manifests as "Val**â–²**d?" in diamond nodes when backward edges cross them
- This is a latent bug on the main branch that the label-dummy approach exposes more frequently

## Acceptance Criteria

- [ ] Failing test written and confirmed red
- [ ] Arrow drawing checks `is_node` before writing
- [ ] Non-node cells still get arrows drawn correctly
- [ ] `cargo test` passes

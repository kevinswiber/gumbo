# Task 3.1: Strip dagre waypoints for backward edges

## Objective

Remove dagre-assigned waypoints from backward edges after coordinate transformation, so the router falls through to compact synthetic waypoint generation via `generate_backward_waypoints()`.

## Location

Modify: `src/render/layout.rs` â€” `compute_layout_direct()` (after waypoint transformation, before returning Layout)

## TDD Phases

### ðŸ”´ Red: Write Failing Tests

```rust
#[test]
fn backward_edge_no_dagre_waypoints() {
    // Render a diagram with a backward edge and verify it doesn't have
    // dagre waypoints (which create tall vertical columns).
    let input = "graph TD\nA[Start]-->B[Process]\nB-->C[End]\nC-->A";
    let flowchart = mmdflux::parser::parse_flowchart(input).unwrap();
    let diagram = mmdflux::graph::build_diagram(&flowchart);
    let output = mmdflux::render::render(&diagram, &Default::default());

    let line_count = output.lines().count();
    // Without the fix, backward edge dagre waypoints create tall columns.
    // With synthetic routing, the layout should be compact.
    assert!(
        line_count < 25,
        "Diagram with backward edge should be compact, got {line_count} lines"
    );
}
```

**What the failing test asserts:** Backward edge produces compact output, not inflated by dagre waypoints.
**Expected failure reason:** With global minlen=2, the backward edge gets normalization dummies and dagre waypoints that inflate the layout.

### ðŸŸ¢ Green: Minimal Implementation

In `compute_layout_direct()`, after transforming waypoints (Phase H/I section), add:

```rust
// Strip dagre waypoints from backward edges.
// Backward edges should use synthetic compact routing, not inflated dagre waypoints
// that create tall vertical columns.
for edge in &diagram.edges {
    let key = (edge.from.clone(), edge.to.clone());
    if let (Some(from_b), Some(to_b)) = (node_bounds.get(&edge.from), node_bounds.get(&edge.to)) {
        if router::is_backward_edge(from_b, to_b, diagram.direction) {
            edge_waypoints_final.remove(&key);
        }
    }
}
```

`router::is_backward_edge` is already `pub` in `src/render/router.rs:95`.

### ðŸ”µ Refactor: Clean Up

- Add a comment explaining why backward edges need synthetic routing
- Consider whether backward edge label positions should also be stripped (likely not â€” label placement uses the routed path, not dagre positions)

## Context

- With global minlen=2, backward edges that were single-rank span become multi-rank span after normalization
- dagre assigns these dummy positions that span the full diagram height
- The router at `router.rs:197-221` checks for waypoints first, falling through to `generate_backward_waypoints()` only when none exist
- `router::is_backward_edge()` uses geometric position comparison (e.g., TD: `tgt.y < src.y`)
- `NodeBounds` is available from the node_bounds HashMap built earlier in `compute_layout_direct()`

## Acceptance Criteria

- [ ] Failing test written and confirmed red
- [ ] Backward edge waypoints stripped after transformation
- [ ] Router falls through to synthetic compact routing for backward edges
- [ ] Forward edges retain their dagre waypoints
- [ ] `cargo test` passes
